<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>State Machine Architecture - ZisK Documentation</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../../favicon.svg">
        <link rel="shortcut icon" href="../../favicon.png">
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        <link rel="stylesheet" href="../../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">ZisK Documentation</h1>

                    <div class="right-buttons">
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="state-machine-architecture"><a class="header" href="#state-machine-architecture">State Machine Architecture</a></h1>
<p>ZisK uses a modular state machine architecture that breaks program execution into specialized processing units. Rather than using a single monolithic processor, ZisK decomposes computation into domain-specific state machines that handle arithmetic, memory, binary operations, and program storage independently. This specialization enables targeted optimizations and parallel processing while maintaining the mathematical rigor required for zero-knowledge proof generation.</p>
<h2 id="why-specialized-state-machines"><a class="header" href="#why-specialized-state-machines">Why Specialized State Machines?</a></h2>
<p>Traditional virtual machines use general-purpose processors that handle all operations uniformly. ZisK recognizes that different types of computations have fundamentally different mathematical properties and constraint requirements. By creating dedicated state machines for each domain, ZisK can apply optimizations that would be impossible in a general-purpose design.</p>
<p>Each state machine is designed specifically for <strong>witness computation</strong> - the process of generating mathematical evidence needed for zero-knowledge proofs. Every operation and state transition gets captured in a format that directly feeds into the constraint system.</p>
<h2 id="core-interface-instance-trait"><a class="header" href="#core-interface-instance-trait">Core Interface: Instance Trait</a></h2>
<p>Every state machine implements the <code>Instance</code> trait, which defines the standard interface for all computational units in ZisK.</p>
<p><strong>File:</strong> <code>common/src/component/component_instance.rs</code></p>
<p>rust</p>
<pre><code class="language-rust">pub trait Instance&lt;F: PrimeField64&gt;: Send + Sync {
    /// Computes the witness for the instance based on the proof context
    fn compute_witness(
        &amp;self,
        _pctx: &amp;ProofCtx&lt;F&gt;,
        _sctx: &amp;SetupCtx&lt;F&gt;,
        _collectors: Vec&lt;(usize, Box&lt;dyn BusDevice&lt;PayloadType&gt;&gt;)&gt;,
        trace_buffer: Vec&lt;F&gt;,
    ) -&gt; Option&lt;AirInstance&lt;F&gt;&gt; { None }
    
    /// Retrieves the checkpoint associated with the instance
    fn check_point(&amp;self) -&gt; CheckPoint;
    
    /// Retrieves the type of the instance
    fn instance_type(&amp;self) -&gt; InstanceType;
    
    /// Builds an input collector for the instance
    fn build_inputs_collector(
        &amp;self,
        chunk_id: ChunkId,
    ) -&gt; Option&lt;Box&lt;dyn BusDevice&lt;PayloadType&gt;&gt;&gt; { None }
    
    fn debug(&amp;self, _pctx: &amp;ProofCtx&lt;F&gt;, _sctx: &amp;SetupCtx&lt;F&gt;) {}
    fn reset(&amp;self) {}
}</code></pre>
<p><strong>Key methods explained:</strong></p>
<p><strong><code>compute_witness()</code></strong> - Transforms the execution trace into an <code>AirInstance</code> - the algebraic representation used for proof generation. The <code>trace_buffer</code> contains field elements that capture every state transition.</p>
<p><strong><code>check_point()</code></strong> - Returns the current execution checkpoint, enabling ZisK to pause, resume, or analyze execution at specific points. Critical for distributed proving where different machines handle different execution segments.</p>
<p><strong><code>instance_type()</code></strong> - Identifies what kind of computation this instance handles, allowing the proving system to apply the correct constraint sets.</p>
<p><strong><code>build_inputs_collector()</code></strong> - Creates a <code>BusDevice</code> that can collect inputs for this specific instance, integrating with the bus system.</p>
<p><strong><code>reset()</code></strong> - Reinitializes the instance for fresh execution, essential for running multiple programs.</p>
<h2 id="state-machine-construction"><a class="header" href="#state-machine-construction">State Machine Construction</a></h2>
<p>State machines are built through a factory pattern that ensures proper initialization and configuration.</p>
<p><strong>File:</strong> <code>common/src/component/component_builder.rs</code></p>
<p>rust</p>
<pre><code class="language-rust">pub trait ComponentBuilder&lt;F: PrimeField64&gt;: Send + Sync {
    fn build_counter(&amp;self) -&gt; Option&lt;Box&lt;dyn BusDeviceMetrics&gt;&gt;;
    fn build_planner(&amp;self) -&gt; Box&lt;dyn Planner&gt;;
    fn configure_instances(&amp;self, pctx: &amp;ProofCtx&lt;F&gt;, plannings: &amp;[Plan]) {}
    fn build_instance(&amp;self, ictx: InstanceCtx) -&gt; Box&lt;dyn Instance&lt;F&gt;&gt;;
    fn build_inputs_generator(&amp;self) -&gt; Option&lt;Box&lt;dyn BusDevice&lt;PayloadType&gt;&gt;&gt; { None }
}</code></pre>
<p><strong>Construction process:</strong></p>
<ol>
<li><strong><code>build_counter()</code></strong> - Creates metrics collectors for performance monitoring</li>
<li><strong><code>build_planner()</code></strong> - Generates execution plans for resource allocation</li>
<li><strong><code>configure_instances()</code></strong> - Sets up instances based on execution context</li>
<li><strong><code>build_instance()</code></strong> - Creates the instance with its specific context</li>
<li><strong><code>build_inputs_generator()</code></strong> - Creates input generators for the instance</li>
</ol>
<h2 id="instance-context-and-coordination"><a class="header" href="#instance-context-and-coordination">Instance Context and Coordination</a></h2>
<p><strong>File:</strong> <code>common/src/instance_context.rs</code></p>
<p>rust</p>
<pre><code class="language-rust">pub struct InstanceCtx {
    /// Plan for the current instance
    pub plan: Plan,
    /// Global ID of the current instance
    pub global_id: usize,
}

impl InstanceCtx {
    pub fn new(global_id: usize, plan: Plan) -&gt; Self {
        Self { plan, global_id }
    }
}</code></pre>
<p>The <code>InstanceCtx</code> coordinates ZisK's distributed architecture:</p>
<p><strong><code>plan</code></strong> - Contains the execution strategy: what operations to handle, resource allocation, and coordination with other instances.</p>
<p><strong><code>global_id</code></strong> - Provides unique identification across the distributed system, enabling machine coordination and witness computation aggregation.</p>
<h2 id="the-state-machine-types"><a class="header" href="#the-state-machine-types">The State Machine Types</a></h2>
<h3 id="main-state-machine"><a class="header" href="#main-state-machine">Main State Machine</a></h3>
<p><strong>File:</strong> <code>state-machines/main/src/main_sm.rs</code></p>
<p>rust</p>
<pre><code class="language-rust">pub struct MainSM {}

pub struct MainInstance {
    pub ictx: InstanceCtx,
    pub is_last_segment: bool,
}</code></pre>
<p>The Main state machine coordinates overall execution without performing computations itself. It manages when and how other state machines operate. The <code>is_last_segment</code> flag triggers specialized cleanup and finalization logic for proof generation.</p>
<h3 id="arithmetic-state-machine"><a class="header" href="#arithmetic-state-machine">Arithmetic State Machine</a></h3>
<p><strong>File:</strong> <code>state-machines/arith/src/arith.rs</code></p>
<p>rust</p>
<pre><code class="language-rust">pub struct ArithSM {
    arith_full_sm: Arc&lt;ArithFullSM&gt;,
    arith_table_sm: Arc&lt;ArithTableSM&gt;,
    arith_range_table_sm: Arc&lt;ArithRangeTableSM&gt;,
}</code></pre>
<p>Handles mathematical operations through specialized sub-machines:</p>
<ul>
<li><strong><code>ArithFullSM</code></strong> - Complete arithmetic operations</li>
<li><strong><code>ArithTableSM</code></strong> - Lookup tables for efficient computation</li>
<li><strong><code>ArithRangeTableSM</code></strong> - Range checking operations</li>
</ul>
<p>This decomposition allows independent optimization and parallel processing of different arithmetic operation types.</p>
<h3 id="binary-state-machine"><a class="header" href="#binary-state-machine">Binary State Machine</a></h3>
<p><strong>File:</strong> <code>state-machines/binary/src/binary.rs</code></p>
<p>rust</p>
<pre><code class="language-rust">pub struct BinarySM&lt;F: PrimeField64&gt; {
    binary_basic_sm: Arc&lt;BinaryBasicSM&gt;,
    binary_basic_table_sm: Arc&lt;BinaryBasicTableSM&gt;,
    binary_extension_sm: Arc&lt;BinaryExtensionSM&lt;F&gt;&gt;,
    binary_extension_table_sm: Arc&lt;BinaryExtensionTableSM&gt;,
    binary_add_sm: Arc&lt;BinaryAddSM&lt;F&gt;&gt;,
}</code></pre>
<p>Manages bitwise and logical operations, which are expensive to prove in zkVMs. The multiple sub-machines handle:</p>
<ul>
<li><strong>Basic operations</strong> (AND, OR, XOR) with lookup tables</li>
<li><strong>Extended operations</strong> for complex binary logic</li>
<li><strong>Binary addition</strong> with optimized constraint generation</li>
</ul>
<h3 id="memory-state-machine"><a class="header" href="#memory-state-machine">Memory State Machine</a></h3>
<p><strong>File:</strong> <code>state-machines/mem/src/mem.rs</code></p>
<p>rust</p>
<pre><code class="language-rust">pub struct Mem&lt;F: PrimeField64&gt; {
    mem_sm: Arc&lt;MemSM&lt;F&gt;&gt;,
    mem_align_sm: Arc&lt;MemAlignSM&lt;F&gt;&gt;,
    mem_align_rom_sm: Arc&lt;MemAlignRomSM&gt;,
    input_data_sm: Arc&lt;InputDataSM&lt;F&gt;&gt;,
    rom_data_sm: Arc&lt;RomDataSM&lt;F&gt;&gt;,
}</code></pre>
<p>Handles all memory operations, proving that every access is legitimate. Specialized sub-machines include:</p>
<ul>
<li><strong><code>MemSM</code></strong> - Core memory operations and access validation</li>
<li><strong><code>MemAlignSM</code></strong> - Unaligned memory accesses (crucial for RISC-V compatibility)</li>
<li><strong><code>InputDataSM</code> / <code>RomDataSM</code></strong> - Specialized handling for input and read-only data</li>
</ul>
<h3 id="rom-state-machine"><a class="header" href="#rom-state-machine">ROM State Machine</a></h3>
<p><strong>File:</strong> <code>state-machines/rom/src/rom.rs</code></p>
<p>rust</p>
<pre><code class="language-rust">pub struct RomSM {
    zisk_rom: Arc&lt;ZiskRom&gt;,
    bios_inst_count: Arc&lt;Vec&lt;AtomicU32&gt;&gt;,
    prog_inst_count: Arc&lt;Vec&lt;AtomicU32&gt;&gt;,
    asm_runner_handler: Mutex&lt;Option&lt;JoinHandle&lt;AsmRunnerRH&gt;&gt;&gt;,
}</code></pre>
<p>Manages program storage and instruction fetching. The atomic counters track instruction execution statistics for optimization and debugging. Can integrate with external assembly runners for specialized execution scenarios.</p>
<h2 id="bus-system-integration"><a class="header" href="#bus-system-integration">Bus System Integration</a></h2>
<p>State machines communicate through the bus system by implementing the <code>BusDevice</code> trait:</p>
<p>rust</p>
<pre><code class="language-rust">impl BusDevice&lt;u64&gt; for $InstanceName {
    fn process_data(
        &amp;mut self,
        bus_id: &amp;BusId,
        data: &amp;[u64],
        _pending: &amp;mut VecDeque&lt;(BusId, Vec&lt;u64&gt;)&gt;,
    ) { /* ... */ }
    
    fn bus_id(&amp;self) -&gt; Vec&lt;BusId&gt; { vec![self.bus_id] }
    fn as_any(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn std::any::Any&gt; { self }
}</code></pre>
<p>This integration makes state machine instances full participants in the communication infrastructure, enabling them to send and receive data through the bus system.</p>
<h2 id="execution-lifecycle"><a class="header" href="#execution-lifecycle">Execution Lifecycle</a></h2>
<h3 id="1-initialization"><a class="header" href="#1-initialization">1. Initialization</a></h3>
<ul>
<li><code>ComponentBuilder</code> creates instances with appropriate <code>InstanceCtx</code></li>
<li>Each state machine registers its bus IDs</li>
<li>Planners generate execution strategies</li>
</ul>
<h3 id="2-execution"><a class="header" href="#2-execution">2. Execution</a></h3>
<ul>
<li>Main state machine coordinates overall execution</li>
<li>Specialized state machines handle domain-specific operations</li>
<li>All communication flows through the bus system</li>
<li>Continuous witness data collection</li>
</ul>
<h3 id="3-witness-generation"><a class="header" href="#3-witness-generation">3. Witness Generation</a></h3>
<ul>
<li>Each instance calls <code>compute_witness()</code> with its execution trace</li>
<li>Trace buffers transform into <code>AirInstance</code> objects</li>
<li>Mathematical constraints prove correctness</li>
</ul>
<h3 id="4-cleanup"><a class="header" href="#4-cleanup">4. Cleanup</a></h3>
<ul>
<li><code>reset()</code> methods prepare instances for next execution</li>
<li>Resources get deallocated properly</li>
<li>Metrics collection and reporting</li>
</ul>
<h2 id="architecture-benefits"><a class="header" href="#architecture-benefits">Architecture Benefits</a></h2>
<p><strong>Specialized Optimization</strong>: Each state machine optimizes independently for its specific operation type, reducing overall proving time.</p>
<p><strong>Parallel Processing</strong>: Independent operations can run simultaneously across different state machines.</p>
<p><strong>Modular Design</strong>: New computational domains can be added without affecting existing components.</p>
<p><strong>Distributed Execution</strong>: The instance system enables coordination across multiple machines while maintaining mathematical soundness.</p>
<p><strong>Incremental Proving</strong>: The checkpoint system enables incremental proof generation for long-running computations.</p>
<h2 id="system-architecture-diagram"><a class="header" href="#system-architecture-diagram">System Architecture Diagram</a></h2>
<pre class="mermaid">graph TD
    Main[Main State Machine] 
    
    Arith[Arithmetic State Machine]
    Binary[Binary State Machine] 
    Memory[Memory State Machine]
    ROM[ROM State Machine]
    
    Bus((Bus System))
    
    Builder[Component Builder]
    Context[Instance Context]
    
    Main --&gt; Arith
    Main --&gt; Binary
    Main --&gt; Memory
    Main --&gt; ROM
    
    Arith &lt;--&gt; Bus
    Binary &lt;--&gt; Bus
    Memory &lt;--&gt; Bus
    ROM &lt;--&gt; Bus
    Main &lt;--&gt; Bus
    
    Builder -.-&gt; Main
    Builder -.-&gt; Arith
    Builder -.-&gt; Binary
    Builder -.-&gt; Memory
    Builder -.-&gt; ROM
    
    Context --&gt; Builder
</pre>
<h2 id="why-this-architecture-works"><a class="header" href="#why-this-architecture-works">Why This Architecture Works</a></h2>
<p>ZisK's state machine architecture provides a purpose-built foundation for zero-knowledge proof generation. By decomposing computation into specialized domains, each state machine can generate constraints optimized for its operation type. The modular design enables parallel processing, distributed execution, and incremental optimizations that would be impossible in a monolithic system.</p>
<p>This architecture ensures that ZisK can efficiently handle the mathematical requirements of zero-knowledge proofs while maintaining the flexibility needed for real-world applications.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../getting_started/architecture/architecture.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../../getting_started/architecture/bus.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../getting_started/architecture/architecture.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../../getting_started/architecture/bus.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="../../elasticlunr.min.js"></script>
        <script src="../../mark.min.js"></script>
        <script src="../../searcher.js"></script>

        <script src="../../clipboard.min.js"></script>
        <script src="../../highlight.js"></script>
        <script src="../../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
