<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Bus - ZisK Documentation</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../../favicon.svg">
        <link rel="shortcut icon" href="../../favicon.png">
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        <link rel="stylesheet" href="../../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">ZisK Documentation</h1>

                    <div class="right-buttons">
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="the-bus-system"><a class="header" href="#the-bus-system">The Bus System</a></h1>
<p>ZisK's bus system connects all components and manages data flow between state machines. Unlike traditional computer buses that focus only on performance, ZisK's bus system captures every data transfer as part of the execution trace needed for zero-knowledge proof generation.</p>
<h2 id="bus-design-principles"><a class="header" href="#bus-design-principles">Bus Design Principles</a></h2>
<p>The bus serves dual purposes: it moves data between components and creates a comprehensive audit trail of all system interactions. Every data transfer gets captured and structured to feed directly into the mathematical constraints that power zero-knowledge proofs.</p>
<p>This design ensures that all communication contributes to proof generation while enabling efficient distributed operation across multiple machines.</p>
<h2 id="core-interface-busdevice-trait"><a class="header" href="#core-interface-busdevice-trait">Core Interface: BusDevice Trait</a></h2>
<p>Every component in ZisK implements the <code>BusDevice</code> trait to participate in the communication system.</p>
<p><strong>File:</strong> <code>common/src/bus/bus_device.rs</code></p>
<pre><code class="language-rust">pub trait BusDevice&lt;D&gt;: Any + Send + Sync {
    fn process_data(&amp;mut self, bus_id: &amp;BusId, data: &amp;[D], pending: &amp;mut VecDeque&lt;(BusId, Vec&lt;D&gt;)&gt;);
    fn bus_id(&amp;self) -&gt; Vec&lt;BusId&gt;;
    fn as_any(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn Any&gt;;
    fn on_close(&amp;mut self) {}
}
</code></pre>
<p><strong>Method breakdown:</strong></p>
<p><strong><code>process_data()</code></strong> - Handles incoming data for the device. When data arrives:</p>
<ul>
<li>Receives the source bus ID and data payload</li>
<li>Processes data according to the device's specific logic</li>
<li>Can queue additional operations in the <code>pending</code> queue for other devices</li>
<li>Creates a chain of data flow captured in the execution trace</li>
</ul>
<p><strong><code>bus_id()</code></strong> - Returns all bus IDs this device responds to. Some devices handle multiple logical addresses or have different interfaces for different operation types.</p>
<p><strong><code>as_any()</code></strong> - Enables runtime type casting, allowing the bus system to work with different device types while maintaining type safety.</p>
<p><strong><code>on_close()</code></strong> - Cleanup hook for device shutdown, ensuring proper resource management.</p>
<h2 id="device-identification-busid"><a class="header" href="#device-identification-busid">Device Identification: BusId</a></h2>
<p><strong>File:</strong> <code>common/src/bus/bus_id.rs</code></p>
<pre><code class="language-rust">#[derive(Debug, Clone, Copy, PartialEq)]
pub struct BusId(pub usize);
</code></pre>
<p>Each <code>BusId</code> uniquely identifies a device or interface on the bus. The <code>usize</code> provides a flat address space that efficiently routes data to the correct component.</p>
<p><strong>Zero-knowledge relevance:</strong> The bus ID becomes part of the execution trace. When the prover generates constraints, it must prove that data went to the correct destination. The simple, deterministic addressing scheme makes these proofs more efficient.</p>
<h2 id="metrics-and-monitoring"><a class="header" href="#metrics-and-monitoring">Metrics and Monitoring</a></h2>
<p><strong>File:</strong> <code>common/src/bus/bus_device_metrics.rs</code></p>
<pre><code class="language-rust">pub trait BusDeviceMetrics: BusDevice&lt;u64&gt; + Metrics + std::any::Any {}
</code></pre>
<p>This trait combines core bus functionality with metrics collection. Devices implementing this provide insights into:</p>
<ul>
<li>Data throughput and latency</li>
<li>Operation counts and patterns</li>
<li>Performance bottlenecks</li>
<li>Resource utilization</li>
</ul>
<p>These metrics are essential for understanding system performance across distributed environments.</p>
<h2 id="specialized-data-handlers"><a class="header" href="#specialized-data-handlers">Specialized Data Handlers</a></h2>
<p>The bus system provides specialized handlers for different data types rather than using a generic approach:</p>
<h3 id="operation-data-handler"><a class="header" href="#operation-data-handler">Operation Data Handler</a></h3>
<p><strong>File:</strong> <code>common/src/bus/data_bus_operation.rs</code></p>
<p>Handles operation-specific communication:</p>
<ul>
<li>Instruction dispatch from main state machine to specialized processors</li>
<li>Result collection from arithmetic and binary operations</li>
<li>Control flow coordination between execution units</li>
</ul>
<h3 id="rom-data-handler"><a class="header" href="#rom-data-handler">ROM Data Handler</a></h3>
<p><strong>File:</strong> <code>common/src/bus/data_bus_rom.rs</code></p>
<p>Manages read-only memory interactions:</p>
<ul>
<li>Program instruction fetching</li>
<li>Constant data access</li>
<li>Program integrity verification during execution</li>
</ul>
<h3 id="memory-data-handler"><a class="header" href="#memory-data-handler">Memory Data Handler</a></h3>
<p><strong>File:</strong> <code>common/src/bus/data_bus_mem.rs</code></p>
<p>Handles dynamic memory operations:</p>
<ul>
<li>RAM read/write operations</li>
<li>Memory alignment and access patterns</li>
<li>Memory tracing for proof generation</li>
</ul>
<h2 id="data-flow-process"><a class="header" href="#data-flow-process">Data Flow Process</a></h2>
<p>Here's how data moves through the system:</p>
<ol>
<li><strong>Initiation:</strong> A state machine needs to communicate with another component</li>
<li><strong>Queuing:</strong> The operation gets queued using the appropriate data handler</li>
<li><strong>Routing:</strong> The bus system examines the target <code>BusId</code> and routes data to the correct device</li>
<li><strong>Processing:</strong> The target device's <code>process_data()</code> method handles the operation</li>
<li><strong>Cascading:</strong> If the operation triggers additional work, new operations get added to the pending queue</li>
<li><strong>Tracing:</strong> Every step gets recorded for the execution trace</li>
</ol>
<h2 id="zero-knowledge-optimization"><a class="header" href="#zero-knowledge-optimization">Zero-Knowledge Optimization</a></h2>
<p>ZisK's bus system optimizes for <strong>verifiability</strong> rather than just speed:</p>
<p><strong>Deterministic Ordering:</strong> The queue-based approach ensures operations happen in predictable order, crucial for generating consistent proofs.</p>
<p><strong>Complete Traceability:</strong> Every data transfer creates execution trace entries. This comprehensive logging means the prover can demonstrate exactly what data moved where and when.</p>
<p><strong>Modular Verification:</strong> Different data handlers can implement domain-specific verification logic. The arithmetic unit can prove its computations are correct, while the memory unit can prove accesses were legitimate.</p>
<p><strong>Distributed Proof Generation:</strong> Clear device interfaces and identities enable different parts of the proof to be generated on different machines and then combined.</p>
<h2 id="performance-characteristics"><a class="header" href="#performance-characteristics">Performance Characteristics</a></h2>
<p><strong>Latency:</strong> The queue-based system introduces minimal overhead compared to direct function calls, but comprehensive tracing provides significant benefits for proof generation.</p>
<p><strong>Throughput:</strong> The generic design allows batching operations and parallel processing where the dependency graph permits.</p>
<p><strong>Scalability:</strong> New device types can be added without modifying existing components - they just need to implement the <code>BusDevice</code> trait and register appropriate bus IDs.</p>
<h2 id="state-machine-integration"><a class="header" href="#state-machine-integration">State Machine Integration</a></h2>
<p>The bus system enables the state machine architecture. Each state machine (Main, Arithmetic, Binary, Memory, ROM) implements the <code>BusDevice</code> trait and uses the bus for:</p>
<ul>
<li><strong>Coordination:</strong> The main state machine orchestrates other components via bus messages</li>
<li><strong>Data Exchange:</strong> Arithmetic results flow back to the main processor through the bus</li>
<li><strong>Resource Sharing:</strong> Multiple state machines access shared resources like memory through standardized interfaces</li>
</ul>
<h2 id="adding-new-components"><a class="header" href="#adding-new-components">Adding New Components</a></h2>
<p>Adding a new component to ZisK involves:</p>
<ol>
<li><strong>Implement <code>BusDevice&lt;T&gt;</code></strong> for your component with appropriate data type <code>T</code></li>
<li><strong>Choose unique <code>BusId</code>(s)</strong> for your component's interfaces</li>
<li><strong>Register with the bus system</strong> during initialization</li>
<li><strong>Handle incoming data</strong> in your <code>process_data()</code> implementation</li>
<li><strong>Optionally implement metrics</strong> via <code>BusDeviceMetrics</code> for monitoring</li>
</ol>
<p>Existing components don't need to know about new devices - they send data to bus IDs, and the system handles routing automatically.</p>
<h2 id="development-support"><a class="header" href="#development-support">Development Support</a></h2>
<p>The module system in <code>common/src/bus/mod.rs</code> provides utilities for:</p>
<ul>
<li><strong>Bus timing analysis</strong> - Understanding data flow patterns and bottlenecks</li>
<li><strong>Debug tracing</strong> - Following data through the system during development</li>
<li><strong>Component lifecycle management</strong> - Proper initialization and cleanup</li>
</ul>
<p>This makes ZisK development more manageable than traditional zkVM architectures where component interactions are often implicit and hard to debug.</p>
<h2 id="bus-system-architecture"><a class="header" href="#bus-system-architecture">Bus System Architecture</a></h2>
<pre class="mermaid">graph TD
    subgraph &quot;State Machines&quot;
        Main[Main State Machine&lt;br/&gt;BusId: 0x01]
        Arith[Arithmetic State Machine&lt;br/&gt;BusId: 0x02]
        Binary[Binary State Machine&lt;br/&gt;BusId: 0x03]
        Memory[Memory State Machine&lt;br/&gt;BusId: 0x04]
        ROM[ROM State Machine&lt;br/&gt;BusId: 0x05]
    end
    
    subgraph &quot;Bus &quot;
        Bus[Bus System&lt;br/&gt;Routing &amp; Queuing]
        Queue[Pending Operations&lt;br/&gt;VecDeque]
        Router[BusId Router]
    end
    
    subgraph &quot;Data Handlers&quot;
        OpHandler[Operation Handler&lt;br/&gt;data_bus_operation.rs]
        MemHandler[Memory Handler&lt;br/&gt;data_bus_mem.rs]
        ROMHandler[ROM Handler&lt;br/&gt;data_bus_rom.rs]
    end
    
    subgraph &quot;BusDevice Interface&quot;
        Interface[&quot;process_data()&lt;br/&gt;bus_id()&lt;br/&gt;as_any()&lt;br/&gt;on_close()&quot;]
    end
    
    Main &lt;--&gt; Bus
    Arith &lt;--&gt; Bus
    Binary &lt;--&gt; Bus
    Memory &lt;--&gt; Bus
    ROM &lt;--&gt; Bus
    
    Bus --&gt; Queue
    Bus --&gt; Router
    
    Bus --&gt; OpHandler
    Bus --&gt; MemHandler
    Bus --&gt; ROMHandler
    
    Main -.-&gt; Interface
    Arith -.-&gt; Interface
    Binary -.-&gt; Interface
    Memory -.-&gt; Interface
    ROM -.-&gt; Interface

</pre>
<h2 id="architecture-benefits"><a class="header" href="#architecture-benefits">Architecture Benefits</a></h2>
<p>ZisK's bus system treats communication as a first-class component that directly supports zero-knowledge proof generation requirements. This approach enables:</p>
<ul>
<li><strong>Modularity:</strong> Components can be developed and optimized independently</li>
<li><strong>Distributed operation:</strong> Seamless scaling across multiple machines</li>
<li><strong>Comprehensive traceability:</strong> Complete audit trail for proof generation</li>
<li><strong>Performance optimization:</strong> Targeted optimizations while maintaining mathematical rigor</li>
</ul>
<p>The bus system provides the foundation for ZisK's modular, scalable, and verifiable architecture.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../getting_started/architecture/state_machines.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../../getting_started/architecture/execution_pipeline.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../getting_started/architecture/state_machines.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../../getting_started/architecture/execution_pipeline.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="../../elasticlunr.min.js"></script>
        <script src="../../mark.min.js"></script>
        <script src="../../searcher.js"></script>

        <script src="../../clipboard.min.js"></script>
        <script src="../../highlight.js"></script>
        <script src="../../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
