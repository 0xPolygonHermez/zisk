import{f as n,j as e}from"./index-DBVKNYZ6.js";const c={description:"Precompile",title:"Precompiles"};function t(s){const i={a:"a",code:"code",div:"div",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",ul:"ul",...n(),...s.components};return e.jsxs(e.Fragment,{children:[e.jsx(i.header,{children:e.jsxs(i.h1,{id:"precompiles",children:["Precompiles",e.jsx(i.a,{"aria-hidden":"true",tabIndex:"-1",href:"#precompiles",children:e.jsx(i.div,{"data-autolink-icon":!0})})]})}),`
`,e.jsx(i.p,{children:"Precompiles are built-in system functions within ZisKâ€™s operating system that accelerate computationally expensive and frequently used operations such as the Keccak-f permutation and Secp256k1 addition and doubling."}),`
`,e.jsxs(i.p,{children:["These precompiles improve proving efficiency by offloading intensive computations from ZisK programs to dedicated, pre-integrated sub-processors. ZisK manages precompiles as system calls using the RISC-V ",e.jsx(i.code,{children:"ecall"})," instruction."]}),`
`,e.jsxs(i.h2,{id:"how-precompiles-work",children:["How Precompiles Work",e.jsx(i.a,{"aria-hidden":"true",tabIndex:"-1",href:"#how-precompiles-work",children:e.jsx(i.div,{"data-autolink-icon":!0})})]}),`
`,e.jsx(i.p,{children:"Precompiles are primarily used to patch third-party crates, replacing costly operations with system calls. This ensures that commonly used cryptographic primitives like Keccak hashing and elliptic curve operations can be efficiently executed within ZisK programs."}),`
`,e.jsx(i.p,{children:"Typically, precompiles are used to patch third-party crates that implement these operations and are then used as dependencies in the Zisk programs we write."}),`
`,e.jsxs(i.p,{children:["You can see ",e.jsx(i.a,{href:"https://github.com/0xPolygonHermez/zisk-patch-tiny-keccak/tree/zisk",children:"here"})," an example of the patched ",e.jsx(i.code,{children:"tiny-keccak"})," crate."]}),`
`,e.jsxs(i.h3,{id:"available-precompiles-in-zisk",children:["Available Precompiles in ZisK",e.jsx(i.a,{"aria-hidden":"true",tabIndex:"-1",href:"#available-precompiles-in-zisk",children:e.jsx(i.div,{"data-autolink-icon":!0})})]}),`
`,e.jsx(i.p,{children:"Below is a summary of the precompiles currently available in ZisK:"}),`
`,e.jsxs(i.ul,{children:[`
`,e.jsxs(i.li,{children:[e.jsx(i.a,{href:"https://github.com/0xPolygonHermez/zisk/tree/main/ziskos/entrypoint/src/syscalls/arith256_mod.rs",children:"syscall_arith256_mod"}),": Modular multiplication followed by addition over 256-bit non-negative integers."]}),`
`,e.jsxs(i.li,{children:[e.jsx(i.a,{href:"https://github.com/0xPolygonHermez/zisk/tree/main/ziskos/entrypoint/src/syscalls/arith256.rs",children:"syscall_arith256"}),": Multiplication followed by addition over 256-bit non-negative integers."]}),`
`,e.jsxs(i.li,{children:[e.jsx(i.a,{href:"https://github.com/0xPolygonHermez/zisk/tree/main/ziskos/entrypoint/src/syscalls/keccakf.rs",children:"syscall_keccak_f"}),": Keccak-f[1600] permutation function from the ",e.jsx(i.a,{href:"https://keccak.team/files/Keccak-reference-3.0.pdf",children:"Keccak"})," cryptographic sponge construction."]}),`
`,e.jsxs(i.li,{children:[e.jsx(i.a,{href:"https://github.com/0xPolygonHermez/zisk/tree/main/ziskos/entrypoint/src/syscalls/sha256f.rs",children:"syscall_sha256_f"}),": Extend and compress function of the ",e.jsx(i.a,{href:"https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf",children:"SHA-256"})," cryptographic hash algorithm."]}),`
`,e.jsxs(i.li,{children:[e.jsx(i.a,{href:"https://github.com/0xPolygonHermez/zisk/tree/main/ziskos/entrypoint/src/syscalls/secp256k1_add.rs",children:"secp256k1_add"}),": Elliptic curve point addition over the ",e.jsx(i.a,{href:"https://en.bitcoin.it/wiki/Secp256k1",children:"Secp256k1"})," curve."]}),`
`,e.jsxs(i.li,{children:[e.jsx(i.a,{href:"https://github.com/0xPolygonHermez/zisk/tree/main/ziskos/entrypoint/src/syscalls/secp256k1_dbl.rs",children:"secp256k1_dbl"}),": Elliptic curve point doubling over the ",e.jsx(i.a,{href:"https://en.bitcoin.it/wiki/Secp256k1",children:"Secp256k1"})," curve."]}),`
`]})]})}function a(s={}){const{wrapper:i}={...n(),...s.components};return i?e.jsx(i,{...s,children:e.jsx(t,{...s})}):t(s)}export{a as default,c as frontmatter};
