use std::sync::{
    atomic::{AtomicU32, Ordering},
    Arc,
};

use crate::{MemAlignRomSM, MemAlignSM, MemOp, MemSM};
use p3_field::PrimeField;
use pil_std_lib::Std;
use proofman_util::{timer_start_debug, timer_stop_and_log_debug};
use zisk_core::{ZiskRequiredMemory, RAM_ADDR};

use proofman::{WitnessComponent, WitnessManager};

pub struct MemProxy<F: PrimeField> {
    // Count of registered predecessors
    registered_predecessors: AtomicU32,

    // Secondary State machines
    mem_sm: Arc<MemSM<F>>,
    mem_align_sm: Arc<MemAlignSM<F>>,
}

impl<F: PrimeField> MemProxy<F> {
    pub fn new(wcm: Arc<WitnessManager<F>>, std: Arc<Std<F>>) -> Arc<Self> {
        let mem_sm = MemSM::new(wcm.clone());
        let mem_align_rom_sm = MemAlignRomSM::new(wcm.clone());
        let mem_align_sm = MemAlignSM::new(wcm.clone(), std, mem_align_rom_sm);

        let mem_proxy = Self {
            registered_predecessors: AtomicU32::new(0),
            mem_sm,
            mem_align_sm,
        };
        let mem_proxy = Arc::new(mem_proxy);

        wcm.register_component(mem_proxy.clone(), None, None);

        // For all the secondary state machines, register the main state machine as a predecessor
        mem_proxy.mem_sm.register_predecessor();
        mem_proxy.mem_align_sm.register_predecessor();

        mem_proxy
    }

    pub fn register_predecessor(&self) {
        self.registered_predecessors.fetch_add(1, Ordering::SeqCst);
    }

    pub fn unregister_predecessor(&self) {
        if self.registered_predecessors.fetch_sub(1, Ordering::SeqCst) == 1 {
            self.mem_sm.unregister_predecessor();
            self.mem_align_sm.unregister_predecessor();
        }
    }

    pub fn prove(
        &self,
        operations: &mut [Vec<ZiskRequiredMemory>; 2],
    ) -> Result<(), Box<dyn std::error::Error + Send>> {
        let mut aligned = std::mem::take(&mut operations[0]);
        let unaligned = std::mem::take(&mut operations[1]);
        let mut new_aligned = Vec::new();

        // Step 1. Sort the aligned memory accesses
        timer_start_debug!(MEM_SORT);
        aligned.sort_by_key(|mem| mem.address);
        timer_stop_and_log_debug!(MEM_SORT);

        // Step 2. For each unaligned memory access
        unaligned.iter().for_each(|unaligned_access| {
            // Step 2.1 Ask to the Mem Align SM for the aligned memory accesses generated by the non-aligned one          
            let mem_op = MemAlignSM::<F>::get_mem_op(unaligned_access);

            // Step 2.2 Ask to the Mem SM for the aligned memory accesses
            // TODO! Remove mem_op.clone()
            let aligned_accesses = self.get_aligned_accesses(
                &unaligned_access,
                mem_op.clone(),
                &aligned,
                &new_aligned,
            );

            // Step 2.3 Carried with the aligned memory accesses, prove the non-aligned ones
            self.mem_align_sm.prove(unaligned_access, &aligned_accesses);

            // Step 2.4 Store the new aligned memory access(es)
            new_aligned.extend(aligned_accesses);
            new_aligned.sort_by_key(|mem| mem.address);
        });

        // Step 3. Concatenate the new aligned memory accesses with the original aligned memory
        // accesses
        aligned.extend(new_aligned);

        timer_start_debug!(MEM_SORT_2);
        aligned.sort_by_key(|mem| (mem.address, mem.step));
        timer_stop_and_log_debug!(MEM_SORT_2);

        let mut idx = 0;
        while aligned[idx].address < RAM_ADDR && idx < aligned.len() {
            idx += 1;
        }

        let (_input_aligned, aligned) = aligned.split_at_mut(idx);

        // Step 4. Prove the aligned memory accesses using mem state machine
        self.mem_sm.prove(aligned);

        Ok(())
    }

    #[inline(always)]
    fn get_aligned_accesses(
        &self,
        unaligned_access: &ZiskRequiredMemory,
        mem_op: MemOp,
        aligned_accesses: &[ZiskRequiredMemory],
        new_aligned_accesses: &[ZiskRequiredMemory],
    ) -> Vec<ZiskRequiredMemory> {
        // Align down to a 8 byte addres
        let addr = unaligned_access.address & !7;
        match mem_op {
            MemOp::OneRead => {
                // Look for last write to the same address
                let last_write_addr = Self::get_last_write(
                    addr,
                    unaligned_access.step,
                    aligned_accesses,
                    Some(new_aligned_accesses),
                );
                let mut last_write_addr = last_write_addr.unwrap_or(ZiskRequiredMemory {
                    step: unaligned_access.step,
                    is_write: false,
                    address: addr,
                    width: 8,
                    value: 0,
                });

                last_write_addr.step = unaligned_access.step;

                vec![last_write_addr]
            }
            MemOp::OneWrite => {
                // Look for last write to the same address
                let last_write_addr = Self::get_last_write(
                    addr,
                    unaligned_access.step,
                    aligned_accesses,
                    Some(new_aligned_accesses),
                );

                // Modify the value of the write to the same address
                let last_write_addr = last_write_addr.unwrap_or(ZiskRequiredMemory {
                    step: unaligned_access.step,
                    is_write: true,
                    address: addr,
                    width: 8,
                    value: 0,
                });

                let mut last_write_addr_r = last_write_addr.clone();
                last_write_addr_r.step = unaligned_access.step;
                last_write_addr_r.is_write = false;

                let mut last_write_addr_w = last_write_addr;
                last_write_addr_w.step = unaligned_access.step;
                Self::write_value(&unaligned_access, &mut last_write_addr_w);

                vec![last_write_addr_r, last_write_addr_w]
            }
            MemOp::TwoReads => {
                // Look for last write to the same address and same address + 8
                let last_write_addr = Self::get_last_write(
                    addr,
                    unaligned_access.step,
                    aligned_accesses,
                    Some(new_aligned_accesses),
                );
                let last_write_addr_p = Self::get_last_write(
                    addr + 8,
                    unaligned_access.step,
                    aligned_accesses,
                    Some(new_aligned_accesses),
                );

                let mut last_write_addr = last_write_addr.unwrap_or(ZiskRequiredMemory {
                    step: unaligned_access.step,
                    is_write: false,
                    address: addr,
                    width: 8,
                    value: 0,
                });

                let mut last_write_addr_p = last_write_addr_p.unwrap_or(ZiskRequiredMemory {
                    step: unaligned_access.step,
                    is_write: false,
                    address: addr + 8,
                    width: 8,
                    value: 0,
                });

                last_write_addr.step = unaligned_access.step;
                last_write_addr_p.step = unaligned_access.step;

                vec![last_write_addr, last_write_addr_p]
            }
            MemOp::TwoWrites => {
                // Look for last write to the same address and same address + 8
                let last_write_addr = Self::get_last_write(
                    addr,
                    unaligned_access.step,
                    aligned_accesses,
                    Some(new_aligned_accesses),
                );
                let last_write_addr_p = Self::get_last_write(
                    addr + 8,
                    unaligned_access.step,
                    aligned_accesses,
                    Some(new_aligned_accesses),
                );

                // Modify the value of the write to the same address
                let last_write_addr = last_write_addr.unwrap_or(ZiskRequiredMemory {
                    step: unaligned_access.step,
                    is_write: true,
                    address: addr,
                    width: 8,
                    value: 0,
                });

                let mut last_write_addr_r = last_write_addr.clone();
                last_write_addr_r.step = unaligned_access.step;
                last_write_addr_r.is_write = false;

                let mut last_write_addr_w = last_write_addr;
                last_write_addr_w.step = unaligned_access.step;
                Self::write_value(&unaligned_access, &mut last_write_addr_w);

                let last_write_addr_p = last_write_addr_p.unwrap_or(ZiskRequiredMemory {
                    step: unaligned_access.step,
                    is_write: true,
                    address: addr + 8,
                    width: 8,
                    value: 0,
                });

                let mut last_write_addr_p_r = last_write_addr_p.clone();
                last_write_addr_p_r.step = unaligned_access.step;
                last_write_addr_p_r.is_write = false;

                let mut last_write_addr_p_w = last_write_addr_p;
                last_write_addr_p_w.step = unaligned_access.step;
                Self::write_value(&unaligned_access, &mut last_write_addr_p_w);

                Self::write_values(
                    &unaligned_access,
                    &mut last_write_addr_w,
                    &mut last_write_addr_p_w,
                );
                vec![last_write_addr_r, last_write_addr_w, last_write_addr_p_r, last_write_addr_p_w]
            }
        }
    }

    #[inline(always)]
    fn get_last_write(
        addr: u64,
        step: u64,
        aligned_accesses: &[ZiskRequiredMemory],
        new_aligned_accesses: Option<&[ZiskRequiredMemory]>,
    ) -> Option<ZiskRequiredMemory> {
        // Step 1: Find the start of the range for `addr`
        let start_index =
            match aligned_accesses.binary_search_by_key(&addr, |access| access.address) {
                Ok(mut index) => {
                    // Backtrack to find the first occurrence of `addr`
                    while index > 0 && aligned_accesses[index - 1].address == addr {
                        index -= 1;
                    }
                    index
                }
                Err(index) => index, // If no match, use the insertion point as before
            };

        // Step 2: Iterate from start_index forward, storing the last valid write
        let mut last_write = None;
        for access in &aligned_accesses[start_index..] {
            if access.address != addr {
                break; // Stop if we move past the given address
            }
            if access.step >= step {
                break; // Stop if step is not less than the given step
            }
            if access.is_write {
                last_write = Some(access.clone()); // Update last write if conditions are met
            }
        }

        // Step 3: If `new_aligned_accesses` exists, check for a more recent write
        if let None = new_aligned_accesses {
            return last_write;
        }

        let new_aligned_accesses = new_aligned_accesses.unwrap();
        let last_new_write = Self::get_last_write(addr, step, new_aligned_accesses, None);

        if let None = last_write {
            return last_new_write;
        }

        if let Some(last_new_write) = last_new_write {
            if last_new_write.step > last_write.as_ref().unwrap().step {
                return Some(last_new_write);
            }
        }

        last_write
    }

    #[inline(always)]
    fn write_value(unaligned: &ZiskRequiredMemory, aligned: &mut ZiskRequiredMemory) {
        let offset = unaligned.address & 7;
        let width_in_bits = unaligned.width * 8;

        let mask = !(((1u64 << width_in_bits) - 1) << (offset * 8));

        aligned.value = (aligned.value & mask)
            | ((unaligned.value & ((1u64 << width_in_bits) - 1)) << (offset * 8));
    }
    #[inline(always)]
    fn write_values(
        unaligned: &ZiskRequiredMemory,
        aligned: &mut ZiskRequiredMemory,
        aligned_next: &mut ZiskRequiredMemory,
    ) {
        let offset = unaligned.address & 7;
        let bytes_to_write = 8 - offset;
        let right_bits = (unaligned.width - bytes_to_write) * 8;

        // Left write
        let left_value = unaligned.value << right_bits;
        let left_memory =
            ZiskRequiredMemory { width: bytes_to_write, value: left_value, ..*unaligned };
        Self::write_value(&left_memory, aligned);

        // Right write
        let right_value = unaligned.value >> (bytes_to_write * 8);

        let right_memory = ZiskRequiredMemory {
            address: 0,
            width: unaligned.width - bytes_to_write,
            value: right_value,
            ..*unaligned
        };
        Self::write_value(&right_memory, aligned_next);
    }
}

impl<F: PrimeField> WitnessComponent<F> for MemProxy<F> {}
