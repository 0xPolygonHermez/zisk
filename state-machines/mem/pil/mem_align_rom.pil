
const int MEM_ALIGN_ROM_ID = 133;
const int MEM_ALIGN_ROM_SIZE = P2_8;

//        PROGRAM SIZE
// RV        0     2    
// RWV       1     3   
// RVR       2     3  
// RWVWR     3     5      
//
// Note1: The offset and width are sufficient to group programs with the same number of operations.
// Note2: The first instruction is always a read.

airtemplate MemAlignRom(const int N = MEM_ALIGN_ROM_SIZE, const int disable_fixed = 0) {
    if (N < MEM_ALIGN_ROM_SIZE) {
        error(`N must be at least ${MEM_ALIGN_ROM_SIZE}, but N=${N} was provided`);
    }

    col witness multiplicity;

    if (disable_fixed) {
        col fixed _K = [0...];
        multiplicity * _K === 0;

        println("*** DISABLE_FIXED ***");
        return;
    }

    // Not all combinations of offset and width are valid for each program.
    // Moreover, each combination should be repeated the number of times of the program size.
    // Notation (x*y): x refers to the number of combinations and y refers to the program size.
                                                                                  //            size
    col fixed OFFSET   = [[0:(4*2), 1:(3*2)..4:(3*2), 5:(2*2), 6:(2*2), 7:2],     // RV     8+6*4+4+4+2  = 42 | 42
                          [0:(4*3), 1:(3*3)..4:(3*3), 5:(2*3), 6:(2*3), 7:3],     // RWV    12+9*3+6+6+3 = 54 | 96
                          [1:3..4:3, 5:(2*3), 6:(2*3), 7:(3*3)],                  // RVR    3*4+6+6+9    = 33 | 129
                          [1:5..4:5, 5:(2*5), 6:(2*5), 7:(3*5)]]...;              // RWVWR  5*4+10+10+15 = 55 | 184 => N = 2^8

    col fixed WIDTH    = [[[1:2,2:2,4:2,8:2], [1:2,2:2,4:2]:4, [1:2,2:2]:2, 1:2], // RV
                          [[1:3,2:3,4:3,8:3], [1:3,2:3,4:3]:4, [1:3,2:3]:2, 1:3], // RWV
                          [8:(4*3), [4:3,8:3]:2, [2:3,4:3,8:3]],                  // RVR
                          [8:(4*5), [4:5,8:5]:2, [2:5,4:5,8:5]]]...;              // RWVWR

    const int psize1 = 42;
    const int psize2 = 54;
    const int psize3 = 33;
    const int psize4 = 55;

    col fixed IS_WRITE = [0:psize1, [0,1,0]:(psize2/3), 0:psize3, [0,1,0,1,0]:(psize4/5)]...;

    // line pc pc'-pc
    //   0  0    1    // (RV)
    //   1  1   -1
    //   2  0    3    // (RV)
    //   3  3   -3
    //   4  0    4    // (RV)
    //   ...
    //  42  0   43    // (RWV)
    //  43 43    1
    //  44 44  -44
    //  45  0   46    // (RWV)
    //   ...
    // 184  0    0    // for padding

    col fixed PC;
    col fixed DELTA_ADDR;
    col fixed RESET;
    col fixed SEL[8];
    col fixed SEL_UP_TO_DOWN;
    col fixed SEL_DOWN_TO_UP;
    for (int i = 0; i < N; i++) {
        const int [offset, width] = [OFFSET[i], WIDTH[i]];
        int pc = 0;
        int delta_addr = 0;
        int reset = 0;
        int sel[8];
        for (int j = 0; j < 8; j++) {
            sel[j] = 0;
        }
        int sel_up_to_down = 0;
        int sel_down_to_up = 0;

        if (line < psize1) // RV
        {
            if (line % 2 == 0) { // R
                // pc = 0;
                delta_addr = line+1;
                reset = 1;
                sel = get_selectors(0, offset, width);
                sel_up_to_down = 1;
                // sel_down_to_up = 0;
            } else {        // V
                pc = line;
                delta_addr = -line;
                // reset = 0;
                // sel = [0:8]
                // sel_up_to_down = 0;
                // sel_down_to_up = 0;
            }
        } 
        else if (line < psize1+psize2)  // RWV
        {
            if (line % 3 == 0) {        // R
                // pc = 0;
                delta_addr = line+1;
                reset = 1;
                sel = get_selectors(1, offset, width);
                sel_up_to_down = 1;
                // sel_down_to_up = 0;
            } else if (line % 3 == 1) { // W
                pc = line;
                delta_addr = 1;
                // reset = 0;
                sel = get_selectors(1, offset, width, 1);
                sel_up_to_down = 1;
                // sel_down_to_up = 0;
            } else {                    // V
                pc = line;
                delta_addr = -line;
                // reset = 0;
                // sel = [0:8]
                // sel_up_to_down = 0;
                // sel_down_to_up = 0;
            }
        } 
        else if (line < psize1+psize2+psize3) // TODO
        {
            if (line % 3 == 0) {        // R
                // pc = 0;
                delta_addr = line+1;
                reset = 1;
                sel = get_selectors(2, offset, width);
                sel_up_to_down = 1;
                // sel_down_to_up = 0;
            } else if (line % 3 == 1) { // V
                pc = line;
                delta_addr = 1;
                // reset = 0;
                // sel = [0:8]
                // sel_up_to_down = 1;
                // sel_down_to_up = 0;
            } else {                    // R
                pc = line;
                delta_addr = -line;
                // reset = 0;
                sel = get_selectors(2, offset, width);
                // sel_up_to_down = 0;
                sel_down_to_up = 1;
            }
        } 
        else if (line < psize1+psize2+psize3+psize4) 
        {
            const int next = line+1;
            if (next % 5 == 0) {        // R
                // pc = 0;
                delta_addr = next;
                reset = 1;
                sel = get_selectors(3, offset, width, 0, 1);
                sel_up_to_down = 1;
                // sel_down_to_up = 0;
            } else if (next % 5 == 1) { // W
                pc = line;
                delta_addr = 1;
                // reset = 0;
                sel = get_selectors(3, offset, width, 1, 1);
                sel_up_to_down = 1;
                // sel_down_to_up = 0;
            } else if (next % 5 == 2) { // V
                pc = line;
                delta_addr = 1;
                // reset = 0;
                // sel = [0:8]
                // sel_up_to_down = 0;
                // sel_down_to_up = 0;
            } else if (next % 5 == 3) { // W
                pc = line;
                delta_addr = -line;
                // reset = 0;
                sel = get_selectors(3, offset, width, 1, 0);
                // sel_up_to_down = 0;
                sel_down_to_up = 1;
            } else {                    // R
                pc = line;
                delta_addr = 1;
                // reset = 0;
                sel = get_selectors(3, offset, width, 0, 0);
                // sel_up_to_down = 0;
                sel_down_to_up = 1;
            }
        }

        PC[i] = pc;
        DELTA_ADDR[i] = delta_addr;
        RESET[i] = reset;
        SEL[i] = sel;
        SEL_UP_TO_DOWN[i] = sel_up_to_down;
        SEL_DOWN_TO_UP[i] = sel_down_to_up;
    }

    lookup_proves(MEM_ALIGN_ROM_ID, [PC, DELTA_ADDR, OFFSET, WIDTH, IS_WRITE, RESET, ...SEL, SEL_UP_TO_DOWN, SEL_DOWN_TO_UP], multiplicity);

    function get_selectors(const int program, const int offset, const int width, const int is_write = 0, const int is_first = 0): int[] {
        int _sel[8];
        for (int j = 0; j < 8; j++) {
            _sel[j] = 0;
        }
        
        switch (program) {
            case 0: // RV
                for (int j = 0; j < offset; j++) {
                    _sel[j] = 1;
                }
            case 1: // RWV
                if (!is_write) {
                    for (int j = 0; j < offset; j++) {
                        _sel[j] = 1;
                    }
                } else {
                    for (int j = offset; j < offset + width; j++) {
                        _sel[j] = 1;
                    }
                }

            case 2: // RVR
                for (int j = 0; j < offset; j++) {
                    _sel[j] = 1;
                }

            case 3: // RWVWR
                if (is_first) {
                    if (!is_write) {
                        for (int j = 0; j < offset; j++) {
                            _sel[j] = 1;
                        }
                    } else {
                        for (int j = offset; j < 8; j++) {
                            _sel[j] = 1;
                        }
                    }
                } else {
                    const int rem = (offset + width) % 8;
                    if (is_write) {
                        for (int j = 0; j < rem; j++) {
                            _sel[j] = 1;
                        }
                    } else {
                        for (int j = rem; j < 8; j++) {
                            _sel[j] = 1;
                        }
                    }
                }

            default:
                error(`Invalid program ${program}`);

            return _sel;
        }
    }
}