require "std_permutation.pil"
require "std_range_check.pil"
require "mem.pil"

airtemplate MemAlign(int N = 2**10, const int MEM_BYTES = 8) {
    // Problem to solve:
    // =================
    // We are given an op (rd,wr), an addr, a step and a bytes-width (8,4,2,1) and we should prove that the memory access is correct.
    // Note: Either the original addr is not a multiple of 8 or width < 8 to ensure it is a non-aligned access that should be
    //       handled by this component.

    /*
    We will model it as a very specified processor with 8 registers and a very limited instruction set.

    This processor is limited to 4 possible subprograms:

    1] Read operation that spans one memory word w = [w_0, w_1]:
                  w_0               w_1
           +---+===+===+===+ +===+---+---+---+
           | 0 | 1 | 2 | 3 | | 4 | 5 | 6 | 7 |
           +---+===+===+===+ +===+---+---+---+
               |<------ v ------>|
    
    [R] In the first clock cycle, we perform an aligned read to w
    [V] In the second clock cycle, we return the demanded value v from w

    2] Write operation that spans one memory word w = [w_0, w_1]:
                  w_0               w_1
           +---+---+---+---+ +---+===+===+---+
           | 0 | 1 | 2 | 3 | | 4 | 5 | 6 | 7 |
           +---+---+---+---+ +---+===+===+---+
                                 |<- v ->|
    
    [R] In the first clock cycle, we perform an aligned read to w
    [W] In the second clock cycle, we compute an aligned write of v to w
    [V] In the third clock cycle, we restore the demanded value from w

    3] Read operation that spans two memory words w1 = [w1_0, w1_1] and w2 = [w2_0, w2_1]:
                 w1_0              w1_1                w2_0              w2_1       
           +---+---+---+---+ +---+===+===+===+   +===+===+===+===+ +===+---+---+---+
           | 0 | 1 | 2 | 3 | | 4 | 5 | 6 | 7 |   | 0 | 1 | 2 | 3 | | 4 | 5 | 6 | 7 |
           +---+---+---+---+ +---+===+===+===+   +===+===+===+===+ +===+---+---+---+
                                 |<---------------- v ---------------->|
    
    [R] In the first clock cycle, we perform an aligned read to w1
    [V] In the second clock cycle, we return the demanded value v from w1 and w2
    [R] In the third clock cycle, we perform an aligned read to w2

    4] Write operation that spans two memory words w1 = [w1_0, w1_1] and w2 = [w2_0, w2_1]:
                 w1_0              w1_1                w2_0              w2_1       
           +---+===+===+===+ +===+===+===+===+   +===+---+---+---+ +---+---+---+---+
           | 0 | 1 | 2 | 3 | | 4 | 5 | 6 | 7 |   | 0 | 1 | 2 | 3 | | 4 | 5 | 6 | 7 |
           +---+===+===+===+ +===+===+===+===+   +===+---+---+---+ +---+---+---+---+
               |<---------------- v ---------------->|
    
    [R] In the first clock cycle, we perform an aligned read to w1
    [W] In the second clock cycle, we compute an aligned write of v to w1
    [V] In the third clock cycle, we restore the demanded value from w1 and w2
    [R] In the fourth clock cycle, we perform an aligned read to w2
    [W] In the fiveth clock cycle, we compute an aligned write of v to w2

    Example:
    ==========================================================
                    (offset = 6, width = 4)
           +----+----+----+----+----+----+----+----+
           | R7 | R6 | R5 | R4 | R3 | R2 | R1 | R0 | [R1] (assume, up_to_down) sel = [1,1,1,1,1,1,0,0]
           +----+----+----+----+----+----+----+----+
                           ⇓
           +----+----+----+----+----+----+====+====+
           | W7 | W6 | W5 | W4 | W3 | W2 | W1 | W0 | [W1] (assume, up_to_down) sel = [0,0,0,0,0,0,1,1]
           +----+----+----+----+----+----+====+====+
                           ⇓
           +====+====+----+----+----+----+====+====+
           | V1 | V0 | V7 | V6 | V5 | V4 | V3 | V2 | [V] (prove) (shift (offset + width) % 8)
           +====+====+----+----+----+----+====+====+
                           ⇓
           +====+====+----+----+----+----+----+----+
           | W7 | W6 | W5 | W4 | W3 | W2 | W1 | W0 | [W2] (assume, down_to_up) sel = [1,1,0,0,0,0,0,0]
           +====+====+----+----+----+----+----+----+
                           ⇓
           +----+----+----+----+----+----+----+----+
           | R7 | R6 | R5 | R4 | R3 | R2 | R1 | R0 | [R2] (assume, down_to_up) sel = [0,0,1,1,1,1,1,1]
           +----+----+----+----+----+----+----+----+
    */

// n-byte address, real address = addr * MEM_BYTES

    col witness step;

    col witness pc;
    col witness addr;           // n-byte address, real address = addr * MEM_BYTES
    col witness offset;
    col witness width;
    col witness reset;
    col witness wr;             // 1 if the operation is a write, 0 otherwise
    col witness sel_up_to_down; // 1 if the next value is the current value (e.g. R -> W)
    col witness sel_down_to_up; // 1 if the next value is the previous value (e.g. W -> R)
    col witness reg[MEM_BYTES]; // Register values, 1 byte each
    col witness sel[MEM_BYTES];

    for (int i = 0; i < MEM_BYTES; i++) {
        range_check(reg[i], 0, 2**8-1);

        (reg[i]' - reg[i]) * sel[i] * sel_up_to_down === 0;
        ('reg[i] - reg[i]) * sel[i] * sel_down_to_up === 0;
    }

    // Assume aligned memory accesses against the Memory component
    const expr sel_assume = sel_up_to_down + sel_down_to_up;

    expr assume_val[2];
    assume_val[0] = 0;
    assume_val[1] = 0;
    for (int i = 0; i < 4; i++) {
        assume_val[0] += reg[i] * 2**i;
        assume_val[1] += reg[i + 4] * 2**i;
    }
    permutation_assumes(MEMORY_ID, cols: [wr * (MEMORY_STORE_OP - MEMORY_LOAD_OP) + MEMORY_LOAD_OP, addr * MEM_BYTES, step, MEM_BYTES, ...assume_val], sel: sel_assume);

    // Prove unaligned memory accesses against the Main component
    const expr sel_prove = 1 - sel_assume;

    expr prove_val[2];
    prove_val[0] = 0;
    prove_val[1] = 0;
    for (int i = 0; i < 4; i++) {
        expr _prove_val0 = 0;
        expr _prove_val1 = 0;
        for (int j = i; j < i+4; j++) {
            _prove_val0 += reg[j] * 2**(j-i);
            _prove_val1 += reg[(j+4) % 8] * 2**(j-i);
        }
        prove_val[0] = sel[i] * _prove_val0;
        prove_val[1] = sel[i] * _prove_val1;
    }
    permutation_proves(MEMORY_ID, cols: [wr * (MEMORY_STORE_OP - MEMORY_LOAD_OP) + MEMORY_LOAD_OP, addr * MEM_BYTES, step, width, ...prove_val], sel: sel_prove);
}