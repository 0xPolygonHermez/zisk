require "std_permutation.pil"

airtemplate MemAlign(int N = 2**10) {
    // We are given an op (rd,wr), an addr, a step and a bytes-width (8,4,2,1) and we should prove that the memory access is correct.
    // Note: Either the original addr is not a multiple of 8 or width < 8 to ensure it is a non-aligned access that should be
    //       handled by this component.

    col witness pc;
    col witness addr;
    col witness offset;
    col witness step;
    col witness reset;
    col witness sel_prove;
    col witness sel_up_to_down;
    col witness sel_down_to_up;
    col witness reg[8];         // Register values, 1 byte each
    col witness sel[8];

    // 4 possible subprograms:

    // 1] Read operation that spans one memory word w = [w_0, w_1]:
    //               w_0               w_1
    //        +---+===+===+===+ +===+---+---+---+
    //        | 0 | 1 | 2 | 3 | | 4 | 5 | 6 | 7 |
    //        +---+===+===+===+ +===+---+---+---+
    //            |<------ v ------>|
    //
    // [R] In the first clock cycle, we perform an aligned read to w
    // [V] In the second clock cycle, we return the demanded value v from w

    // 2] Write operation that spans one memory word w = [w_0, w_1]:
    //               w_0               w_1
    //        +---+---+---+---+ +---+===+===+---+
    //        | 0 | 1 | 2 | 3 | | 4 | 5 | 6 | 7 |
    //        +---+---+---+---+ +---+===+===+---+
    //                              |<- v ->|
    //
    // [R] In the first clock cycle, we perform an aligned read to w
    // [W] In the second clock cycle, we compute an aligned write of v to w
    // [V] In the third clock cycle, we restore the demanded value from w

    // 3] Read operation that spans two memory words w1 = [w1_0, w1_1] and w2 = [w2_0, w2_1]:
    //              w1_0              w1_1                w2_0              w2_1       
    //        +---+---+---+---+ +---+===+===+===+   +===+===+===+===+ +===+---+---+---+
    //        | 0 | 1 | 2 | 3 | | 4 | 5 | 6 | 7 |   | 0 | 1 | 2 | 3 | | 4 | 5 | 6 | 7 |
    //        +---+---+---+---+ +---+===+===+===+   +===+===+===+===+ +===+---+---+---+
    //                              |<---------------- v ---------------->|
    //
    // [R] In the first clock cycle, we perform an aligned read to w1
    // [V] In the second clock cycle, we return the demanded value v from w1 and w2
    // [R] In the third clock cycle, we perform an aligned read to w2

    // 4] Write operation that spans two memory words w1 = [w1_0, w1_1] and w2 = [w2_0, w2_1]:
    //              w1_0              w1_1                w2_0              w2_1       
    //        +---+===+===+===+ +===+===+===+===+   +===+---+---+---+ +---+---+---+---+
    //        | 0 | 1 | 2 | 3 | | 4 | 5 | 6 | 7 |   | 0 | 1 | 2 | 3 | | 4 | 5 | 6 | 7 |
    //        +---+===+===+===+ +===+===+===+===+   +===+---+---+---+ +---+---+---+---+
    //            |<---------------- v ---------------->|
    //
    // [R] In the first clock cycle, we perform an aligned read to w1
    // [W] In the second clock cycle, we compute an aligned write of v to w1
    // [V] In the third clock cycle, we restore the demanded value from w1 and w2
    // [R] In the fourth clock cycle, we perform an aligned read to w2
    // [W] In the fiveth clock cycle, we compute an aligned write of v to w2

    permutation_assume(MEMORY_ID, sel, [addr64 + offset, step - 1 - clock, m0, m1])
    permutation_proves(MEMORY_ID, sel, [addr64 + offset, step - 1 - clock, m0, m1])
}