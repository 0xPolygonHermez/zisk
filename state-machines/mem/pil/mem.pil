require "std_permutation.pil"
// require "std_range_check.pil"

const int MEMORY_ID = 10;
const int MEMORY_CONT_ID = 11;

const int MEMORY_LOAD_OP = 1;
const int MEMORY_STORE_OP = 2;
const int MEMORY_MAX_DIFF = 2**22;

// TODO review ERROR: air Mem(int N = 2**21, int RC = 2, int id ) {

airtemplate Mem(int N = 2**21, int RC = 2, int id = MEMORY_ID, int MAX_STEP = 2 ** 23, int MEM_BYTES = 8 ) {
    col fixed INNER_L1 = [1,0...];
    const expr INNER_LAST = INNER_L1';

    // TODO: airgroup val
    airgroupval aggregate(sum) mem_segment;    // aggregate(serial)
    airgroupval aggregate(sum) mem_last_segment;        // aggregate(last)

    col witness addr;
    col witness step;
    col witness sel, rd, wr;
    col witness value[RC];
    col witness addr_changes;

    sel * (1 - sel) === 0;
    rd * (1 - rd) === 0;
    wr * (1 - wr) === 0;

    // if wr is 1, sel must be 1 (not allowed writes)
    wr * (1 - sel) === 0;

    // all time first line is lost
    sel * INNER_L1 === 0;

    // The list is sorted by [addr, step]
    addr_changes * (1 - addr_changes) === 0;


    // TODO: address memory must be at least 8
    // range_check((1 - INNER_L1), addr_changes * (addr - 'addr - step + 'step) + step - 'step, 1 + 7 * addr_changes, MEMORY_MAX_DIFF);

    // range_check((1 - INNER_L1), addr_changes * (addr - 'addr - step + 'step) + step - 'step, 1, MEMORY_MAX_DIFF);

    // At end of memory fill with same addr, incrementing step, same value, sel = 0, rd = 1, wr = 0

    // if addr_changes == 0 means that addr and previous address are the same
    (1 - addr_changes) * ('addr - addr) === 0;

    sel * (1 - sel) === 0;
    wr * (1 - wr) === 0;

    // wr could be 1 only if sel is 1
    (1 - sel) * wr === 0;

    // only rd or wr could be 1
    rd * wr === 0;

    for (int index = 0; index < length(value); index = index + 1) {
        rd * (1 - addr_changes) * (value[index] - 'value[index])  ===  0;
        rd * addr_changes * value[index]  ===  0;
    }

    // continuations
    permutation_proves(MEMORY_CONT_ID, INNER_LAST, [(mem_segment + 1)* (1 - mem_last_segment), 0, 1, 0, (1 - mem_last_segment) * addr, (1 - mem_last_segment) * step, ...value]);
    permutation_assumes(MEMORY_CONT_ID, INNER_L1, [mem_segment, 0, 1, 0, addr, step, ...value]);

    // bus
    permutation_proves(MEMORY_ID, sel, [rd + 2 * wr, addr * MEM_BYTES, step, MEM_BYTES, ...value]);

}

// TODO: detect non default value but not called, mandatory parameter.
function mem_load(int id = MEMORY_ID, expr sel = 1, expr addr, expr step, expr bytes = 8, expr value[]) {
    permutation_assumes(id, sel, [MEMORY_LOAD_OP, addr, step, bytes, ...value]);
}

function mem_store(int id = MEMORY_ID, expr sel = 1, expr addr, expr step, expr bytes = 8, expr value[]) {
    permutation_assumes(id, sel, [MEMORY_STORE_OP, addr, step, bytes, ...value]);
}