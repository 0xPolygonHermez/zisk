require "std_permutation.pil"
require "std_range_check.pil"

const int MEMORY_ID = 10;
const int MEMORY_CONT_ID = 11;

const int MEMORY_LOAD_OP = 1;
const int MEMORY_STORE_OP = 2;
const int MEMORY_MAX_DIFF = 2**24;

const int MAX_MEM_STEP_OFFSET = 2;
const int MAX_MEM_OPS_PER_MAIN_STEP = (MAX_MEM_STEP_OFFSET + 1) * 2;

airtemplate Mem(const int N = 2**21, const int id = MEMORY_ID, const int RC = 2, const int MEM_BYTES = 8, const int base_address = 0, int immutable = 0, const int free_input_mem = 0) {
    col fixed SEGMENT_L1 = [1,0...];
    const expr SEGMENT_LAST = SEGMENT_L1';

    const expr internal_base_address = base_address / MEM_BYTES;
    airval mem_segment;
    airval mem_last_segment;

    col witness addr;        // n-byte address, real address = addr * MEM_BYTES
    col witness step;
    col witness sel;
    col witness addr_changes;

    if (!free_input_mem) {
        col witness air.value[RC];
    } else {
        immutable = 1;
        col witness air.value_word[RC*2];
        const expr air.value[RC];
        for (int index = 0; index < RC; ++index) {
            value[index] = value_word[index*2] +  2**16 * value_word[index*2 + 1];

            // how value is a free-input, must be checked that it's 32-bit well formed value
            range_check(value_word[index*2], 0, 2**16 - 1);
            range_check(value_word[index*2+1], 0, 2**16 - 1);
        }
    }

    if (!immutable) {
        col witness air.wr;
        const expr air.rd = 1 - wr;
        wr * (1 - wr) === 0;
        // if wr is 1, sel must be 1 (not allowed writes)
        wr * (1 - sel) === 0;
    }

    sel * (1 - sel) === 0;

    // all time first line is lost, used for continuations
    sel * SEGMENT_L1 === 0;

    addr_changes * (1 - addr_changes) === 0;

    // check increment of memory
    if (free_input_mem) {
        // addresses are incremental, to save range check, increment, etc, address must be consecutive.
        addr_changes * (addr - 'addr - 1) === 0;
    } else {
        col witness air.increment;
        increment === SEGMENT_L1 * (addr - internal_base_address + 1) + (1 - SEGMENT_L1) * (addr_changes * (addr - 'addr - step + 'step) + step - 'step);
        range_check(colu: increment, min: 1, max: MEMORY_MAX_DIFF);
    }

    // PADDING: At end of memory fill with same addr, incrementing step, same value, sel = 0, rd = 1, wr = 0
    //          setting mem_last_segment = 1

    // if addr_changes == 0 means that addr and previous address are the same
    const expr same_addr = 1 - SEGMENT_L1 - addr_changes;
    same_addr * ('addr - addr) === 0;

    for (int index = 0; index < length(value); index++) {
        if (immutable) {
            // if address not change value must be equal to previous value
            (1 - addr_changes) * (value[index] - 'value[index])  ===  0;

            if (!free_input_mem) {
                // if address changes => write, and it must be inserted on bus
                addr_changes * (1 - sel)  ===  0;
            }
        } else {
            // if address not change and it isn't write, value must be equal to previous value
            (1 - addr_changes) * (1 - wr) * (value[index] - 'value[index])  ===  0;

            // if address changes, and it isn't a write, value must be 0.
            addr_changes * (1 - wr) * value[index]  ===  0;
        }
    }

    // CONTINUATIONS
    //
    // segments: S, S+1
    //
    // CASE: last row of segment is read
    //
    // S[n-1]    wr = 0, sel = 1, addr, step, value  => BUS.proves(MEM_CONT_ID, S+1, addr, step-1, value)
    // S+1[0]    wr = 0, sel = 0, addr, step, value  => BUS.assumes(MEM_CONT_ID, S, addr, step, value)
    //
    // CASE: last row of segment is write
    //
    // S[n-1]    wr = 1, sel = 1, addr, step, value  => BUS.proves(MEM_CONT_ID, S+1, addr, step-1, value)
    // S+1[0]    wr = 0, sel = 0, addr, step, value  => BUS.assumes(MEM_CONT_ID, S, addr, step, value)
    //
    // NOTES: from row = 1 all constraints could be reference previous row, without problems
    //        on row = 0 forced by constraint that sel = 0 => wr = 0.
    //        on S+1[0].step = S[n-1].step - 1;
    //
    // FIRST SEGMENT:
    // the BUS.proves needed by BUS.assumes of the first segment it's generated by global constraint to avoid
    // generate more than one cycle of memory. In this constraint we could force the initial address (to split
    // in two memories, one register-memory and other standard-memory).
    //
    // LAST SEGMENT:
    // the last not used rows are filled with last addr and value and sel = 0 and wr = 0 incrementing steps.
    // last BUS.proves not it's generated to avoid generate more than one memory cycle.

    // permutation_proves(MEMORY_CONT_ID, [(mem_segment + 1), addr, step, ...value], sel: mem_last_segment * 'SEGMENT_L1); // last row
    // permutation_assumes(MEMORY_CONT_ID, [mem_segment, 0, addr, step, ...value], sel: SEGMENT_L1); // first row

    // The Memory component is only able to prove aligned memory access, since we force the bus address to be a multiple of MEM_BYTES
    // and the width to be exactly MEM_BYTES
    // Notice, however, that the main can also use widths of 4, 2, 1 and addresses that are not multiples of MEM_BYTES.
    // These are handled with the Memory Align component

    if (free_input_mem) {
        permutation_proves(MEMORY_ID, cols: [MEMORY_LOAD_OP, addr * MEM_BYTES, step, MEM_BYTES, ...value], sel: sel);
    } else if (immutable) {
        permutation_proves(MEMORY_ID, cols: [addr_changes * (MEMORY_STORE_OP - MEMORY_LOAD_OP) + MEMORY_LOAD_OP, addr * MEM_BYTES, step, MEM_BYTES, ...value], sel: sel);
    } else {
        permutation_proves(MEMORY_ID, cols: [wr * (MEMORY_STORE_OP - MEMORY_LOAD_OP) + MEMORY_LOAD_OP, addr * MEM_BYTES, step, MEM_BYTES, ...value], sel: sel);
    }
}

function mem_load(int id = MEMORY_ID, expr addr, expr step, expr step_offset = 0, expr bytes = 8, expr value[], expr sel = 1) {
    mem_assumes(id, MEMORY_LOAD_OP, addr, step, step_offset, bytes, value, sel);
}

function mem_store(int id = MEMORY_ID, expr addr, expr step, expr step_offset = 0, expr bytes = 8, expr value[], expr sel = 1) {
    mem_assumes(id, MEMORY_STORE_OP, addr, step, step_offset, bytes, value, sel);
}

private function mem_assumes(int id, int mem_op, expr addr, expr step, expr step_offset, expr bytes, expr value[], expr sel) {
    if (step_offset > MAX_MEM_STEP_OFFSET) {
        error("step_offset ${step_offset} is greater than max value allowed ${MAX_MEM_STEP_OFFSET}");
    }

    // adding 1 at step for first continuation
    permutation_assumes(id, [mem_op, addr, 1 + MAX_MEM_OPS_PER_MAIN_STEP * step + 2 * step_offset, bytes, ...value], sel: sel);
}