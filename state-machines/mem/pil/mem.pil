/*
    Memory Component (Mem)
    ======================

    Memory is sorted by address and step for all memory accesses to prove the correctness of memory.
    This verifies that, within the same memory address, `mem_steps` (acting like timestamps) are
    incremental. Additionally, each time the address changes, it must be greater than the previous
    address to prevent repeated addresses.

    There are three types of memory:
    - Mutable (read/write) memory. The dual_mem feature can be enabled for this memory type.
    - Immutable (read-only) memory, with a single write at initialization.
    - Immutable free-input memory, always reading the same value for each address.


    - Allows to define a memory on a region. Initially the distance between address could up
      to 2^(36+3) bits = 2^39 = 512 GB, but executor use only 32 bits for address, so the maximum
      memory size is 4 GB
      - Inside this component the address are mem-byte address, to translate internal adress to
      external need to multiply by bytes.    
      - The memory regions must be exclusive, to avoid collisions between different memories.
    - The constraints over instances guarantees that the memory access are inside definited region.    
    - The constraints guarantees that only one cyle for memory region is allowed.
    - For non-aligned or for non mem-bytes access, the MemAlign machine was used.
    - For reads, it's possible read (only read) many times the same address, in same step, this
      feature is usefull for precompiles.

    Parameters:

    - N = number of rows
    - id = bus_id used of memory operations
    - RC = number of value chunks (2 by default)
    - bytes = number of bytes of memory word (8 bytes by default)
    - base_address = base byte address when start the memory
    - size_mb = size of memory in mega-bytes (1024^2, 128 by default)
    - large_mem = to force use two chunks for distance between base_address and previous_segment_addr
    - immutable = if memory is immutable, first access must be a write (by default is mutable)
    - free_input_mem = if memory is a free input memory, memory without write, all access are reads
                       with same value, this value it's stablished by executor.

    Continuations:

    - The memory continuation is used to proves the last row significant values of the current segment,
      and the next segment assume these significant values.
    - The first assume of memory is generated by global constraint to guarantees only one cycle by
      memory region.
    - In the last segment, the proves are not generated to avoid generate more than one memory cycle.
    - The constraints that refer to the values of the previous row, in the first row, take the value
      from the airvalue previous_segment_xxx, which contains the value at the end of the previous segment.
    - These previous airvalues are validated throw bus, because assume these values at end of previous
      segment.

    Dual Memory:

    - The dual memory feature groups the common parts of an operation, allowing the same row to validate 
      two read operations (RR) or one write operation followed by a read operation (WR).
    - These operations must be performed on the same address and the value must be the same; the only 
      difference is the step (timestamp).
    - Due a distribute limitations, chunk driven planner, this is only permitted if both operations 
      are in the same chunk. This limits the range for verifying that one operation follows another 
      in time: (step_dual - step) < 2^24 - 1.
    - It must be considered that to verify a row is subsequent, it should be compared with the previous 
      step_dual or step, depending on whether the dual mode was active in the previous row or not.

*/

require "std_permutation.pil"
require "std_range_check.pil"

const int MEMORY_ID = 10;
const int MEMORY_CONT_ID = 11;

const int MEMORY_LOAD_OP = 1;
const int MEMORY_STORE_OP = 2;
const int MEMORY_REG_OP = 3;

const int RESERVED_MEM_STEPS = 1;
const int MAX_MEM_STEP_OFFSET = 2;
const int MAX_MEM_STEPS_PER_MAIN_STEP = 4;

const int MAX_RANGE_CHECK_CHUNK = 2**16;

airtemplate Mem(const int N = 2**21, const int id = MEMORY_ID, const int RC = 2, const int bytes = 8,
                const int base_address = 0, const int size_mb = 128, int immutable = 0,
                const int free_input_mem = 0, const expr enable_flag = 1, const int use_predefined_ranges = 0, 
                const int large_mem = 0, const int dual_mem = 0) {

    col fixed SEGMENT_L1 = [1,0...];
    const expr SEGMENT_LAST = SEGMENT_L1';

    // in this air the address in a mem-bytes address (internal), when this address is pushed in BUS must be multiplied
    // by bytes to get the real address.

    assert(size_mb <= 128 || large_mem);

    const expr mem_size = size_mb * 1024 * 1024;
    const expr internal_base_address = base_address / bytes;
    const expr internal_end_address = (base_address + mem_size - 1) / bytes;
    airval segment_id;
    airval is_first_segment;
    airval is_last_segment;

    // constraints for boolean airvalues

    is_first_segment * (1 - is_first_segment) === 0;
    is_last_segment * (1 - is_last_segment) === 0;

    // If is_first_segment means that segment must be 0
    is_first_segment * segment_id === 0;

    col witness bits(29) addr;
    col witness bits(40) step;
    col witness bits(1) sel;
    col witness bits(1) addr_changes;

    if (dual_mem) {
        // Dual mem feature not supported for free input memory
        assert(free_input_mem == 0);
        // Dual mem feature not supported for immutable memory
        assert(immutable == 0);

        // Two columns, one for step (timestap) of second operation, and other
        // to enable dual operation in the row.
        col witness bits(40) air.step_dual;
        col witness bits(1) air.sel_dual;

        sel_dual * (1 - sel_dual) === 0;
        (1 - sel) * sel_dual === 0;
    }

    // boolean constraints

    sel * (1 - sel) === 0;
    addr_changes * (1 - addr_changes) === 0;

    // constraints over value

    if (free_input_mem) {
        immutable = 1;
        col witness bits(16) air.value_word[RC*2];

        // free read for free input, means an specific address (offset = 0) that could be read
        // many times with different well formed 64-bit values. Used for fcalls and other free-inputs

        col witness bits(1) air.is_free_read;
        is_free_read * (1 - is_free_read) === 0;
        is_free_read * (internal_base_address - addr) === 0;

        const expr air.value[RC];
        for (int index = 0; index < RC; ++index) {
            value[index] = value_word[index*2] +  MAX_RANGE_CHECK_CHUNK * value_word[index*2 + 1];

            // how value is a free-input, must be checked that it's 32-bit well formed value
            range_check(value_word[index*2], 0, MAX_RANGE_CHECK_CHUNK - 1, predefined: use_predefined_ranges);
            range_check(value_word[index*2+1], 0, MAX_RANGE_CHECK_CHUNK - 1, predefined: use_predefined_ranges);
        }
    } else {
        col witness bits(32) air.value[RC];
    }

    if (free_input_mem) {
        // free input memory must be read-only
        const int air.wr = 0;
    } else if (immutable) {
        // immutable memory in address change, must be write first or a read of zero.
        const expr air.wr = addr_changes * sel;
        for (int i = 0; i < RC; i++) {
            // really constraint is addr_changes * (1 - wr) * value[i] === 0, but it's simplified because
            // addr_changes * addr_changes = addr_changes
            addr_changes * (1 - sel) * value[i] === 0;
        }
    } else {
        col witness bits(1) air.wr;
        const expr air.rd = 1 - wr;

        // boolean constraint over wr;
        wr * (1 - wr) === 0;

        // all writes must be "launched" to the bus, not allowed silent writes
        wr * (1 - sel) === 0;
    }

    // CONTINUATIONS

    // These previous values used on direct update to air bus, using constraints proves the relation
    // with values of first row of current segment

    airval previous_segment_value[RC];
    airval previous_segment_step, previous_segment_addr;

    // In columns sent to the bus, we add base_address to avoid collisions between different memory
    // areas. Also for security send is_last_segment to avoid reuse end of last segment as start of
    // new cycle of segments

    // this constraint "assumes" that previous values of this segment

    direct_update_assumes(MEMORY_CONT_ID,
                  [
                    base_address,               // identify area of memory
                    segment_id,                 // current segment_id
                                                // proves of last segment
                    previous_segment_addr,
                    previous_segment_step,
                    ...previous_segment_value
                  ]);

    // This constraint "proves" that the previous values of the next segment are the current last
    // values of this segment (airvals).
    // These last values must match the last row values of the current segment.

    airval segment_last_value[RC];
    airval segment_last_step, segment_last_addr;

    for (int i = 0; i < RC; i++) {
        // The `segment_last_value[i]` air_value must match the `value[i]` from the last row. In this 
        // case, it doesn't matter if it's dual or not, because the value is unique for the last row.
        SEGMENT_LAST * (value[i] - segment_last_value[i]) === 0;
    }

    // The `segment_last_addr` air_value must match the `addr` from the last row. In this case, 
    // it doesn't matter if it's dual or not, because the addr is unique for the last row.
    SEGMENT_LAST * (addr - segment_last_addr) === 0;

    if (dual_mem) {
        // The `segment_last_step` air_value must match the step from the last row.
        // - If the last row was in dual mode, it must match the last `step_dual`.
        // - Otherwise, it must match the last `step`.
        SEGMENT_LAST * (sel_dual * (step_dual - step) + step - segment_last_step) === 0;
    } else {
        // The `segment_last_step` air_value must match the `step` from the last row.
        SEGMENT_LAST * (step - segment_last_step) === 0;
    }

    direct_update_proves(MEMORY_CONT_ID,
                  [
                    base_address,               // identify area of memory
                    segment_id + 1,             // next segment_id, for last segment
                                                // this value is forced to 0 to match global constraint
                    segment_last_addr,          // last addr of segment
                    segment_last_step,          // last step of segment
                    ...segment_last_value
                  ],
                  sel: (1 - is_last_segment));

    const int zeros[air.RC];
    for (int i = 0; i < length(zeros); ++i) {
        zeros[i] = 0;
    }

    // Global constraint to ensure that memory segments are initialized only once. The `enable_flag`
    // must be a boolean value. The constraint on this boolean should be defined outside of memory
    // to prevent redundant constraints.This flag is used to handle cases where a memory area is not
    // used during a given execution.

    direct_global_update_proves(MEMORY_CONT_ID, [ base_address, 0, internal_base_address, 0, ...zeros], sel: enable_flag);

    // For security, ensure that the first address has the correct value to prevent adding a large
    // number of instances that could cause an "overflow" in the prime field.

    if (large_mem) {
        // Distance between the internal base address of memory area and previous_segment_address 
        // could be greater than 2^24, so we divide this distance in two chunks of 16 bits, to verify 
        // that this distance is "positive"

        airval distance_base[2];

        previous_segment_addr - internal_base_address === distance_base[0] + 0x10000 * distance_base[1];

        range_check(expression: distance_base[0], min: 0, max: 0xFFFF);
        range_check(expression: distance_base[1], min: 0, max: 0xFFFF);
    } else {
        range_check(expression: previous_segment_addr - internal_base_address, min: 0, max: 2**24 - 1);
    }

    // Final memory control: the last address must be within the memory area.
    // Since the initial address is inside the memory area and addresses are either equal or incremental,
    // if the last address is within the memory area, all addresses are guaranteed to be inside as well.

    if (large_mem) {
        // Distance between the last address and the end address of the memory area could be greater than 2^24, so
        // we divide this distance in two chunks of 16 bits, to verify that this distance is "positive"

        airval distance_end[2];

        internal_end_address - segment_last_addr === distance_end[0] + 0x10000 * distance_end[1];

        range_check(expression: distance_end[0], min: 0, max: 0xFFFF);
        range_check(expression: distance_end[1], min: 0, max: 0xFFFF);
        assert(size_mb <= 4096);
    } else {
        range_check(expression: internal_end_address - segment_last_addr, min: 0, max: 2**24 - 1);
        assert(size_mb <= 128);
    }

    // Check the order of operations inside segment

    if (immutable) {

        // Immutable means that all operations must produces the same value. In the case of
        // free-input memory, no write operations exist. The first read value for a given address
        // determines all subsequent values for that same address.

        // In this type of memory, addresses need to be ordered. However, execution typically
        // accesses a full range of addresses. To avoid wasting a range check, we assume that
        // addresses are consecutive (note that addresses are `bytes` addresses). If the executor
        // detects that an address has not been accessed, it must be added but not sent to the bus.

        // `previous_addr` is `previous_segment_addr` in row 0 and the `addr` of the previous row
        // for all other rows.

        if (free_input_mem) {

            // In the case of free-input memory, in first segment, if the first row is equal to
            // previous addr, means that is_free_read is active, value is free. In case of the first
            // row is different, the `address_change` is active, and value could change.
            // With this consideration,  the first value of first row is always free, and we could
            // use 0 as previous value on global constraint of first segment.

            const expr air.previous_addr = SEGMENT_L1 * (previous_segment_addr - 'addr) + 'addr;
        } else {

            // In the case of immutable, no free-input memory, the first row must be "different" to
            // force `address_change`. For this reason, we subtract one from `previous_segment_addr`,
            // which in the first segment is equal to the first address of the memory area.

            const expr air.previous_addr = SEGMENT_L1 * (previous_segment_addr - is_first_segment - 'addr) + 'addr;
        }

        const expr delta_addr = addr - previous_addr;

        // read_same_addr = (1 - addr_changes) * (1 - wr)
        // - free_input_mem, wr = 0, so read_same_addr = (1 - addr_changes)
        // - immutable, wr = addr_changes * sel, so read_same_addr = (1 - addr_changes) * (1 - addr_changes * sel)
        //      addr_changes = 0, read_same_addr = 1 (not matter if sel = 0 or 1)
        //      addr_changes = 1, read_same_addr = 0 (not matter if sel = 0 or 1)
        //   means for immutable read_same_addr = (1 - addr_changes)

        const expr air.read_same_addr = (1 - addr_changes);

        // If the address changes, the difference must be one

        addr_changes * (delta_addr - 1) === 0;

        // If the address does not change, the current address and previous must be the same.

        (1 - addr_changes) * (addr - previous_addr) === 0;


    } else {

        // In this case we don't need to substract one, as happends on immutable memory, because the step of first
        // previous segment is 0 and first possible step is greater than 0.

        const expr air.previous_addr = SEGMENT_L1 * (previous_segment_addr - 'addr) + 'addr;
        const expr delta_addr = addr - previous_addr;

        // on first row of first segment could be the same and address_change = 1 because it's as a new addr
        // SEGMENT_L1 * (x + is_first_segment * SEGMENT_L1) === SEGMENT_L1 * (x + is_first_segment)

        
        if (dual_mem) {
            // The `previous_step` column must match with the `step` from the previous row.
            // - If the previous row was in dual mode, it must match the previous `step_dual`.
            // - Otherwise, it must match the previous `step`.

            col witness bits(40) air.previous_step;
            const expr previous_row_step = 'sel_dual * ('step_dual - 'step) + 'step;
            previous_step === SEGMENT_L1 * (previous_segment_step - previous_row_step) + previous_row_step;
        } else {
            const expr air.previous_step = SEGMENT_L1 * (previous_segment_step - 'step) + 'step;
        }
        const expr delta_step = step - previous_step + (1 - wr);

        col witness bits(18) air.increment[2];
        increment[0] + 2**18 * increment[1] + 1 === addr_changes * (delta_addr - delta_step) + delta_step;

        is_first_segment * SEGMENT_L1 * (1 - addr_changes) === 0;

        // addr_change == 1 => [0,2^18-1] => 18 + 18 = 36 bits + 3 => 39 bits => 512 GB
        // addr_change == 0 => [0,2^18-1] => 18 + 18 = 36 bits => STEP upto 2^34 => 16 GB steps
        // 36 bits x 2^22 = 2^58 + 2^32 address = 2^59 secure.

        range_check(expression: increment[0], min: 0, max: 2**18 - 1);
        range_check(expression: increment[1], min: 0, max: 2**18 - 1);

        // to avoid intermediate column
        col witness bits(1) air.read_same_addr;

        read_same_addr === (1 - addr_changes) * (1 - wr);

        if (dual_mem) {
            // Range check to validate that `step_dual` > `step` if the row is dual. In case of operations
            // RR, `step_dual` could be equal to `step`, but in operation WR, `step_dual` must be strictly 
            // greater than `step`. How dual operation must be in same chunk, with range_check of 2^24 is
            // enough if chunk_size <= 2^22.
            range_check(expression: step_dual - step - wr , min: 0, max: 2**24 - 1, sel: sel_dual);
        }
    }

    // if addr_changes is 0, check that previous address match with current addr.

    (1 - addr_changes) * (addr - previous_addr) === 0;

    // PADDING: At end of memory fill with same addr, incrementing step, same value, sel = 0, rd = 1, wr = 0
    //          setting is_last_segment = 1

    // if addr_changes == 0 means that addr and previous address are the same

    for (int index = 0; index < length(value); index++) {
        const expr previous_value = SEGMENT_L1 * (previous_segment_value[index] - 'value[index]) + 'value[index];
        if (free_input_mem) {
            // if address not change value must be equal to previous value, when is_free_read
            // is active the value not change, so value must be equal to previous value
            (1 - addr_changes) * (1 - is_free_read) * (value[index] - previous_value)  ===  0;

        } else if (immutable) {
            // if address not change value must be equal to previous value
            (1 - addr_changes) * (value[index] - previous_value)  ===  0;

        } else {
            // if address not change and it isn't write, value must be equal to previous value
            read_same_addr * (value[index] - previous_value)  ===  0;

            // if address changes, and it isn't a write, value must be 0.
            addr_changes * (1 - wr) * value[index]  ===  0;
        }
    }

    // The Memory component is only able to prove aligned memory access, since we force the bus address to be a multiple of bytes
    // and the width to be exactly bytes
    // Notice, however, that the main can also use widths of 4, 2, 1 and addresses that are not multiples of bytes.
    // These are handled with the Memory Align component

    const expr mem_op = wr * (MEMORY_STORE_OP - MEMORY_LOAD_OP) + MEMORY_LOAD_OP;
    permutation_proves(MEMORY_ID, expressions: [mem_op, addr * bytes, step, bytes, ...value], sel: sel);

    if (dual_mem) {
        // dual mem memory, send to bus always a READ operation, with same address, and value, only change de step.
        permutation_proves(MEMORY_ID, expressions: [MEMORY_LOAD_OP, addr * bytes, step_dual, bytes, ...value], sel: sel_dual);
    }
}

// Memory helpers to use the memory
// mem_step is the step of memory step, to translate from main_step to mem_step use main_step_to_mem_step

// Helpers for main memory operations

// Function to send to bus a memory load operations (only for main)
function mem_load(int id = MEMORY_ID, expr addr, expr mem_step, expr bytes = 8, expr value[], expr sel = 1, int name = PIOP_NAME_DEFAULT) {
    mem_assumes(id, MEMORY_LOAD_OP, addr, mem_step, bytes, value, sel, name);
}

// Function to send to bus a memory write operation (only for main)
function mem_store(int id = MEMORY_ID, expr addr, expr mem_step, expr bytes = 8, expr value[], expr sel = 1, int name = PIOP_NAME_DEFAULT) {
    mem_assumes(id, MEMORY_STORE_OP, addr, mem_step, bytes, value, sel, name);
}

// Function to send to bus a memory operation (only for main)
function mem_op(int id = MEMORY_ID, expr op, expr addr, expr mem_step, expr bytes = 8, expr value[], expr sel = 1, int name = PIOP_NAME_DEFAULT) {
    mem_assumes(id, op, addr, mem_step, bytes, value, sel, name);
}

// Helpers for main memory operations

// Functions to translate from main step send to bus, to memory step (used by precompiled memory operations)
function main_step_to_precompiled_mem_step(const expr step, const expr is_write = 0): expr {
    return RESERVED_MEM_STEPS + MAX_MEM_STEPS_PER_MAIN_STEP * step + is_write + 2;
}

// Helpers for precompiled memory operations

function precompiled_mem_op(int id = MEMORY_ID, expr addr, expr main_step, expr value[], expr sel = 1, int name = PIOP_NAME_DEFAULT, const expr is_write = 0) {
    const expr op = is_write * (MEMORY_STORE_OP - MEMORY_LOAD_OP) + MEMORY_LOAD_OP;
    mem_assumes(id, op, addr, main_step_to_precompiled_mem_step(main_step, is_write), 8, value, sel, name);
}

function precompiled_mem_load(int id = MEMORY_ID, expr addr, expr main_step, expr value[], expr sel = 1, int name = PIOP_NAME_DEFAULT) {
    mem_assumes(id, MEMORY_LOAD_OP, addr, main_step_to_precompiled_mem_step(main_step), 8, value, sel, name);
}

function precompiled_mem_store(int id = MEMORY_ID, expr addr, expr main_step, expr value[], expr sel = 1, int name = PIOP_NAME_DEFAULT ) {
    mem_assumes(id, MEMORY_STORE_OP, addr, main_step_to_precompiled_mem_step(main_step, 1), 8, value, sel, name);
}

// Helpers for main registers operations (reuse memory operations)

function reg_pre_load(int id = MEMORY_ID, expr addr, expr prev_mem_step, expr value[], expr sel = 1, int name = PIOP_NAME_DEFAULT) {
    mem_proves(id, MEMORY_REG_OP, addr, prev_mem_step, value, sel, name: name);
}

function reg_pre_store(int id = MEMORY_ID, expr addr, expr prev_mem_step, expr value[], expr sel = 1, int name = PIOP_NAME_DEFAULT) {
    mem_proves(id, MEMORY_REG_OP, addr, prev_mem_step, value, sel, name);
}

// Function to send the register operation cycle initialization to the bus.
function global_init_mem(int id = MEMORY_ID, expr addr, expr value[], expr sel = 1, int name = PIOP_NAME_DEFAULT) {
    direct_global_update_assumes(id, [MEMORY_REG_OP, addr, 0, 8, ...value], sel: sel, name: name);
}

// Functions to translate from main step to memory step (used by main)

function main_step_to_mem_step(const expr step, int step_offset = 0): expr {
    if (step_offset > MAX_MEM_STEP_OFFSET) {
        error("step_offset ${step_offset} is greater than max value allowed ${MAX_MEM_STEP_OFFSET}");
    }
    return RESERVED_MEM_STEPS + MAX_MEM_STEPS_PER_MAIN_STEP * step + step_offset;
}

function main_step_to_special_mem_step(const expr step):expr {
    return RESERVED_MEM_STEPS + MAX_MEM_STEPS_PER_MAIN_STEP * step + MAX_MEM_STEPS_PER_MAIN_STEP - 1;
}

private function mem_assumes(int id, expr mem_op, expr addr, expr mem_step, expr bytes, expr value[], expr sel, int name = PIOP_NAME_DEFAULT) {
    // adding 1 at step for first continuation
    permutation_assumes(id, [mem_op, addr, mem_step, bytes, ...value], sel: sel, name: name);
}

private function mem_proves(int id, expr mem_op, expr addr, expr mem_step, expr value[], expr sel, int name = PIOP_NAME_DEFAULT) {
    // adding 1 at step for first continuation
    permutation_proves(id, [mem_op, addr, mem_step, 8, ...value], sel: sel, name: name);
}
