/*
    Memory Component (Mem)
    ======================

    - Allows to define a memory on a region with size <= MEMORY_MAX_DIFF * mem_bytes (2^24).
    - Inside this component the address are mem-byte address, to translate internal adress to
      external need to multiply by mem_bytes.
    - For executors optimization, external addresses use 32-bits.
    - The memory regions must be exclusive, to avoid collisions between different memories.
    - The constraints over instances guarantees that the memory access are inside definited region.
    - The constraints guarantees that only one cyle for memory region is allowed.
    - For non-aligned or for non mem-bytes access, the MemAlign machine was used.

    Parameters:

    - N = number of rows
    - id = bus_id used of memory operations
    - RC = number of value chunks (2 by default)
    - mem_bytes = number of bytes of memory word (8 bytes by default)
    - base_address = base byte address when start the memory
    - mem_size = size of memory in bytes (0x800_0000 by default)
    - immutable = if memory is immutable, first access is a write (by default is mutable)
    - free_input_mem = if memory is a free input memory, memory without write, all access are reads
                       with same value, this value it's stablished by executor.

    Continuations:

    - The memory continuation is used to proves the last row significant values of the current segment,
      and the next segment assume these significant values.
    - The first assume of memory is generated by global constraint to guarantees only one cycle by
      memory region.
    - In the last segment, the proves are not generated to avoid generate more than one memory cycle.
    - The constraints that refer to the values of the previous row, in the first row, take the value
      from the airvalue previous_segment_xxx, which contains the value at the end of the previous segment.
    - These previous airvalues are validated throw bus, because assume these values at end of previous
      segment.

*/

require "std_permutation.pil"
require "std_range_check.pil"

const int MEMORY_ID = 10;
const int MEMORY_CONT_ID = 11;

const int MEMORY_LOAD_OP = 1;
const int MEMORY_STORE_OP = 2;
const int MEMORY_MAX_DIFF = 2**24;

const int RESERVED_MEM_STEPS = 1;
const int MAX_MEM_STEP_OFFSET = 2;
const int MAX_MEM_STEPS_PER_MAIN_STEP = 4;

airtemplate Mem(const int N = 2**21, const int id = MEMORY_ID, const int RC = 2, const int mem_bytes = 8,
                const int base_address = 0, const int mem_size = 0x800_0000, int immutable = 0,
                const int free_input_mem = 0, const expr enable_flag = 1) {

    col fixed SEGMENT_L1 = [1,0...];
    const expr SEGMENT_LAST = SEGMENT_L1';

    // in this air the address in a mem-bytes address (internal), when this address is pushed in BUS must be multiplied
    // by mem_bytes to get the real address.

    const expr internal_base_address = base_address / mem_bytes;
    const expr internal_end_address = (base_address + mem_size - 1) / mem_bytes;
    airval segment_id;
    airval is_first_segment;
    airval is_last_segment;

    is_first_segment * (1 - is_first_segment) === 0;
    is_last_segment * (1 - is_last_segment) === 0;
    is_first_segment * segment_id === 0;

    col witness addr;        // n-byte address, real address = addr * mem_bytes
    col witness step;
    col witness sel;
    col witness addr_changes;

    if (!free_input_mem) {
        col witness air.value[RC];
    } else {
        immutable = 1;
        col witness air.value_word[RC*2];
        const expr air.value[RC];
        for (int index = 0; index < RC; ++index) {
            value[index] = value_word[index*2] +  2**16 * value_word[index*2 + 1];

            // how value is a free-input, must be checked that it's 32-bit well formed value
            range_check(value_word[index*2], 0, 2**16 - 1);
            range_check(value_word[index*2+1], 0, 2**16 - 1);
        }
    }


    if (free_input_mem) {
        // free input memory must be read-only
        const int air.wr = 0;
    } else if (immutable) {
        // immutable memory in address change, must be write first or a read of zero.
        const expr air.wr = addr_changes * sel;
        for (int i = 0; i < RC; i++) {
            // addr_changes * (1 - wr) * value[i] === 0;
            addr_changes * (1 - sel) * value[i] === 0;
        }
    } else {
        col witness air.wr;
        const expr air.rd = 1 - wr;
        wr * (1 - wr) === 0;
        // if wr is 1, sel must be 1 (not allowed writes)
        wr * (1 - sel) === 0;
    }

    sel * (1 - sel) === 0;

    addr_changes * (1 - addr_changes) === 0;

    airval previous_segment_value[RC];
    airval previous_segment_step, previous_segment_addr;

    // continuation for next segment, these values used on direct update to air bus, and after
    // with constraints force that these values are the same as last row of current segment.

    airval segment_last_value[RC];
    airval segment_last_step, segment_last_addr;

    for (int i = 0; i < RC; i++) {
        SEGMENT_LAST * (value[i] - segment_last_value[i]) === 0;
    }

    SEGMENT_LAST * (addr - segment_last_addr) === 0;
    SEGMENT_LAST * (step - segment_last_step) === 0;

    // add base_address to the columns to avoid collisions between different memories
    // for security send is_last_segment to avoid reuse end of last segment as start of new cycle of segments
    direct_update_assumes(MEMORY_CONT_ID,
                  [
                    base_address,                               // identify area of memory
                    segment_id,                                 // current segment_id
                                                                // proves of last segment
                    previous_segment_addr,
                    previous_segment_step,
                    ...previous_segment_value
                  ]);

    direct_update_proves(MEMORY_CONT_ID,
                  [
                    base_address,                               // identify area of memory
                    segment_id + 1,                             // next segment_id, for last segment
                                                                // this value is forced to 0 to match global constraint
                    segment_last_addr,                          // last addr of segment
                    segment_last_step,                          // last step of segment
                    ...segment_last_value
                  ],
                  sel: (1 - is_last_segment));

    const int zeros[air.RC];
    for (int i = 0; i < length(zeros); ++i) {
        zeros[i] = 0;
    }

    direct_global_update_proves(MEMORY_CONT_ID, [ base_address, 0, internal_base_address, 0, ...zeros], sel: enable_flag);

    // for security check that first address has correct value, to avoid add huge quantity of instances to "overflow" prime field.
    range_check(expression: previous_segment_addr - internal_base_address + 1, min: 1, max: MEMORY_MAX_DIFF);

    // control final of memory
    range_check(expression: internal_end_address - segment_last_addr + 1, min: 1, max: MEMORY_MAX_DIFF);


    // check increment of memory
    if (immutable) {
        // addresses are incremental, to save range check, increment, etc, address must be consecutive.
        const expr air.previous_addr = SEGMENT_L1 * (previous_segment_addr - is_first_segment - 'addr) + 'addr;
        const expr delta_addr = addr - previous_addr;
        addr_changes * (delta_addr - 1) === 0;
        (1 - addr_changes) * (addr - previous_addr) === 0;
    } else {
        const expr air.previous_addr = SEGMENT_L1 * (previous_segment_addr - 'addr) + 'addr;
        const expr delta_addr = addr - previous_addr;

        // on first row of first segment could be the same and address_change = 1 because it's as a new addr
        // SEGMENT_L1 * (x + is_first_segment * SEGMENT_L1) === SEGMENT_L1 * (x + is_first_segment)

        const expr previous_step = SEGMENT_L1 * (previous_segment_step - 'step) + 'step;
        const expr delta_step = step - previous_step;

        col witness increment;
        increment === addr_changes * (delta_addr - delta_step) + delta_step;

        is_first_segment * SEGMENT_L1 * (1 - addr_changes) === 0;

        range_check(expression: increment, min: 1, max: MEMORY_MAX_DIFF);
    }

    (1 - addr_changes) * (addr - previous_addr) === 0;

    // PADDING: At end of memory fill with same addr, incrementing step, same value, sel = 0, rd = 1, wr = 0
    //          setting is_last_segment = 1

    // if addr_changes == 0 means that addr and previous address are the same
    // TODO:

    for (int index = 0; index < length(value); index++) {
        const expr previous_value = SEGMENT_L1 * (previous_segment_value[index] - 'value[index]) + 'value[index];
        if (immutable) {
            // if address not change value must be equal to previous value
            (1 - addr_changes) * (value[index] - previous_value)  ===  0;

        } else {
            // if address not change and it isn't write, value must be equal to previous value
            // TODO: boundary constraints
            (1 - addr_changes) * (1 - wr) * (value[index] - previous_value)  ===  0;

            // if address changes, and it isn't a write, value must be 0.
            addr_changes * (1 - wr) * value[index]  ===  0;
        }
    }

    // The Memory component is only able to prove aligned memory access, since we force the bus address to be a multiple of mem_bytes
    // and the width to be exactly mem_bytes
    // Notice, however, that the main can also use widths of 4, 2, 1 and addresses that are not multiples of mem_bytes.
    // These are handled with the Memory Align component

    const expr mem_op = wr * (MEMORY_STORE_OP - MEMORY_LOAD_OP) + MEMORY_LOAD_OP;
    permutation_proves(MEMORY_ID, expressions: [mem_op, addr * mem_bytes, step, mem_bytes, ...value], sel: sel);
}

function mem_load(int id = MEMORY_ID, expr addr, expr mem_step, expr bytes = 8, expr value[], expr sel = 1, int name = PIOP_NAME_DEFAULT) {
    mem_assumes(id, MEMORY_LOAD_OP, addr, mem_step, bytes, value, sel, name);
}

function mem_store(int id = MEMORY_ID, expr addr, expr mem_step, expr bytes = 8, expr value[], expr sel = 1, int name = PIOP_NAME_DEFAULT) {
    mem_assumes(id, MEMORY_STORE_OP, addr, mem_step, bytes, value, sel, name);
}

function main_step_to_precompiled_mem_step(const expr step, const int is_write = 0): expr {
    const int write_inc = is_write ? 3 : 2;
    return RESERVED_MEM_STEPS + MAX_MEM_STEPS_PER_MAIN_STEP * step + write_inc;
}

function precompiled_mem_load(int id = MEMORY_ID, expr addr, expr main_step, expr value[], expr sel = 1, int name = PIOP_NAME_DEFAULT) {
    mem_assumes(id, MEMORY_LOAD_OP, addr, main_step_to_precompiled_mem_step(main_step), 8, value, sel, name: name);
}

function precompiled_mem_store(int id = MEMORY_ID, expr addr, expr main_step, expr value[], expr sel = 1, int name = PIOP_NAME_DEFAULT ) {
    mem_assumes(id, MEMORY_STORE_OP, addr, main_step_to_precompiled_mem_step(main_step, 1) + 1, 8, value, sel, name: name);
}

function main_step_to_mem_step(const expr step, int step_offset = 0): expr {
    if (step_offset > MAX_MEM_STEP_OFFSET) {
        error("step_offset ${step_offset} is greater than max value allowed ${MAX_MEM_STEP_OFFSET}");
    }
    return RESERVED_MEM_STEPS + MAX_MEM_STEPS_PER_MAIN_STEP * step + step_offset;
}

function main_step_to_special_mem_step(const expr step):expr {
    return RESERVED_MEM_STEPS + MAX_MEM_STEPS_PER_MAIN_STEP * step + MAX_MEM_STEPS_PER_MAIN_STEP - 1;
}

private function mem_assumes(int id, int mem_op, expr addr, expr mem_step, expr bytes, expr value[], expr sel, int name = PIOP_NAME_DEFAULT) {
    // adding 1 at step for first continuation
    permutation_assumes(id, [mem_op, addr, mem_step, bytes, ...value], sel: sel, name: name);
}

private function mem_proves(int id, int mem_op, expr addr, expr mem_step, expr value[], expr sel, int name = PIOP_NAME_DEFAULT) {
    // adding 1 at step for first continuation
    permutation_proves(id, [mem_op, addr, mem_step, 8, ...value], sel: sel, name: name);
}
