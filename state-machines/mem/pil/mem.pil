require "std_permutation.pil"
require "std_range_check.pil"

const int MEMORY_ID = 10;
const int MEMORY_CONT_ID = 11;

const int MEMORY_LOAD_OP = 1;
const int MEMORY_STORE_OP = 2;
const int MEMORY_MAX_DIFF = 2**22;

// TODO review ERROR: air Mem(int N = 2**21, int RC = 2, int id ) {

airtemplate Mem (int N = 2**21, int RC = 2, int id = MEMORY_ID, int MAX_STEP = 2 ** 23, int MEM_BYTES = 8 ) {
    col fixed SEGMENT_L1 = [1,0...];
    const expr SEGMENT_LAST = SEGMENT_L1';

    // TODO: airgroup val
    // airgroupval aggregate(sum) mem_segment;         // aggregate(serial)
    // airgroupval aggregate(sum) mem_last_segment;    // aggregate(last)
    col witness mem_segment; 
    col witness mem_last_segment;

    col witness addr;  // n-byte address, real address = addr * MEM_BYTES
    col witness step;
    col witness sel, wr;
    col witness value[RC];
    col witness addr_changes;

    const expr rd = (1 - wr);
    sel * (1 - sel) === 0;
    wr * (1 - wr) === 0;

    // if wr is 1, sel must be 1 (not allowed writes)
    wr * (1 - sel) === 0;

    // all time first line is lost, used for continuations
    sel * SEGMENT_L1 === 0;

    // CONTINUATIONS
    // 
    // segments: S, S+1
    // 
    // CASE: last row of segment is read
    // 
    // S[n-1]    wr = 0, sel = 1, addr, step, value  => BUS.proves(MEM_CONT_ID, S+1, addr, step-1, value)
    // S+1[0]    wr = 0, sel = 0, addr, step, value  => BUS.assumes(MEM_CONT_ID, S, addr, step, value)
    //
    // CASE: last row of segment is write
    // 
    // S[n-1]    wr = 1, sel = 1, addr, step, value  => BUS.proves(MEM_CONT_ID, S+1, addr, step-1, value)
    // S+1[0]    wr = 0, sel = 0, addr, step, value  => BUS.assumes(MEM_CONT_ID, S, addr, step, value)
    //
    // NOTES: from row = 1 all constraints could be reference previous row, without problems
    //        on row = 0 forced by constraint that sel = 0 => wr = 0.
    //        on S+1[0].step = S[n-1].step - 1;
    //
    // FIRST SEGMENT: 
    // the BUS.proves needed by BUS.assumes of the first segment it's generated by global constraint to avoid
    // generate more than one cycle of memory. In this constraint we could force the initial address (to split
    // in two memories, one register-memory and other standard-memory).
    //
    // LAST SEGMENT: 
    // the last not used rows are filled with last addr and value and sel = 0 and wr = 0 incrementing steps.
    // last BUS.proves not it's generated to avoid generate more than one memory cycle.

    addr_changes * (1 - addr_changes) === 0;

    // check increment of memory
    range_check(sel: (1 - SEGMENT_L1), colu: addr_changes * (addr - 'addr - step + 'step) + step - 'step, min: 1, max: MEMORY_MAX_DIFF);

    // At end of memory fill with same addr, incrementing step, same value, sel = 0, rd = 1, wr = 0

    // if addr_changes == 0 means that addr and previous address are the same
    (1 - addr_changes) * ('addr - addr) === 0;

    col witness value_equal;
    (1 - value_equal) * (1 - wr) * (1 - addr_change) === 0;

    col witness first_addr_access_is_read;
    (1 - first_addr_access_is_read) * rd * (1 - addr_changes) === 0;

    for (int index = 0; index < length(value); index = index + 1) {
        value_equal * (value[index] - 'value[index])  ===  0;
        first_addr_access_is_read * value[index]  ===  0;
    }

    // continuations
    permutation_proves(MEMORY_CONT_ID, SEGMENT_LAST, [(mem_segment + 1), addr, step, ...value], sel: SEGMENT_L1); // last row
    permutation_assumes(MEMORY_CONT_ID, SEGMENT_L1, [mem_segment, addr, step, ...value], sel: end ); // first row
    // first row

    // bus
    permutation_proves(MEMORY_ID, cols: [wr, addr * MEM_BYTES, step, MEM_BYTES, ...value], sel: sel); 
}

// TODO: detect non default value but not called, mandatory parameter.
function mem_load(int id = MEMORY_ID, expr sel = 1, expr addr, expr step, expr bytes = 8, expr value[]) {
    permutation_assumes(id, [MEMORY_LOAD_OP, addr, 1 + step, bytes, ...value], sel:sel);
}

function mem_store(int id = MEMORY_ID, expr sel = 1, expr addr, expr step, expr bytes = 8, expr value[]) {
    permutation_assumes(id, [MEMORY_STORE_OP, addr, 1 + st  ep, bytes, ...value], sel:sel);
}