require "std_lookup.pil"
require "std_range_check.pil"

/*
    Operation table summary:
    =======================================

    List of 64-bit proven operations:
    ┼────────┼──────────┼──────────────┼─────────────┼
    │  name  │   op     │ in2_low_bits │ op_is_shift │
    ┼────────┼──────────┼──────────────┼─────────────┼
    │  SLL   │   0x31   │      6       │      x      │
    │  SRL   │   0x32   │      6       │      x      │
    │  SRA   │   0x33   │      6       │      x      │
    ┼────────┼──────────┼──────────────┼─────────────┼

    List of 32-bit proven operations:
    ┼────────┼──────────┼──────────────┼─────────────┼
    │  name  │   op     │ in2_low_bits │ op_is_shift │
    ┼────────┼──────────┼──────────────┼─────────────┼
    │  SLL_W │   0x34   │      5       │      x      │
    │  SRL_W │   0x35   │      5       │      x      │
    │  SRA_W │   0x36   │      5       │      x      │
    │  SE_B  │   0x37   │      0       │             │
    │  SE_H  │   0x38   │      0       │             │
    │  SE_W  │   0x39   │      0       │             │
    ┼────────┼──────────┼──────────────┼─────────────┼

    Examples:
    =======================================

    SLL 28
    x    in1[x]    out[x][0]     out[x][1]
    ---------------------------------------
    0    0x11      0x10000000    0x00000001
    1    0x22      0x00000000    0x00000220
    2    0x33      0x00000000    0x00033000
    3    0x44      0x00000000    0x04400000
    4    0x55      0x00000000    0x50000000
    5    0x66      0x00000000    0x00000000
    6    0x77      0x00000000    0x00000000
    7    0x88      0x00000000    0x00000000
    ---------------------------------------
    Result:        0x10000000    0x54433221

    SLL_W 8
    x    in1[x]    out[x][0]     out[x][1]
    ---------------------------------------
    0    0x11      0x00001100    0x00000000
    1    0x22      0x00220000    0x00000000
    2    0x33      0x33000000    0x00000000
    3    0x44      0x00000000    0x00000044
    4    0x55      0x00000000    0x00000000 (since 0x44 & 0x80 = 0, we stop here and set the remaining bytes to 0x00)
    5    0x66      0x00000000    0x00000000 (bytes of in1 are ignored from here)
    6    0x77      0x00000000    0x00000000
    7    0x88      0x00000000    0x00000000
    ---------------------------------------
    Result:        0x33221100    0x00000000

    SE_H
    x    in2[x]    out[x][0]     out[x][1]
    ---------------------------------------
    0    0xbc      0x000000bc    0x00000000
    1    0x8a      0xFFFF8a00    0xFFFFFFFF (since 0x8a & 0x80 = 0x80, we stop here and set the remaining bytes to 0xFF)
    2    0x33      0x00000000    0x00000000 (bytes of in2 are ignored from here)
    3    0x44      0x00000000    0x00000000
    4    0x55      0x00000000    0x00000000
    5    0x66      0x00000000    0x00000000
    6    0x77      0x00000000    0x00000000
    7    0x88      0x00000000    0x00000000
    ---------------------------------------
    Result:        0xFFFF8abc    0xFFFFFFFF
*/

airtemplate BinaryExtension(const int N = 2**18, const int bits = 64, const int operation_bus_id = OPERATION_BUS_ID) {
    if (bits <= 0) {
        error(`bits=${bits} must be positive integer`);
    } else if (bits % 16 != 0) {
        error(`Bits=${bits} must be divisible by 16`);
    }

    // Default values
    const int BYTES = bits / 8;
    const int HALF_BYTES = BYTES / 2;
    const int BYTE_BASE = (1 << BYTES);

    // Primary columns
    col witness bits(6)  op;                  // operation code
    col witness bits(8)  free_in_a[BYTES];    // input A per byte
    col witness bits(8)  free_in_b;           // input B (only one byte)
    col witness bits(32) free_in_c[BYTES][2]; // output C byte, split in 2 parts

    // Flags and helpers
    col witness bits(1)  op_is_shift;         // 1 if operation is in the shift family; 0 otherwise

    // Constraints to check the correctness of each binary operation
    for (int j = 0; j < BYTES; j++) {
       lookup_assumes(BINARY_EXTENSION_TABLE_ID, [op, j, free_in_a[j], free_in_b, free_in_c[j][0], free_in_c[j][1], op_is_shift]);
    }

    // Constraints to make sure that this component is called from the main component
    col witness bits(32) b[2];
    range_check(expression: b[0], min: 0, max: 2**24 - 1, sel: op_is_shift);

    expr a[2];
    a[0] = 0;
    a[1] = 0;
    for (int j = 0; j < HALF_BYTES; j++) {
        const int byte_weight = BYTE_BASE ** j;
        a[0] += (byte_weight * free_in_a[j]);
        a[1] += (byte_weight * free_in_a[HALF_BYTES + j]);
    }

    expr c[2];
    c[0] = 0;
    c[1] = 0;
    for (int j = 0; j < BYTES; j++) {
        c[0] += free_in_c[j][0];
        c[1] += free_in_c[j][1];
    }

    // if op_is_shift == 1 => [op, a[0],  a[1], free_in_b + 256 * b[0], b[1], sum(free_in_c[*][0]), sum(free_in_c[*][1]), 0]
    // if op_is_shift == 0 => [op, b[0],  b[1], a[0],                   a[1], sum(free_in_c[*][0]), sum(free_in_c[*][1]), 0]
    col witness bits(1) multiplicity;
    multiplicity * (1 - multiplicity) === 0; // multiplicity is not used yet, so it must be 0 or 1
    lookup_proves(
        operation_bus_id,
        [
            op,
            op_is_shift * (a[0] - b[0]) + b[0],
            op_is_shift * (a[1] - b[1]) + b[1],
            op_is_shift * (free_in_b + BYTE_BASE * b[0] - a[0]) + a[0],
            op_is_shift * (b[1] - a[1]) + a[1],
            c[0],
            c[1],
            0
        ],
        multiplicity
    );
}
