require "std_lookup.pil";
require "std_range_check.pil";
require "operations.pil";
require "opids.pil";
require "binary_extension_table.pil";

// Coprocessor in charge of performing standard RISCV binary operations

/*
List:
    ┼──────────┼────────┼──────────┼
    │  name    │  bits  │   op     │
    ┼──────────┼────────┼──────────┼
    │  SLL     │   64   │   0x21   │
    │  SRL     │   64   │   0x22   │
    │  SRA     │   64   │   0x23   │
    │  SLL_W   │   32   │   0x24   │
    │  SRL_W   │   32   │   0x25   │
    │  SRA_W   │   32   │   0x26   │
    │  SEXT_B  │   32   │   0x27   │
    │  SEXT_H  │   32   │   0x28   │
    │  SEXT_W  │   32   │   0x29   │
    ┼──────────┼────────┼──────────┼

Examples:
=======================================

SLL 28
x    in1[x]    out[x][0]     out[x][1]
---------------------------------------
0    0x11      0x10000000    0x00000001
1    0x22      0x00000000    0x00000220
2    0x33      0x00000000    0x00033000
3    0x44      0x00000000    0x04400000
4    0x55      0x00000000    0x50000000
5    0x66      0x00000000    0x00000000
6    0x77      0x00000000    0x00000000
7    0x88      0x00000000    0x00000000
---------------------------------------
Result:        0x10000000    0x54433221

SLL_W 8
x    in1[x]    out[x][0]     out[x][1]
---------------------------------------
0    0x11      0x00001100    0x00000000
1    0x22      0x00220000    0x00000000
2    0x33      0x33000000    0x00000000
3    0x44      0x00000000    0x00000044
4    0x55      0x00000000    0x00000000 (since 0x44 & 0x80 = 0, we stop here and set the remaining bytes to 0x00)
5    0x66      0x00000000    0x00000000 (bytes of in1 are ignored from here)
6    0x77      0x00000000    0x00000000
7    0x88      0x00000000    0x00000000
---------------------------------------
Result:        0x33221100    0x00000000

SEXT_H
x    in2[x]    out[x][0]     out[x][1]
---------------------------------------
0    0xbc      0x000000bc    0x00000000
1    0x8a      0xFFFF8a00    0xFFFFFFFF (since 0x8a & 0x80 = 0x80, we stop here and set the remaining bytes to 0xFF)
2    0x33      0x00000000    0x00000000 (bytes of in2 are ignored from here)
3    0x44      0x00000000    0x00000000
4    0x55      0x00000000    0x00000000
5    0x66      0x00000000    0x00000000
6    0x77      0x00000000    0x00000000
7    0x88      0x00000000    0x00000000
---------------------------------------
Result:        0xFFFF8abc    0xFFFFFFFF
*/

airtemplate BinaryExtension(const int N = 2**18, const int bits = 64, const int operation_bus_id = OPERATION_BUS_ID) {
    if (bits != 64) {
        error(`Currently only bits=64 is supported, got bits=${bits}`);
    }

    // Default values
    const int BYTES = bits / 8;
    const int HALF_BYTES = BYTES / 2;
    const int BYTE_BASE = (1 << BYTES);

    // Primary columns
    col witness bits(6)  op;                  // operation code
    col witness bits(8)  free_in_a[BYTES];    // input A per byte
    col witness bits(8)  free_in_b;           // input B (only one byte)
    col witness bits(32) free_in_c[BYTES][2]; // output C byte, split in 2 parts
    
    // Flags and helpers
    col witness bits(1)  op_is_shift;         // 1 if operation is in the shift family; 0 otherwise

    // Constraints to check the correctness of each binary operation
    for (int j = 0; j < BYTES; j++) {
       lookup_assumes(BINARY_EXTENSION_TABLE_ID, [op, j, free_in_a[j], free_in_b, free_in_c[j][0], free_in_c[j][1], op_is_shift]);
    }

    // Constraints to make sure that this component is called from the main component
    col witness bits(32) b[2];
    range_check(expression: b[0], min: 0, max: 2**24 - 1, sel: op_is_shift);

    expr a[2];
    a[0] = 0;
    a[1] = 0;
    for (int j = 0; j < HALF_BYTES; j++) {
        const int byte_weight = BYTE_BASE ** j;
        a[0] += (byte_weight * free_in_a[j]);
        a[1] += (byte_weight * free_in_a[HALF_BYTES + j]);
    }

    expr c[2];
    c[0] = 0;
    c[1] = 0;
    for (int j = 0; j < BYTES; j++) {
        c[0] += free_in_c[j][0];
        c[1] += free_in_c[j][1];
    }

    // if op_is_shift == 1 => [op, a[0],  a[1], free_in_b + 256 * b[0], b[1], sum(free_in_c[*][0]), sum(free_in_c[*][1]), 0]
    // if op_is_shift == 0 => [op, b[0],  b[1], a[0],                   a[1], sum(free_in_c[*][0]), sum(free_in_c[*][1]), 0]
    lookup_proves(
        operation_bus_id,
        [
            op,
            op_is_shift * (a[0] - b[0]) + b[0],
            op_is_shift * (a[1] - b[1]) + b[1],
            op_is_shift * (free_in_b + BYTE_BASE * b[0] - a[0]) + a[0],
            op_is_shift * (b[1] - a[1]) + a[1],
            c[0],
            c[1],
            0
        ]
    );

    airval padding_size;
    direct_update_assumes(operation_bus_id, [OP_SEXT_B, 0, 0, 0, 0, 0, 0, 0], sel: padding_size);
}
