require "std_lookup.pil"
require "constants.pil"

// Operations Table:
//                                                                Running Total
// SLL     (OP:0x0d)   2^8 (A) * 2^3 (OFFSET) * 2^8 (B)  = 2^19 |               2^19
// SRL     (OP:0x0e)   2^8 (A) * 2^3 (OFFSET) * 2^8 (B)  = 2^19 |       2^20                      
// SRA     (OP:0x0f)   2^8 (A) * 2^3 (OFFSET) * 2^8 (B)  = 2^19 |       2^20  + 2^19
// SLL_W   (OP:0x1d)   2^8 (A) * 2^3 (OFFSET) * 2^8 (B)  = 2^19 | 2^21  
// SRL_W   (OP:0x1e)   2^8 (A) * 2^3 (OFFSET) * 2^8 (B)  = 2^19 | 2^21        + 2^19
// SRA_W   (OP:0x1f)   2^8 (A) * 2^3 (OFFSET) * 2^8 (B)  = 2^19 | 2^21 + 2^20        => 2^22

const int SHIFT_TABLE_ID = 124;

airtemplate ShiftTable(const int N = 2**22, const int disable_fixed = 0) {
    
    #pragma memory m1 start

    const int SE_MASK_32 = 0xFFFFFFFF00000000;

    const int SIGN_32_BIT = 0x80000000;
    const int SIGN_BYTE = 0x80;

    const int LS_5_BITS = 0x1F;
    const int LS_6_BITS = 0x3F;
    
    col witness multiplicity;

    if (disable_fixed) {
        col fixed _K = [0...];
        // FORCE ONE TRACE
        multiplicity * _K === 0;
        
        println("*** DISABLE_FIXED ***"); 
        return;
    }

    if (N < 2**22) {
        error("N must be at least 2^22");
    }

    const int bits = 64;
    const int bytes = bits / 8;

    #pragma timer tt start
    #pragma timer t1 start
    col fixed A = [0..255]...;                              // Input A    (8 bits)

    col fixed OFFSET = [0:P2_8..(bytes-1):P2_8]...;         // Offset     (3 bits)

    col fixed B = [[0:P2_11..255:P2_11]:6,                  // Input B    (8 bits)
                    0:(P2_11*3)]...;                    

    col fixed OP = [0x0d:P2_19, 0x0e:P2_19, 0x0f:P2_19,     // SLL, SRL, SRA
                    0x1d:P2_19, 0x1e:P2_19, 0x1f:P2_19]...; // SLL_W, SRL_W, SRA_W

    #pragma timer t1 end
    #pragma timer t2 start

    #pragma fixed_size dword
    col fixed C0;                                           // Output C0  (32 bits)
    #pragma fixed_size dword
    col fixed C1;                                           // Output C1  (32 bits)

    #pragma transpile
    for (int i = 0; i < N; i++) {
        int [op, offset, a, b] = [OP[i], OFFSET[i], A[i], B[i]];
        int _out = 0;
        const int _a = a << (8*offset);
        switch (op) {
            case 0x0d: // SLL
                _out = _a << (b & LS_6_BITS); 

            case 0x0e: // SRL
                _out = _a >> (b & LS_6_BITS);

            case 0x0f: { // SRA 
                const int _b = b & LS_6_BITS;
                _out = _a >> _b;
                if (offset == 7) {
                    // most significant bit of most significant byte define if negative or not
                    // if negative then add b bits one on the left
                    if (a & SIGN_BYTE) {
                        _out = _out | (MASK_64 << (64 - _b));
                    }
                }
            }

            case 0x1d: // SLL_W
                if (offset >= 4) {
                    // last most significant bytes are ignored because it's 32-bit operation
                    _out = 0;
                } else {
                    _out = (_a << (b & LS_5_BITS)) & MASK_32;
                    if (_out & SIGN_32_BIT) {
                        _out = _out | SE_MASK_32;
                    }
                }
                
            case 0x1e: // SRL_W
                if (offset >= 4) {
                    // last most significant bytes are ignored because it's 32-bit operation
                    _out = 0;
                } else {
                    _out = (_a >> (b & LS_5_BITS)) & MASK_32;
                    if (_out & SIGN_32_BIT) {
                        _out = _out | SE_MASK_32;
                    }
                }

            case 0x1f: // SRA_W
                if (offset >= 4) {
                    // last most significant bytes are ignored because it's 32-bit operation
                    _out = 0;
                } else {
                    const int _b = b & LS_5_BITS;
                    _out = _a >> _b;
                    if (offset == 3) {
                        // most significant bit of most significant byte define if negative or not
                        // if negative then add b bits one on the left
                        if (a & SIGN_BYTE) {
                            _out = _out | (MASK_64 << (32 - _b));
                        }
                    }
                }

            default:
                error(`Invalid operation ${op}`);
        }

        const int _c0 = _out & MASK_32;
        const int _c1 = (_out >> 32) & MASK_32;
        C0[i] = _c0;
        C1[i] = _c1;
        log(`T ${i},${op},${offset},${a},${b},${_c0},${_c1},${_out}`)
    }
    #pragma timer t2 end
    #pragma timer tt end

    lookup_proves(SHIFT_TABLE_ID, [OP, OFFSET, A, B, C0, C1], multiplicity);
    #pragma memory m1 end
}