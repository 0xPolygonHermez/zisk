require "std_constants.pil";
require "std_lookup.pil";
require "operations.pil";
require "opids.pil";

/* PIL Binary Operations Table used by Binary Extension
                                                       Running Total
    SLL      2^8 (A) * 2^3 (OFFSET) * 2^8 (B)  = 2^19 |               2^19
    SRL      2^8 (A) * 2^3 (OFFSET) * 2^8 (B)  = 2^19 |       2^20
    SRA      2^8 (A) * 2^3 (OFFSET) * 2^8 (B)  = 2^19 |       2^20  + 2^19
    SLL_W    2^8 (A) * 2^3 (OFFSET) * 2^8 (B)  = 2^19 | 2^21
    SRL_W    2^8 (A) * 2^3 (OFFSET) * 2^8 (B)  = 2^19 | 2^21        + 2^19 
    SRA_W    2^8 (A) * 2^3 (OFFSET) * 2^8 (B)  = 2^19 | 2^21 + 2^20 
    SEXT_B   2^8 (A) * 2^3 (OFFSET)            = 2^11 | 2^21 + 2^20               + 2^11
    SEXT_H   2^8 (A) * 2^3 (OFFSET)            = 2^11 | 2^21 + 2^20        + 2^12
    SEXT_W   2^8 (A) * 2^3 (OFFSET)            = 2^11 | 2^21 + 2^20        + 2^12 + 2^11 => 2^22
*/

const int BINARY_EXTENSION_TABLE_SIZE = P2_19 * 6 + P2_11 * 3;

airtemplate BinaryExtensionTable(const int N = 2**22) {
    if (N < BINARY_EXTENSION_TABLE_SIZE) {
        error(`N must be at least ${BINARY_EXTENSION_TABLE_SIZE}, but N=${N} was provided`);
    }

    const int SE_MASK_32 = 0xFF_FF_FF_FF_00_00_00_00;
    const int SE_MASK_16 = 0xFF_FF_FF_FF_FF_FF_00_00;
    const int SE_MASK_8 =  0xFF_FF_FF_FF_FF_FF_FF_00;

    const int SIGN_32_BIT = 0x80_00_00_00;
    const int SIGN_BYTE = 0x80;

    const int LS_5_BITS = 0x1F;
    const int LS_6_BITS = 0x3F;

    // Input A    (8 bits)
    col fixed A = [0..255]...;

    // Offset     (3 bits)
    col fixed OFFSET = [0:P2_8..7:P2_8]...;

    // Input B    (8 bits)
    col fixed B = [[0:P2_11..255:P2_11]:3, // SLL, SRL, SRA
                   [0:P2_11..255:P2_11]:3, // SLL_W, SRL_W, SRA_W
                    0:(P2_11*3)]...;       // SEXT_B, SEXT_H, SEXT_W

    // Operation opcode
    col fixed OP = [   OP_SLL:P2_19,    OP_SRL:P2_19,    OP_SRA:P2_19,     // SLL, SRL, SRA
                     OP_SLL_W:P2_19,  OP_SRL_W:P2_19,  OP_SRA_W:P2_19,     // SLL_W, SRL_W, SRA_W
                    OP_SEXT_B:P2_11, OP_SEXT_H:P2_11, OP_SEXT_W:P2_11]...; // SEXT_B, SEXT_H, SEXT_W


    col fixed C0; // Output C0  (32 bits)
    col fixed C1; // Output C1  (32 bits)
    col fixed FLAGS; // Flags (1 bit): op_is_shift

    #pragma transpile
    for (int i = 0; i < N; i++) {
        int [op, offset, a, b] = [OP[i], OFFSET[i], A[i], B[i]];
        int out = 0;
        int op_is_shift = 0;
        const int a_pos = a << (8*offset);
        switch (op) {
            case OP_SLL: // SLL: Shift Left Logical
                // Shifts value left by B positions
                // Example: SLL(0x12, offset=0, B=4) = 0x120
                // Example: SLL(0x80, offset=1, B=1) = 0x10000 (0x8000 << 1)
                out = a_pos << (b & LS_6_BITS);

                op_is_shift = 1;

            case OP_SRL: // SRL: Shift Right Logical
                // Shifts value right by B positions
                // Example: SRL(0x80, offset=0, B=4) = 0x8
                // Example: SRL(0xFF, offset=2, B=8) = 0xFF00 (0xFF0000 >> 8)
                out = a_pos >> (b & LS_6_BITS);

                op_is_shift = 1;

            case OP_SRA: // SRA: Shift Right Arithmetic
                // Shifts value right by B positions, preserves sign bit
                // Example: SRA(0x80, offset=7, B=8) = 0xFF80000000000000 (sign extends)
                // Example: SRA(0x7F, offset=7, B=1) = 0x3F80000000000000 (no sign extend)
                const int _b = b & LS_6_BITS;
                out = a_pos >> _b;
                if (offset == 7) {
                    // most significant bit of most significant byte define if negative or not
                    // if negative then add b bits one on the left
                    if (a & SIGN_BYTE) {
                        out = out | (MASK_64 << (64 - _b));
                    }
                }

                op_is_shift = 1;

            case OP_SLL_W: // SLL_W: Shift Left Logical Word
                // Shifts value left by B positions, sign extends the rest
                // Example: SLL_W(0x12, offset=0, B=4) = 0x120
                // Example: SLL_W(0x01, offset=3, B=7) = 0xFFFFFFFF80000000
                if (offset >= 4) {
                    // last most significant bytes are ignored because it's 32-bit operation
                    out = 0;
                } else {
                    out = (a_pos << (b & LS_5_BITS)) & MASK_32;
                    if (out & SIGN_32_BIT) {
                        out = out | SE_MASK_32;
                    }
                }

                op_is_shift = 1;

            case OP_SRL_W: // SRL_W: Shift Right Logical Word 
                // Shifts value right by B positions, sign extends the rest
                // Example: SRL_W(0x80, offset=0, B=4) = 0x8
                // Example: SRL_W(0xFF, offset=3, B=1) = 0x7F800000 
                if (offset >= 4) {
                    // last most significant bytes are ignored because it's 32-bit operation
                    out = 0;
                } else {
                    out = (a_pos >> (b & LS_5_BITS)) & MASK_32;
                    if (out & SIGN_32_BIT) {
                        out = out | SE_MASK_32;
                    }
                }

                op_is_shift = 1;

            case OP_SRA_W: // SRA_W: Shift Right Arithmetic Word 
                // Shifts value right by B positions, preserves sign
                // Example: SRA_W(0x80, offset=3, B=1) = 0xFFFFFFFF40000000
                // Example: SRA_W(0x7F, offset=3, B=1) = 0x3F800000
                if (offset >= 4) {
                    // last most significant bytes are ignored because it's 32-bit operation
                    out = 0;
                } else {
                    const int _b = b & LS_5_BITS;
                    out = a_pos >> _b;
                    if (offset == 3) {
                        // most significant bit of most significant byte define if negative or not
                        // if negative then add b bits one on the left
                        if (a & SIGN_BYTE) {
                            out = out | (MASK_64 << (32 - _b));
                        }
                    }
                }

                op_is_shift = 1;

            case OP_SEXT_B: // SEXT_B: Sign Extend Byte (8-bit to 64-bit)
                // Sign extends an 8-bit value to 64-bit
                // Example: SEXT_B(0x7F, offset=0) = 0x7F (positive byte)
                // Example: SEXT_B(0x80, offset=0) = 0xFFFFFFFFFFFFFF80 (negative byte)
                // Example: SEXT_B(0x42, offset=1) = 0x0 (ignored, only offset 0 matters)
                if (offset == 0) {
                    // the most significant bit of first byte determines the sign extend
                    out = (a & SIGN_BYTE) ? a | SE_MASK_8 : a
                } else {
                    // the rest of the bytes are ignored
                    out = 0;
                }

            case OP_SEXT_H: // SEXT_H: Sign Extend Halfword (16-bit to 64-bit)
                // Sign extends a 16-bit value to 64-bit
                // Example: SEXT_H with offset=0,A=0x34 and offset=1,A=0x12 = 0x1234 (positive)
                // Example: SEXT_H with offset=0,A=0x34 and offset=1,A=0x80 = 0xFFFFFFFFFFFF8034 (negative)
                if (offset == 0) {
                    // fist byte not define the sign extend, but participate of result
                    out = a;
                } else if (offset == 1) {
                    // the most significant bit of second byte determines the sign extend
                    out = (a & SIGN_BYTE) ? a_pos | SE_MASK_16 : a_pos
                } else {
                    // the rest of the bytes are ignored
                    out = 0;
                }

            case OP_SEXT_W: // SEXT_W: Sign Extend Word (32-bit to 64-bit)
                // Sign extends a 32-bit value to 64-bit
                // Example: SEXT_W with bytes forming 0x12345678 = 0x12345678 (positive)
                // Example: SEXT_W with bytes forming 0x80000000 = 0xFFFFFFFF80000000 (negative)
                if (offset <= 3) {
                    out = a_pos;
                    if (offset == 3) {
                        if (a & SIGN_BYTE) {
                            // the most significant bit of fourth byte determines the sign extend
                            out = out | SE_MASK_32
                        }
                    }
                }

            default:
                error(`Invalid operation opcode: ${op} at row ${i}`);
        }

        const int c0 = out & MASK_32;
        const int c1 = (out >> 32) & MASK_32;
        C0[i] = c0;
        C1[i] = c1;
        const int flags = op_is_shift;
        FLAGS[i] = flags;
        log(`T[${i}] = [${op}, ${offset}, ${a}, ${b}, ${c0}, ${c1}, ${flags}]`);
    }

    col witness multiplicity;
    lookup_proves(BINARY_EXTENSION_TABLE_ID, [OP, OFFSET, A, B, C0, C1, FLAGS], multiplicity);
}