require "std_constants.pil";
require "std_lookup.pil"

/* PIL Binary Operations Table used by Binary
                                                                                                   Running Total
    MINU       (OP:0x02)      2^8 (A) x 2^8 (B) x 2^1 (POS_IND) x 2^1 (CIN) x 2^1 (FLAGS)  = 2^19 |                      2^19
    MIN        (OP:0x03)      2^8 (A) x 2^8 (B) x 2^1 (POS_IND) x 2^1 (CIN) x 2^1 (FLAGS)  = 2^19 |               2^20
    MAXU       (OP:0x04)      2^8 (A) x 2^8 (B) x 2^1 (POS_IND) x 2^1 (CIN) x 2^1 (FLAGS)  = 2^19 |               2^20 + 2^19
    MAX        (OP:0x05)      2^8 (A) x 2^8 (B) x 2^1 (POS_IND) x 2^1 (CIN) x 2^1 (FLAGS)  = 2^19 |        2^21
    LT_ABS_NP  (OP:0x06)      2^8 (A) x 2^8 (B) x 2^2 (POS_IND) x 2^1 (CIN)                = 2^19 |        2^21        + 2^19
    LT_ABS_PN  (OP:0x07)      2^8 (A) x 2^8 (B) x 2^2 (POS_IND) x 2^1 (CIN)                = 2^19 |        2^21 + 2^20
    LTU        (OP:0x08)      2^8 (A) x 2^8 (B) x 2^1 (POS_IND) x 2^1 (CIN)                = 2^18 |        2^21 + 2^20        + 2^18
    LT         (OP:0x09)      2^8 (A) x 2^8 (B) x 2^1 (POS_IND) x 2^1 (CIN)                = 2^18 |        2^21 + 2^20 + 2^19
    GT         (OP:0x0a)      2^8 (A) x 2^8 (B) x 2^1 (POS_IND) x 2^1 (CIN)                = 2^18 |        2^21 + 2^20 + 2^19 + 2^18
    EQ         (OP:0x0b)      2^8 (A) x 2^8 (B) x 2^1 (POS_IND) x 2^1 (CIN)                = 2^18 | 2^22 
    ADD        (OP:0x0c)      2^8 (A) x 2^8 (B) x 2^1 (POS_IND) x 2^1 (CIN)                = 2^18 | 2^22                      + 2^18
    SUB        (OP:0x0d)      2^8 (A) x 2^8 (B) x 2^1 (POS_IND) x 2^1 (CIN)                = 2^18 | 2^22               + 2^19
    LEU        (OP:0x0e)      2^8 (A) x 2^8 (B) x 2^1 (POS_IND) x 2^1 (CIN)                = 2^18 | 2^22               + 2^19 + 2^18
    LE         (OP:0x0f)      2^8 (A) x 2^8 (B) x 2^1 (POS_IND) x 2^1 (CIN)                = 2^18 | 2^22        + 2^20
    AND        (OP:0x10)  *   2^8 (A) x 2^8 (B) x 2^1 (POS_IND)                            = 2^17 | 2^22        + 2^20               + 2^17
    OR         (OP:0x11)  *   2^8 (A) x 2^8 (B) x 2^1 (POS_IND)                            = 2^17 | 2^22        + 2^20        + 2^18
    XOR        (OP:0x12)  *   2^8 (A) x 2^8 (B) x 2^1 (POS_IND)                            = 2^17 | 2^22        + 2^20        + 2^18 + 2^17
    SEXT_00    (OP:0x13)  **  2^8 (A) x 2^8 (B)                 x 2^1 (CIN) x 2^1 (FLAGS)  = 2^18 | 2^22        + 2^20 + 2^19        + 2^17
    SEXT_FF    (OP:0x14)  **  2^8 (A) x 2^8 (B)                 x 2^1 (CIN) x 2^1 (FLAGS)  = 2^18 | 2^22        + 2^20 + 2^19 + 2^18 + 2^17 => < 2^23
    -------------------------------------------------------------------------------------------------------------------
    (*)  Do not uses POS_IND in its operation, but the binary does so we need to consider it
    (**) Do not uses A,B,CIN in its operation, but the binary does so we need to consider them
    Note: SEXT_00, SEXT_FF are the only (unary) operation which is not a ZisK OP but are used to prove the rest
*/

const int BINARY_TABLE_ID = 125;
const int BINARY_TABLE_SIZE = P2_19 * 6 + P2_18 * 8 + P2_17 * 3 + P2_18 * 2;
const int SEXT_00 = 0x13;
const int SEXT_FF = 0x14;

airtemplate BinaryTable(const int N = 2**23) {
    if (N < BINARY_TABLE_SIZE) {
        error(`N must be at least ${BINARY_TABLE_SIZE}, but N=${N} was provided`);
    }

    const int SIGN_BYTE = 0x80;

    // Input A (8 bits)
    col fixed A = [0..255]...;                          

    // Input B (8 bits)
    col fixed B = [0:P2_8..255:P2_8]...;

    // Indicator of the byte position (<=2 bits)
    //  - 2 indicates the first byte
    //  - 1 indicates the last byte
    //  - 0 indicates a middle byte
    col fixed POS_IND = [[0:P2_16, 1:P2_16]:(4*4),          // MINU,MIN,MAXU,MAX
                         [0:P2_16..2:P2_16, 2:P2_16]:(2*2), // LT_ABS_NP,LT_ABS_PN
                         [0:P2_16, 1:P2_16]:(4*2),          // LTU,LT,GT,EQ
                         [0:P2_16, 1:P2_16]:(2*2),          // ADD,SUB
                         [0:P2_16, 1:P2_16]:(2*2),          // LEU,LE
                         [0:P2_16, 1:P2_16]:3,              // AND,OR,XOR
                          0:P2_18, 0:P2_18]...;             // SEXT_00,SEXT_FF

    // Input carry (1 bit)
    col fixed CIN = [[0:P2_17, 1:P2_17]:(4*2),     // MINU,MIN,MAXU,MAX
                     [0:P2_18, 1:P2_18]:2,         // LT_ABS_NP,LT_ABS_PN
                     [0:P2_17, 1:P2_17]:4,         // LTU,LT,GT,EQ
                     [0:P2_17, 1:P2_17]:2,         // ADD,SUB
                     [0:P2_17, 1:P2_17]:2,         // LEU,LE
                      0:(P2_17*3),                 // AND,OR,XOR
                     [0:P2_16, 1:P2_16]:(2*2)]...; // SEXT_00,SEXT_FF

    // Operation opcode
    col fixed OP = [0x02:P2_19, 0x03:P2_19, 0x04:P2_19, 0x05:P2_19, // MINU,MIN,MAXU,MAX
                    0x06:P2_19, 0x07:P2_19,                         // LT_ABS_NP,LT_ABS_PN
                    0x08:P2_18, 0x09:P2_18, 0x0a:P2_18, 0x0b:P2_18, // LTU,LT,GT,EQ
                    0x0c:P2_18, 0x0d:P2_18,                         // ADD,SUB
                    0x0e:P2_18, 0x0f:P2_18,                         // LEU,LE
                    0x10:P2_17, 0x11:P2_17, 0x12:P2_17,             // AND,OR,XOR
                    0x13:P2_18, 0x14:P2_18]...;                     // SEXT_00,SEXT_FF


    col fixed C;             // Output C (8 bits)
    col fixed FLAGS;         // Combined flags (8 bits): cout + 2*result_is_a + 4*use_first_byte + 8*c_is_signed

    int relative_index = 0;
    #pragma transpile logfile:/tmp/binary_table.txt
    for (int i = 0; i < N; i++) {
        const int [pos_ind, op, a, b, cin] = [POS_IND[i], OP[i], A[i], B[i], CIN[i]];
        relative_index = (i == 0 || OP[i-1] != op) ? 0 : relative_index + 1;
        const int pfirst = (pos_ind == 2) ? 1 : 0;
        const int plast = (pos_ind == 1) ? 1 : 0;
        int c = 0;
        int cout = 0;
        int result_is_a = 0;
        int use_first_byte = 0;
        int c_is_signed = 0;
        switch (op) {
            case 0x02,0x03: // MINU,MIN: Minimum operation
                // Returns min(a,b). MINU for unsigned, MIN for signed.
                // Example: MINU(5,3) = 3, MIN(-1,3) = -1
                if (a < b) {
                    cout = 1;
                } else if (a == b) {
                    cout = cin;
                } else {
                    cout = 0;
                }

                result_is_a = relative_index >= P2_18 ? 1 : 0;

                if (result_is_a) {
                    c = a;
                } else {
                    c = b;
                }

                if (plast) {
                    if (op == 0x03 && (a & SIGN_BYTE) != (b & SIGN_BYTE)) {
                        cout = (a & SIGN_BYTE) ? 1 : 0;
                    }

                    c_is_signed = (c & SIGN_BYTE) ? 1 : 0;
                }

            case 0x04,0x05: // MAXU,MAX: Maximum operation
                // Returns max(a,b). MAXU for unsigned, MAX for signed.
                // Example: MAXU(5,3) = 5, MAX(-1,3) = 3
                if (a > b) {
                    cout = 1;
                } else if (a == b) {
                    cout = cin;
                } else {
                    cout = 0;
                }

                result_is_a = relative_index >= P2_18 ? 1 : 0;

                if (result_is_a) {
                    c = a;
                } else {
                    c = b;
                }

                if (plast) {
                    if (op == 0x05 && (a & SIGN_BYTE) != (b & SIGN_BYTE)) {
                        cout = (b & SIGN_BYTE) ? 1 : 0;
                    }

                    c_is_signed = (c & SIGN_BYTE) ? 1 : 0;
                }

            case 0x06: // LT_ABS_NP: Absolute value comparison |a| < |b| where a < 0 and b > 0
                // Compares absolute values when a is negative and b is positive
                // Example: LT_ABS_NP(-3, 5) = 1 (|-3| < |5|), LT_ABS_NP(-7, 5) = 0 (|-7| > |5|)
                const int _a = a ^ 0xFF;
                const int _b = b;
                const int sub = pfirst ? (_a + 1) - _b : _a - _b; // |a| - b

                if (sub < 0) {
                    cout = 1;
                } else if (sub == 0) {
                    cout = cin;
                } else {
                    cout = 0;
                }
                
                c = 0;

                use_first_byte = 1;

            case 0x07: // LT_ABS_PN: Absolute value comparison |a| < |b| where a > 0 and b < 0
                // Compares absolute values when a is positive and b is negative
                // Example: LT_ABS_PN(3, -5) = 1 (|3| < |-5|), LT_ABS_PN(7, -5) = 0 (|7| > |-5|)
                const int _a = a;
                const int _b = b ^ 0xFF;
                const int sub = pfirst ? _a - (_b + 1) : _a - _b; // a - |b|

                if (sub < 0) {
                    cout = 1;
                } else if (sub == 0) {
                    cout = cin;
                } else {
                    cout = 0;
                }

                c = 0;

                use_first_byte = 1;

            case 0x08,0x09: // LTU,LT: Less than comparison
                // Returns 1 if a < b, 0 otherwise. LTU for unsigned, LT for signed.
                // Example: LTU(3,5) = 1, LT(-1,3) = 1, LTU(5,3) = 0
                if (a < b) {
                    cout = 1;
                } else if (a == b) {
                    cout = cin;
                } else {
                    cout = 0;
                }

                c = 0;

                // If the chunk is signed, then the result is the sign of a
                if (op == 0x09 && plast && (a & SIGN_BYTE) != (b & SIGN_BYTE)) {
                    cout = (a & SIGN_BYTE) ? 1 : 0;
                }

            case 0x0a: // GT: Greater than comparison (signed)
                // Returns 1 if a > b, 0 otherwise (signed comparison)
                // Example: GT(5,3) = 1, GT(-1,3) = 0, GT(3,3) = 0
                if (a > b) {
                    cout = 1;
                } else if (a == b) {
                    cout = cin;
                } else {
                    cout = 0;
                }

                c = 0;

                // The result is the sign of b
                if (plast && (a & SIGN_BYTE) != (b & SIGN_BYTE)) {
                    cout = (b & SIGN_BYTE) ? 1 : 0;
                }

            case 0x0b: // EQ: Equality comparison
                // Returns 1 if a == b, 0 otherwise
                // Example: EQ(5,5) = 1, EQ(3,5) = 0
                if (cin == 0 && a == b) {
                    cout = 0; // is_eq
                } else {
                    cout = 1; // is_neq
                }

                c = 0;

                if (plast) {
                    // cout = 0 means a == b => change cout = 1
                    cout = 1 - cout;
                }

            case 0x0c: // ADD: Addition with carry
                // Performs a + b + cin
                // Example: ADD(5,3,0) = 8, ADD(255,1,0) = 0
                const int sum = cin + a + b;
                c = sum & 0xFF;
                cout = plast ? 0 : sum >> 8;

                if (plast) {
                    c_is_signed = (c & SIGN_BYTE) ? 1 : 0;
                }

            case 0x0d: // SUB: Subtraction with borrow
                // Performs a - b - cin (where cin is borrow)
                // Example: SUB(5,3,0) = 2, SUB(3,5,0) = 254 with borrow=1
                const int borrow = (a - cin) < b ? 1 : 0;
                c = P2_8 * borrow + a - cin - b;
                cout = plast ? 0 : borrow;

                if (plast) {
                    c_is_signed = (c & SIGN_BYTE) ? 1 : 0;
                }

            case 0x0e,0x0f: // LEU,LE: Less than or equal comparison
                // Returns 1 if a <= b, 0 otherwise. LEU for unsigned, LE for signed.
                // Example: LEU(3,5) = 1, LE(-1,3) = 1, LEU(5,3) = 0, LEU(3,3) = 1
                if (a < b) {
                    cout = 0;
                } else if (a == b) {
                    cout = cin;
                } else {
                    cout = 1;
                }

                c = 0;

                if (plast) {
                    cout = 1 - cout;

                    // If the chunk is signed, then the result is the sign of a
                    if (op == 0x0f && (a & SIGN_BYTE) != (b & SIGN_BYTE)) {
                        cout = (a & SIGN_BYTE) ? 1 : 0;
                    }
                }

            case 0x10: // AND: Bitwise AND
                // Performs bitwise AND operation: a & b
                // Example: AND(0b1100, 0b1010) = 0b1000 = 8
                c = a & b;

            case 0x11: // OR: Bitwise OR
                // Performs bitwise OR operation: a | b
                // Example: OR(0b1100, 0b1010) = 0b1110 = 14
                c = a | b;

            case 0x12: // XOR: Bitwise XOR
                // Performs bitwise XOR operation: a ^ b
                // Example: XOR(0b1100, 0b1010) = 0b0110 = 6
                c = a ^ b;

            case 0x13: // SEXT_00: Sign extension with 0
                // Example: SEXT_00(a) = 0x00
                cout = cin;
                c = 0x00;

                result_is_a = relative_index >= P2_17 ? 1 : 0;
                c_is_signed = 0;

            case 0x14: // SEXT_FF: Sign extension with 1
                // Example: SEXT_FF(a) = 0xFF
                cout = cin;
                c = 0xFF;

                result_is_a = relative_index >= P2_17 ? 1 : 0;
                c_is_signed = 1;

            default:
                error(`Invalid operation opcode: ${op} at row ${i}`);
        }

        C[i] = c;
        const int flags = cout + 2*result_is_a + 4*use_first_byte + 8*c_is_signed;
        FLAGS[i] = flags;
        log(`T[${i}] = [${pos_ind}, ${op}, ${a}, ${b}, ${cin}, ${c}, ${flags}]`);
    }

    col witness multiplicity;
    lookup_proves(BINARY_TABLE_ID, [POS_IND, OP, A, B, CIN, C, FLAGS], multiplicity);
}