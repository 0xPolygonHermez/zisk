require "std_constants.pil";
require "std_lookup.pil"

/* PIL Binary Operations Table used by Binary
                                                                                                            Running Total
    MINU       (OP:0x02)       2^8 (A) x 2^8 (B) x 2^1 (POS_IND) x 2^1 (CIN) x 2^1 (RESULT_IS_A)     = 2^19 |                     2^19
    MIN        (OP:0x03)       2^8 (A) x 2^8 (B) x 2^1 (POS_IND) x 2^1 (CIN) x 2^1 (RESULT_IS_A)     = 2^19 |              2^20
    MAXU       (OP:0x04)       2^8 (A) x 2^8 (B) x 2^1 (POS_IND) x 2^1 (CIN) x 2^1 (RESULT_IS_A)     = 2^19 |              2^20 + 2^19
    MAX        (OP:0x05)       2^8 (A) x 2^8 (B) x 2^1 (POS_IND) x 2^1 (CIN) x 2^1 (RESULT_IS_A)     = 2^19 |       2^21
    LT_ABS_NP  (OP:0x06)   *   2^8 (A) x 2^8 (B) x 2^2 (POS_IND) x 2^1 (CIN)                         = 2^19 |       2^21        + 2^19
    LT_ABS_PN  (OP:0x07)   *   2^8 (A) x 2^8 (B) x 2^2 (POS_IND) x 2^1 (CIN)                         = 2^19 |       2^21 + 2^20
    LTU        (OP:0x08)   *   2^8 (A) x 2^8 (B) x 2^1 (POS_IND) x 2^1 (CIN)                         = 2^18 |       2^21 + 2^20        + 2^18
    LT         (OP:0x09)   *   2^8 (A) x 2^8 (B) x 2^1 (POS_IND) x 2^1 (CIN)                         = 2^18 |       2^21 + 2^20 + 2^19
    GT         (OP:0x0a)   *   2^8 (A) x 2^8 (B) x 2^1 (POS_IND) x 2^1 (CIN)                         = 2^18 |       2^21 + 2^20 + 2^19 + 2^18
    EQ         (OP:0x0b)   *   2^8 (A) x 2^8 (B) x 2^1 (POS_IND) x 2^1 (CIN)                         = 2^18 | 2^22
    ADD        (OP:0x0c)       2^8 (A) x 2^8 (B) x 2^1 (POS_IND) x 2^1 (CIN)                         = 2^18 | 2^22                     + 2^18
    SUB        (OP:0x0d)       2^8 (A) x 2^8 (B) x 2^1 (POS_IND) x 2^1 (CIN)                         = 2^18 | 2^22              + 2^19
    LEU        (OP:0x0e)   *   2^8 (A) x 2^8 (B) x 2^1 (POS_IND) x 2^1 (CIN)                         = 2^18 | 2^22              + 2^19 + 2^18
    LE         (OP:0x0f)   *   2^8 (A) x 2^8 (B) x 2^1 (POS_IND) x 2^1 (CIN)                         = 2^18 | 2^22       + 2^20
    AND        (OP:0x10)   **  2^8 (A) x 2^8 (B) x 2^1 (POS_IND)                                     = 2^17 | 2^22       + 2^20               + 2^17
    OR         (OP:0x11)   **  2^8 (A) x 2^8 (B) x 2^1 (POS_IND)                                     = 2^17 | 2^22       + 2^20        + 2^18
    XOR        (OP:0x12)   **  2^8 (A) x 2^8 (B) x 2^1 (POS_IND)                                     = 2^17 | 2^22       + 2^20        + 2^18 + 2^17
    SEXT       (OP:0x13)   *** 2^8 (A)                           x 2^1 (CIN) x 2^2 (FLAGS)           = 2^11 | 2^22       + 2^20        + 2^18 + 2^17 + 2^11 => < 2^23
    --------------------------------------------------------------------------------------------------------------------------
    (*)   Uses the carry of the last byte as its result
    (**)  Do not uses POS_IND in its operation, but the binary does so we need to consider it
    (***) Do not uses CIN, but we add it to simplify the FLAGS column
    Note: SEXT is the only (unary) operation which is not a ZisK OP but it is used to prove the rest
*/

const int BINARY_TABLE_ID = 125;
const int SEXT_OP = 0x13;

airtemplate BinaryTable(const int N = 2**23) {
    if (N < 2**23) {
        error(`N must be at least 2^23, but N=${N} was provided`);
    }

    // Input A (8 bits)
    col fixed A = [0..255]...;                          

    // Input B (8 bits)
    col fixed B = [[0:P2_8..255:P2_8]:86, // 86 = 4*8 + 2*8 + 4*4 + 2*4 + 2*4 + 3*2
                    0:P2_11]...;          // B is 0 for SEXT

    // Indicator of the byte position (<=2 bits)
    col fixed POS_IND = [[0:P2_16, 1:P2_16]:(4*4),          // MINU,MIN,MAXU,MAX
                         [0:P2_16..2:P2_16, 2:P2_16]:(2*2), // LT_ABS_NP,LT_ABS_PN
                         [0:P2_16, 1:P2_16]:(4*2),          // LTU,LT,GT,EQ
                         [0:P2_16, 1:P2_16]:(2*2),          // ADD,SUB
                         [0:P2_16, 1:P2_16]:(2*2),          // LEU,LE
                         [0:P2_16, 1:P2_16]:3,              // AND,OR,XOR
                          0:P2_11]...;

    // Input carry (1 bit)
    col fixed CIN = [[0:P2_17, 1:P2_17]:(4*2), // MINU,MIN,MAXU,MAX
                     [0:P2_18, 1:P2_18]:2,     // LT_ABS_NP,LT_ABS_PN
                     [0:P2_17, 1:P2_17]:4,     // LTU,LT,GT,EQ
                     [0:P2_17, 1:P2_17]:2,     // ADD,SUB
                     [0:P2_17, 1:P2_17]:2,     // LEU,LE
                      0:(P2_17*3),             // AND,OR,XOR
                     [0:P2_8, 1:P2_8]:4]...;   // SEXT

    // Operation opcode (fixed values)
    col fixed OP = [0x02:P2_19, 0x03:P2_19, 0x04:P2_19, 0x05:P2_19, // MINU,MIN,MAXU,MAX
                    0x06:P2_19, 0x07:P2_19,                         // LT_ABS_NP,LT_ABS_PN
                    0x08:P2_18, 0x09:P2_18, 0x0a:P2_18, 0x0b:P2_18, // LTU,LT,GT,EQ
                    0x0c:P2_18, 0x0d:P2_18,                         // ADD,SUB
                    0x0e:P2_18, 0x0f:P2_18,                         // LEU,LE
                    0x10:P2_17, 0x11:P2_17, 0x12:P2_17,             // AND,OR,XOR
                    0x13:P2_11]...;                                 // SEXT

    const int TABLE_SIZE = P2_19 * 6 + P2_18 * 8 + P2_17 * 3 + P2_11;
    const int TABLE_BASE_EXT32 = P2_16 * 86;

    col fixed C;             // Output C (8 bits)
    col fixed FLAGS;         // Combined flags (8 bits)

    #pragma transpile logfile:/tmp/binary_table.txt
    for (int i = 0; i < N; i++) {
        const int [pos_ind, op, a, b, cin] = [POS_IND[i], OP[i], A[i], B[i], CIN[i]];
        const int pfirst = (pos_ind == 2) ? 1 : 0;
        const int plast = (pos_ind == 1) ? 1 : 0;
        int c = 0;
        int cout = 0;
        int op_is_min_max = 0;
        int first_byte = 0;
        int use_last_carry = 0;
        int index = i % TABLE_SIZE;
        int result_is_a = index < P2_21 ? ((index >> 18) & 0x01) : 0;
        switch (op) {
            case 0x02,0x03: // MINU,MIN: Minimum operation
                // Returns min(a,b). MINU for unsigned, MIN for signed.
                // Example: MINU(5,3) = 3, MIN(-1,3) = -1
                if (a < b) {
                    cout = 1;
                } else if (a == b) {
                    cout = cin;
                }

                if (result_is_a) {
                    c = a;
                } else {
                    c = b;
                }

                if (op == 0x03 && plast && (a & 0x80) != (b & 0x80)) {
                    cout = (a & 0x80) ? 1 : 0;
                }

            case 0x04,0x05: // MAXU,MAX: Maximum operation
                // Returns max(a,b). MAXU for unsigned, MAX for signed.
                // Example: MAXU(5,3) = 5, MAX(-1,3) = 3
                if (a > b) {
                    cout = 1;
                } else if (a == b) {
                    cout = cin;
                }

                if (result_is_a) {
                    c = a;
                } else {
                    c = b;
                }

                if (op == 0x05 && plast && (a & 0x80) != (b & 0x80)) {
                    cout = (a & 0x80) ? 0 : 1;
                }

            case 0x06: // LT_ABS_NP: Absolute value comparison |a| < |b| where a < 0 and b > 0
                // Compares absolute values when a is negative and b is positive
                // Example: LT_ABS_NP(-3, 5) = 1 (|-3| < |5|), LT_ABS_NP(-7, 5) = 0 (|-7| > |5|)
                const int _a = a ^ 0xFF;
                const int _b = b;
                const int sub = pfirst ? (_a + 1) - _b : _a - _b;

                if (sub < 0) {
                    cout = 1;
                    c = plast;
                } else if (sub == 0) {
                    cout = cin;
                    c = plast * cin;
                }

                first_byte = 1;
                use_last_carry = plast;

            case 0x07: // LT_ABS_PN: Absolute value comparison |a| < |b| where a > 0 and b < 0
                // Compares absolute values when a is positive and b is negative
                // Example: LT_ABS_PN(3, -5) = 1 (|3| < |-5|), LT_ABS_PN(7, -5) = 0 (|7| > |-5|)
                const int _a = a;
                const int _b = b ^ 0xFF;
                const int sub = pfirst ? _a - (_b + 1) : _a - _b;

                if (sub < 0) {
                    cout = 1;
                    c = plast;
                } else if (sub == 0) {
                    cout = cin;
                    c = plast * cin;
                }

                first_byte = 1;
                use_last_carry = plast;

            case 0x08,0x09: // LTU,LT: Less than comparison
                // Returns 1 if a < b, 0 otherwise. LTU for unsigned, LT for signed.
                // Example: LTU(3,5) = 1, LT(-1,3) = 1, LTU(5,3) = 0
                if (a < b) {
                    cout = 1;
                    c = plast;
                } else if (a == b) {
                    cout = cin;
                    c = plast * cin;
                }

                // If the chunk is signed, then the result is the sign of a
                if (op == 0x09 && plast && (a & 0x80) != (b & 0x80)) {
                    c = (a & 0x80) ? 1 : 0;
                    cout = c;
                }

                use_last_carry = plast;

            case 0x0a: // GT: Greater than comparison (signed)
                // Returns 1 if a > b, 0 otherwise (signed comparison)
                // Example: GT(5,3) = 1, GT(-1,3) = 0, GT(3,3) = 0
                if (a > b) {
                    cout = 1;
                    c = plast;
                } else if (a == b) {
                    cout = cin;
                    c = plast * cin;
                }

                // The result is the sign of b
                if (plast && (a & 0x80) != (b & 0x80)) {
                    c = (b & 0x80) ? 1 : 0;
                    cout = c;
                }

                use_last_carry = plast;

            case 0x0b: // EQ: Equality comparison
                // Returns 1 if a == b, 0 otherwise
                // Example: EQ(5,5) = 1, EQ(3,5) = 0
                if (a == b && !cin) {
                    c = plast;
                } else {
                    cout = 1;
                }

                if (plast) {
                    cout = 1 - cout;
                }

                use_last_carry = plast;

            case 0x0c: // ADD: Addition with carry
                // Performs a + b + cin
                // Example: ADD(5,3,0) = 8, ADD(255,1,0) = 0
                c = (cin + a + b) & 0xFF;
                cout = plast ? 0 : (cin + a + b) >> 8;

            case 0x0d: // SUB: Subtraction with borrow
                // Performs a - b - cin (where cin is borrow)
                // Example: SUB(5,3,0) = 2, SUB(3,5,0) = 254 with borrow=1
                sign = (a - cin) >= b ? 0 : 1;
                c = 256 * sign + a - cin - b;
                cout = plast ? 0 : sign;

            case 0x0e,0x0f: // LEU,LE: Less than or equal comparison
                // Returns 1 if a <= b, 0 otherwise. LEU for unsigned, LE for signed.
                // Example: LEU(3,5) = 1, LE(-1,3) = 1, LEU(5,3) = 0, LEU(3,3) = 1
                if (a < b) {
                    c = plast;
                } else if (a == b) {
                    c = plast * (1 - cin);
                    cout = cin;
                } else {
                    cout = 1;
                }

                if (plast) {
                    cout = 1 - cout;
                }

                use_last_carry = plast;

            case 0x10: // AND: Bitwise AND
                // Performs bitwise AND operation: a & b
                // Example: AND(0b1100, 0b1010) = 0b1000 = 8
                c = a & b;

            case 0x11: // OR: Bitwise OR
                // Performs bitwise OR operation: a | b
                // Example: OR(0b1100, 0b1010) = 0b1110 = 14
                c = a | b;

            case 0x12: // XOR: Bitwise XOR
                // Performs bitwise XOR operation: a ^ b
                // Example: XOR(0b1100, 0b1010) = 0b0110 = 6
                c = a ^ b;

            case 0x13: // SEXT: Sign extension
                // Extends sign bit (bit 7) to all 8 bits of output
                // Example: SEXT(0x80) = 0xFF, SEXT(0x7F) = 0x00
                c = (a & 0x80) ? 0xFF : 0x00;
                const int index_offset = (index - TABLE_BASE_EXT32) >> 9;
                result_is_a = index_offset & 0x01;
                if ((index_offset & 0x03) == 0x03) {
                    first_byte = 1;
                } else {
                    first_byte = 0;
                }

            default:
                error(`Invalid operation opcode: ${op} at row ${i}`);
        }

        C[i] = c;
        const int flags = cout + 2*result_is_a + 4*first_byte + 8*use_last_carry;
        FLAGS[i] = flags;
        log(`T[${i}] = [${pos_ind}, ${op}, ${a}, ${b}, ${cin}, ${c}, ${flags}]`);
    }

    col witness multiplicity;
    lookup_proves(BINARY_TABLE_ID, [POS_IND, OP, A, B, CIN, C, FLAGS], multiplicity);
}