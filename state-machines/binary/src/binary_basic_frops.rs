use static_assertions::const_assert;
use std::error::Error;
use zisk_core::zisk_ops::ZiskOp;

use sm_frequent_ops::FrequentOpsHelpers;

const OP_ADD: u8 = ZiskOp::Add.code();
const OP_ADDW: u8 = ZiskOp::AddW.code();
const OP_SUB: u8 = ZiskOp::Sub.code();
const OP_SUBW: u8 = ZiskOp::SubW.code();
const OP_EQ: u8 = ZiskOp::Eq.code();
const OP_EQW: u8 = ZiskOp::EqW.code();
const OP_LTU: u8 = ZiskOp::Ltu.code();
const OP_LT: u8 = ZiskOp::Lt.code();
const OP_LTUW: u8 = ZiskOp::LtuW.code();
const OP_LTW: u8 = ZiskOp::LtW.code();
const OP_LEU: u8 = ZiskOp::Leu.code();
const OP_LE: u8 = ZiskOp::Le.code();
const OP_LEUW: u8 = ZiskOp::LeuW.code();
const OP_LEW: u8 = ZiskOp::LeW.code();
const OP_AND: u8 = ZiskOp::And.code();
const OP_OR: u8 = ZiskOp::Or.code();
const OP_XOR: u8 = ZiskOp::Xor.code();

const LOW_VALUES_OPCODES: [u8; 17] = [
    OP_ADD, OP_ADDW, OP_SUB, OP_SUBW, OP_EQ, OP_EQW, OP_LTU, OP_LT, OP_LTUW, OP_LTW, OP_LEU, OP_LE,
    OP_LEUW, OP_LEW, OP_AND, OP_OR, OP_XOR,
];

const MAX_A_LOW_VALUE: u64 = 386;
const MAX_B_LOW_VALUE: u64 = 386;
const LOW_VALUE_SIZE: usize = (MAX_A_LOW_VALUE * MAX_B_LOW_VALUE) as usize;
const MINUS_ONE: u64 = -1i64 as u64;
const MAX_U64: u64 = 0xFFFF_FFFF_FFFF_FFFF;
const EQ_OP_B_ZERO_A_LIMIT: u64 = 0xFFFFF;
const LTU_OP_B_LT_ONE_FROM: u64 = -128i64 as u64;

// LT

const LT_FROM_ADDR: u64 = 0xA010_0000;
const LT_TO_ADDR: u64 = 0xA012_0000;
const LT_DELTA: u64 = 8;
const LT_LOW_DISTANCE_1: u64 = 16; // 0 - 15
const LT_HIGH_DISTANCE_8: u64 = 240; // 16,24,32,40,.....
const LT_LOW_HIGH_DISTANCES: u64 = LT_LOW_DISTANCE_1 + LT_HIGH_DISTANCE_8;
const LT_MAX_DISTANCE: u64 = LT_LOW_DISTANCE_1 + (LT_HIGH_DISTANCE_8 - 1) * 8;
const LT_FROM_TO_SIZE: usize = ((LT_TO_ADDR - LT_FROM_ADDR) / LT_DELTA) as usize;
const LT_ALL_FROM_TO_SIZE: usize = LT_FROM_TO_SIZE * LT_LOW_HIGH_DISTANCES as usize;

const LT_ZERO_TO_B: u64 = 0x10000;

// ADD
const MAX_ADD_MINUS_ONE: u64 = 24628;
const MAX_ADD_MINUS_A: u64 = 1024;
const MAX_ADD_MINUS_B: u64 = 8;
const ADD_ONE_FROM_ADDR: u64 = 0xA010_0000; // address
const ADD_ONE_TO_ADDR: u64 = 0xA020_0000;
const ADD_EIGHT_FROM_ADDR: u64 = 0xA010_0000; // address
const ADD_EIGHT_TO_ADDR: u64 = 0xA020_0000;
const ADD_EIGHT_FROM_CODE: u64 = 0x8000_0000; // address
const ADD_EIGHT_TO_CODE: u64 = 0x8080_0000;
const ADD_EIGHT_STEP: u64 = 8;

const ADD_ZERO_FROM_ADDR: u64 = 0xA010_0000; // address
const ADD_ZERO_TO_ADDR: u64 = 0xA020_0000;
const ADD_ZERO_STEP: u64 = 8;

const ADD_MINUS_ONE_SIZE: usize = MAX_ADD_MINUS_ONE as usize;
const ADD_MINUS_A_B_SIZE: usize = (MAX_ADD_MINUS_A * MAX_ADD_MINUS_B) as usize;
const ADD_MINUS_A_B_FROM_B: u64 = MINUS_ONE - MAX_ADD_MINUS_B;

const ADD_ONE_ADDR_SIZE: usize = (ADD_ONE_TO_ADDR - ADD_ONE_FROM_ADDR) as usize;
const ADD_EIGHT_ADDR_SIZE: usize =
    ((ADD_EIGHT_TO_ADDR - ADD_EIGHT_FROM_ADDR) / ADD_EIGHT_STEP) as usize;
const ADD_EIGHT_CODE_SIZE: usize =
    ((ADD_EIGHT_TO_CODE - ADD_EIGHT_FROM_CODE) / ADD_EIGHT_STEP) as usize;
const ADD_ZERO_ADDR_SIZE: usize =
    ((ADD_ZERO_TO_ADDR - ADD_ZERO_FROM_ADDR) / ADD_ZERO_STEP) as usize;

const ADD_MINUS_ONE_OFFSET: usize = LOW_VALUE_SIZE;
const ADD_MINUS_A_B_OFFSET: usize = ADD_MINUS_ONE_OFFSET + ADD_MINUS_ONE_SIZE;
const ADD_ONE_ADDR_OFFSET: usize = ADD_MINUS_A_B_OFFSET + ADD_MINUS_A_B_SIZE;
const ADD_EIGHT_ADDR_OFFSET: usize = ADD_ONE_ADDR_OFFSET + ADD_ONE_ADDR_SIZE;
const ADD_EIGHT_CODE_OFFSET: usize = ADD_EIGHT_ADDR_OFFSET + ADD_EIGHT_ADDR_SIZE;
const ADD_ZERO_ADDR_OFFSET: usize = ADD_EIGHT_CODE_OFFSET + ADD_EIGHT_CODE_SIZE;

// AND
const AND_CODE_ADDR_FROM: u64 = 0x8000_0000;
const AND_CODE_ADDR_TO: u64 = 0x8090_0000; // address
const AND_CODE_ADDR_STEP: u64 = 4;
const AND_CODE_ADDR_MASK: u64 = 0xFFFF_FFFF_FFFF_FFFC;

const AND_RESET_LAST_THREE_BITS_B: u64 = 0xFFFF_FFFF_FFFF_FFF8;
const AND_RESET_LAST_THREE_BITS_A_TO: u64 = 1024;
const AND_GET_LAST_THREE_BITS_B: u64 = 0x7;
const AND_GET_LAST_THREE_BITS_FROM: u64 = 0xA010_0000;
const AND_GET_LAST_THREE_BITS_TO: u64 = 0xA020_0000;
const AND_GET_LAST_THREE_BITS_STEP: u64 = 8;

const AND_CODE_ADDR_OFFSET: usize = LOW_VALUE_SIZE;
const AND_CODE_ADDR_SIZE: usize =
    ((AND_CODE_ADDR_TO - AND_CODE_ADDR_FROM) / AND_CODE_ADDR_STEP) as usize;

const AND_RESET_LAST_THREE_BITS_OFFSET: usize = AND_CODE_ADDR_OFFSET + AND_CODE_ADDR_SIZE;
const AND_RESET_LAST_THREE_BITS_SIZE: usize = AND_RESET_LAST_THREE_BITS_A_TO as usize;

const AND_GET_LAST_THREE_BITS_OFFSET: usize =
    AND_RESET_LAST_THREE_BITS_OFFSET + AND_RESET_LAST_THREE_BITS_SIZE;
const AND_GET_LAST_THREE_BITS_SIZE: usize = ((AND_GET_LAST_THREE_BITS_TO
    - AND_GET_LAST_THREE_BITS_FROM)
    / AND_GET_LAST_THREE_BITS_STEP) as usize;

const OR_TO_A: u64 = 0x1000;
const OR_TO_B: u64 = 16;

const SUB_W_ADDR_FROM: u64 = 0xA010_0000;
const SUB_W_ADDR_TO: u64 = 0xA020_0000;
const SUB_W_ADDR_STEP: u64 = 4;

const SUB_TO_A: u64 = 4192;
const SUB_TO_B: u64 = 8;

// table autogenerated with FrequentOpsTable::print_table_offsets()
// this table is used to calculate the offset (row) of each operation
const OP_TABLE_OFFSETS_START: usize = 8;
const OP_TABLE_OFFSETS: [usize; 40] = [
    0, 149124, 0, 4557574, 5755146, 8296258, 8479508, 8628504, 8777500, 11417888, 11629954, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 11778952, 11927948, 0, 12076944,
    12225940, 12374936, 12786076, 12935072,
];

#[derive(Debug, Clone)]
pub struct BinaryBasicFrops {
    table: FrequentOpsHelpers,
}

const FREQUENT_OP_EMPTY: usize = 256;

impl Default for BinaryBasicFrops {
    fn default() -> Self {
        Self::new()
    }
}
impl BinaryBasicFrops {
    pub const TABLE_ID: usize = 5011;
    pub const NO_FROPS: usize = FrequentOpsHelpers::NO_FROPS;
    pub fn new() -> Self {
        Self { table: FrequentOpsHelpers::new() }
    }
    fn build_low_values_operations(&mut self) {
        let mut ops = self.table.get_low_values_operations(MAX_A_LOW_VALUE, MAX_B_LOW_VALUE);
        for op in LOW_VALUES_OPCODES.iter() {
            self.table.add_ops(*op, &mut ops, false);
        }
    }

    // EQ

    fn build_eq_zero(&mut self) {
        let mut ops: Vec<[u64; 2]> = Vec::new();
        for i in 0..=EQ_OP_B_ZERO_A_LIMIT {
            ops.push([i, 0]);
        }
        self.table.add_ops(OP_EQ, &mut ops, true);
    }

    #[inline(always)]
    fn get_eq_offset(a: u64, b: u64) -> usize {
        if b == 0 && a <= EQ_OP_B_ZERO_A_LIMIT {
            LOW_VALUE_SIZE + a as usize
        } else if b < MAX_B_LOW_VALUE && a < MAX_A_LOW_VALUE {
            Self::get_low_values_offset(a, b)
        } else {
            Self::NO_FROPS
        }
    }

    // LTU

    fn build_ltu_one(&mut self) {
        let mut ops: Vec<[u64; 2]> = Vec::new();
        for i in LTU_OP_B_LT_ONE_FROM..=MAX_U64 {
            ops.push([i, 1]);
        }
        self.table.add_ops(OP_LTU, &mut ops, true);
    }

    #[inline(always)]
    fn get_ltu_offset(a: u64, b: u64) -> usize {
        if b == 1 {
            if a >= LTU_OP_B_LT_ONE_FROM {
                LOW_VALUE_SIZE + (a - LTU_OP_B_LT_ONE_FROM) as usize
            } else if a < MAX_A_LOW_VALUE {
                Self::get_low_values_offset(a, 1)
            } else {
                Self::NO_FROPS
            }
        } else if b < MAX_B_LOW_VALUE && a < MAX_A_LOW_VALUE {
            Self::get_low_values_offset(a, b)
        } else {
            Self::NO_FROPS
        }
    }

    // LT

    fn build_lt(&mut self) {
        let mut ops: Vec<[u64; 2]> = Vec::new();
        let mut i = LT_FROM_ADDR;
        while i < LT_TO_ADDR {
            for j in 0..LT_LOW_DISTANCE_1 {
                ops.push([i - j, i]);
            }
            for j in 0..LT_HIGH_DISTANCE_8 {
                ops.push([i - j * 8 - 16, i]);
            }
            i += LT_DELTA;
        }
        for i in MAX_B_LOW_VALUE..LT_ZERO_TO_B {
            ops.push([0, i]);
        }
        self.table.add_ops(OP_LT, &mut ops, true);
    }

    #[inline(always)]
    fn is_frequent_lt(a: u64, b: u64) -> bool {
        if a < MAX_A_LOW_VALUE && b < MAX_B_LOW_VALUE {
            true
        } else if a <= b && b & 0xFFFF_FFFF_FFFE_0007 == 0xA010_0000 {
            // 256 / 8 = 32 (5 bits)
            let dist = b - a;
            if dist < LT_LOW_DISTANCE_1 {
                true
            } else if dist <= LT_MAX_DISTANCE && dist & 0x7 == 0 {
                // 16 - dist >> 3 - 2 = 14 - dist >> 3
                true
            } else {
                false
            }
        } else {
            a == 0 && b < LT_ZERO_TO_B
        }
    }

    #[inline(always)]
    fn get_lt_offset(a: u64, b: u64) -> usize {
        const_assert!(LT_DELTA == 8);
        const_assert!(LT_FROM_ADDR == 0xA010_0000);
        const_assert!(LT_TO_ADDR == 0xA012_0000);

        if a < MAX_A_LOW_VALUE && b < MAX_B_LOW_VALUE {
            Self::get_low_values_offset(a, b)
        // TODO_ASSERT
        } else if a <= b && (b & 0xFFFF_FFFF_FFFE_0007) == 0xA010_0000 {
            // 256 / 8 = 32 (5 bits)
            let addr_offset = ((b - LT_FROM_ADDR) >> 3) * LT_LOW_HIGH_DISTANCES;
            let dist = b - a;
            if dist < LT_LOW_DISTANCE_1 {
                LOW_VALUE_SIZE + (addr_offset + dist) as usize
            } else if dist <= LT_MAX_DISTANCE && dist & 0x7 == 0 {
                // 16 - dist >> 3 - 2 = 14 - dist >> 3
                LOW_VALUE_SIZE + (addr_offset + LT_LOW_DISTANCE_1 + ((dist - 16) >> 3)) as usize
            } else {
                Self::NO_FROPS
            }
        } else if a == 0 && b < LT_ZERO_TO_B {
            // in this point B >= MAX_B_LOW_VALUE
            LOW_VALUE_SIZE + LT_ALL_FROM_TO_SIZE + (b - MAX_B_LOW_VALUE) as usize
        } else {
            Self::NO_FROPS
        }
    }

    // ADD

    fn build_add(&mut self) {
        let mut ops: Vec<[u64; 2]> = Vec::new();
        for i in 0..MAX_ADD_MINUS_ONE {
            ops.push([i, MINUS_ONE]);
        }
        assert_eq!(ADD_MINUS_ONE_SIZE, ops.len());

        assert_eq!(ADD_MINUS_A_B_OFFSET, LOW_VALUE_SIZE + ops.len());
        for i in 0..MAX_ADD_MINUS_A {
            for j in 1..=MAX_ADD_MINUS_B {
                ops.push([i, MAX_U64 - j]);
            }
        }
        assert_eq!((ADD_MINUS_A_B_OFFSET + ADD_MINUS_A_B_SIZE), LOW_VALUE_SIZE + ops.len());
        // address + 1

        assert_eq!(ADD_ONE_ADDR_OFFSET, LOW_VALUE_SIZE + ops.len());
        for i in ADD_ONE_FROM_ADDR..ADD_ONE_TO_ADDR {
            ops.push([i, 1]);
        }
        assert_eq!((ADD_ONE_ADDR_OFFSET + ADD_ONE_ADDR_SIZE), LOW_VALUE_SIZE + ops.len());

        assert_eq!(ADD_EIGHT_ADDR_OFFSET, LOW_VALUE_SIZE + ops.len());
        for i in (ADD_EIGHT_FROM_ADDR..ADD_EIGHT_TO_ADDR).step_by(ADD_EIGHT_STEP as usize) {
            ops.push([i, 8]);
        }
        assert_eq!((ADD_EIGHT_ADDR_OFFSET + ADD_EIGHT_ADDR_SIZE), LOW_VALUE_SIZE + ops.len());

        assert_eq!(ADD_EIGHT_CODE_OFFSET, LOW_VALUE_SIZE + ops.len());
        for i in (ADD_EIGHT_FROM_CODE..ADD_EIGHT_TO_CODE).step_by(ADD_EIGHT_STEP as usize) {
            ops.push([i, 8]);
        }
        assert_eq!((ADD_EIGHT_CODE_OFFSET + ADD_EIGHT_CODE_SIZE), LOW_VALUE_SIZE + ops.len());

        assert_eq!(ADD_ZERO_ADDR_OFFSET, LOW_VALUE_SIZE + ops.len());
        for i in (ADD_ZERO_FROM_ADDR..ADD_ZERO_TO_ADDR).step_by(ADD_ZERO_STEP as usize) {
            ops.push([i, 0]);
        }
        assert_eq!((ADD_ZERO_ADDR_OFFSET + ADD_ZERO_ADDR_SIZE), LOW_VALUE_SIZE + ops.len());

        self.table.add_ops(OP_ADD, &mut ops, true);
    }

    #[inline(always)]
    fn get_add_offset(a: u64, b: u64) -> usize {
        const_assert!(ADD_ZERO_STEP == 8);
        if b < MAX_B_LOW_VALUE {
            if a < MAX_A_LOW_VALUE {
                Self::get_low_values_offset(a, b)
            } else {
                match b {
                    0 => {
                        if (ADD_ZERO_FROM_ADDR..ADD_ZERO_TO_ADDR).contains(&a) && a & 0x7 == 0 {
                            ADD_ZERO_ADDR_OFFSET + ((a - ADD_ZERO_FROM_ADDR) >> 3) as usize
                        } else {
                            Self::NO_FROPS
                        }
                    }
                    1 => {
                        if (ADD_ONE_FROM_ADDR..ADD_ONE_TO_ADDR).contains(&a) {
                            ADD_ONE_ADDR_OFFSET + (a - ADD_ONE_FROM_ADDR) as usize
                        } else {
                            Self::NO_FROPS
                        }
                    }
                    8 => {
                        if a & 0x7 == 0 {
                            if (ADD_EIGHT_FROM_ADDR..ADD_EIGHT_TO_ADDR).contains(&a) {
                                ADD_EIGHT_ADDR_OFFSET + ((a - ADD_EIGHT_FROM_ADDR) >> 3) as usize
                            } else if (ADD_EIGHT_FROM_CODE..ADD_EIGHT_TO_CODE).contains(&a) {
                                ADD_EIGHT_CODE_OFFSET + ((a - ADD_EIGHT_FROM_CODE) >> 3) as usize
                            } else {
                                Self::NO_FROPS
                            }
                        } else {
                            Self::NO_FROPS
                        }
                    }
                    _ => Self::NO_FROPS,
                }
            }
        } else if b == MINUS_ONE {
            if a < MAX_ADD_MINUS_ONE {
                ADD_MINUS_ONE_OFFSET + a as usize
            } else {
                Self::NO_FROPS
            }
        } else if b >= ADD_MINUS_A_B_FROM_B && a < MAX_ADD_MINUS_A {
            ADD_MINUS_A_B_OFFSET + (a * MAX_ADD_MINUS_B + (MAX_U64 - 1 - b)) as usize
        } else {
            Self::NO_FROPS
        }
    }

    // AND

    fn build_and(&mut self) {
        let mut ops: Vec<[u64; 2]> = Vec::new();
        assert_eq!(AND_CODE_ADDR_OFFSET, LOW_VALUE_SIZE + ops.len());
        for i in (AND_CODE_ADDR_FROM..AND_CODE_ADDR_TO).step_by(AND_CODE_ADDR_STEP as usize) {
            ops.push([AND_CODE_ADDR_MASK, i]);
        }
        assert_eq!(AND_CODE_ADDR_OFFSET + AND_CODE_ADDR_SIZE, LOW_VALUE_SIZE + ops.len());

        assert_eq!(AND_RESET_LAST_THREE_BITS_OFFSET, LOW_VALUE_SIZE + ops.len());
        for i in 0..AND_RESET_LAST_THREE_BITS_A_TO {
            ops.push([i, AND_RESET_LAST_THREE_BITS_B]);
        }
        assert_eq!(
            (AND_RESET_LAST_THREE_BITS_OFFSET + AND_RESET_LAST_THREE_BITS_SIZE),
            LOW_VALUE_SIZE + ops.len()
        );

        assert_eq!(AND_GET_LAST_THREE_BITS_OFFSET, LOW_VALUE_SIZE + ops.len());
        for i in (AND_GET_LAST_THREE_BITS_FROM..AND_GET_LAST_THREE_BITS_TO)
            .step_by(AND_GET_LAST_THREE_BITS_STEP as usize)
        {
            ops.push([i, AND_GET_LAST_THREE_BITS_B]);
        }
        assert_eq!(
            (AND_GET_LAST_THREE_BITS_OFFSET + AND_GET_LAST_THREE_BITS_SIZE),
            LOW_VALUE_SIZE + ops.len()
        );
        self.table.add_ops(OP_AND, &mut ops, true);
    }

    #[inline(always)]
    fn get_and_offset(a: u64, b: u64) -> usize {
        if a == AND_CODE_ADDR_MASK
            && (b & 0x03) == 0
            && (AND_CODE_ADDR_FROM..AND_CODE_ADDR_TO).contains(&b)
        {
            AND_CODE_ADDR_OFFSET + ((b - AND_CODE_ADDR_FROM) >> 2) as usize
        } else if b == AND_RESET_LAST_THREE_BITS_B && a < AND_RESET_LAST_THREE_BITS_A_TO {
            AND_RESET_LAST_THREE_BITS_OFFSET + a as usize
        } else if b == AND_GET_LAST_THREE_BITS_B
            && (AND_GET_LAST_THREE_BITS_FROM..AND_GET_LAST_THREE_BITS_TO).contains(&a)
            && a & 0x7 == 0
        {
            AND_GET_LAST_THREE_BITS_OFFSET + ((a - AND_GET_LAST_THREE_BITS_FROM) >> 3) as usize
        } else if a < MAX_A_LOW_VALUE && b < MAX_B_LOW_VALUE {
            Self::get_low_values_offset(a, b)
        } else {
            Self::NO_FROPS
        }
    }

    // OR

    fn build_or(&mut self) {
        let mut ops: Vec<[u64; 2]> = Vec::new();
        for i in MAX_A_LOW_VALUE..OR_TO_A {
            for j in 0..=OR_TO_B {
                ops.push([i, j]);
            }
        }
        self.table.add_ops(OP_OR, &mut ops, true);
    }
    #[inline(always)]
    fn is_frequent_or(a: u64, b: u64) -> bool {
        (a < MAX_A_LOW_VALUE && b < MAX_B_LOW_VALUE) || (a < OR_TO_A && b <= OR_TO_B)
    }
    #[inline(always)]
    fn get_or_offset(a: u64, b: u64) -> usize {
        if a < MAX_A_LOW_VALUE && b < MAX_B_LOW_VALUE {
            Self::get_low_values_offset(a, b)
        } else if a < OR_TO_A && b <= OR_TO_B {
            LOW_VALUE_SIZE + ((a - MAX_A_LOW_VALUE) * (OR_TO_B + 1) + b) as usize
        } else {
            Self::NO_FROPS
        }
    }

    // SUB_W

    fn build_sub_w(&mut self) {
        let mut ops: Vec<[u64; 2]> = Vec::new();
        for i in (SUB_W_ADDR_FROM..SUB_W_ADDR_TO).step_by(SUB_W_ADDR_STEP as usize) {
            ops.push([0, i]);
        }
        self.table.add_ops(OP_SUBW, &mut ops, true);
    }
    #[inline(always)]
    fn is_frequent_sub_w(a: u64, b: u64) -> bool {
        (a == 0 && ((b & 0xFFFF_FFFF_FFF0_0003 == 0xA010_0000) || b < MAX_B_LOW_VALUE))
            || (a < MAX_A_LOW_VALUE && b < MAX_B_LOW_VALUE)
    }
    #[inline(always)]
    fn get_sub_w_offset(a: u64, b: u64) -> usize {
        if a == 0 {
            if b & 0xFFFF_FFFF_FFF0_0003 == 0xA010_0000 {
                LOW_VALUE_SIZE + ((b - SUB_W_ADDR_FROM) >> 2) as usize
            } else if b < MAX_B_LOW_VALUE {
                Self::get_low_values_offset(0, b)
            } else {
                Self::NO_FROPS
            }
        } else if a < MAX_A_LOW_VALUE && b < MAX_B_LOW_VALUE {
            Self::get_low_values_offset(a, b)
        } else {
            Self::NO_FROPS
        }
    }

    // BUILD_XOR

    fn build_xor(&mut self) {
        let mut ops: Vec<[u64; 2]> = Vec::new();
        ops.push([0, MAX_U64]);
        ops.push([1, MAX_U64]);
        self.table.add_ops(OP_XOR, &mut ops, true);
    }
    #[inline(always)]
    fn is_frequent_xor(a: u64, b: u64) -> bool {
        (b == MAX_U64 && a < 2) || (a < MAX_A_LOW_VALUE && b < MAX_B_LOW_VALUE)
    }
    #[inline(always)]
    fn get_xor_offset(a: u64, b: u64) -> usize {
        if b == MAX_U64 {
            if a < 2 {
                LOW_VALUE_SIZE + a as usize
            } else {
                Self::NO_FROPS
            }
        } else if a < MAX_A_LOW_VALUE && b < MAX_B_LOW_VALUE {
            Self::get_low_values_offset(a, b)
        } else {
            Self::NO_FROPS
        }
    }

    // SUB

    fn build_sub(&mut self) {
        let mut ops: Vec<[u64; 2]> = Vec::new();
        for i in MAX_A_LOW_VALUE..SUB_TO_A {
            for j in 0..=SUB_TO_B {
                ops.push([i, j]);
            }
        }
        self.table.add_ops(OP_SUB, &mut ops, true);
    }
    #[inline(always)]
    fn is_frequent_sub(a: u64, b: u64) -> bool {
        (a < MAX_A_LOW_VALUE && b < MAX_B_LOW_VALUE) || (a < SUB_TO_A && b <= SUB_TO_B)
    }
    #[inline(always)]
    fn get_sub_offset(a: u64, b: u64) -> usize {
        if a < MAX_A_LOW_VALUE && b < MAX_B_LOW_VALUE {
            Self::get_low_values_offset(a, b)
        } else if a < SUB_TO_A && b <= SUB_TO_B {
            LOW_VALUE_SIZE + ((a - MAX_A_LOW_VALUE) * (SUB_TO_B + 1) + b) as usize
        } else {
            Self::NO_FROPS
        }
    }

    pub fn build_table(&mut self) {
        self.build_low_values_operations();
        self.build_eq_zero();
        self.build_ltu_one();
        self.build_lt();
        self.build_add();
        self.build_and();
        self.build_or();
        self.build_sub_w();
        self.build_xor();
        self.build_sub();
    }

    #[inline(always)]
    fn get_low_values_offset(a: u64, b: u64) -> usize {
        (a * MAX_B_LOW_VALUE + b) as usize
    }

    #[inline(always)]
    pub fn is_frequent_op(op: u8, a: u64, b: u64) -> bool {
        // Use lookup table for faster branching instead of match on enum
        match op {
            // Low value operations - check bounds first (most common case)
            OP_ADDW | OP_EQW | OP_LTUW | OP_LTW | OP_LEU | OP_LE | OP_LEUW | OP_LEW => {
                a < MAX_A_LOW_VALUE && b < MAX_B_LOW_VALUE
            }
            // Special cases - inline the logic to avoid function calls
            OP_EQ => {
                (b == 0 && a <= EQ_OP_B_ZERO_A_LIMIT)
                    || (b < MAX_B_LOW_VALUE && a < MAX_A_LOW_VALUE)
            }
            OP_LTU => {
                (b == 1 && !(MAX_A_LOW_VALUE..LTU_OP_B_LT_ONE_FROM).contains(&a))
                    || (b < MAX_B_LOW_VALUE && a < MAX_A_LOW_VALUE)
            }
            OP_ADD => {
                // Inline is_frequent_add logic
                if b < MAX_B_LOW_VALUE {
                    if a < MAX_A_LOW_VALUE {
                        true
                    } else {
                        match b {
                            0 => {
                                (ADD_ZERO_FROM_ADDR..ADD_ZERO_TO_ADDR).contains(&a) && a & 0x7 == 0
                            }
                            1 => (ADD_ONE_FROM_ADDR..ADD_ONE_TO_ADDR).contains(&a),
                            8 => {
                                a & 0x7 == 0
                                    && ((ADD_EIGHT_FROM_ADDR..ADD_EIGHT_TO_ADDR).contains(&a)
                                        || (ADD_EIGHT_FROM_CODE..ADD_EIGHT_TO_CODE).contains(&a))
                            }
                            _ => false,
                        }
                    }
                } else if b == MINUS_ONE {
                    a < MAX_ADD_MINUS_ONE
                } else {
                    b >= ADD_MINUS_A_B_FROM_B && a < MAX_ADD_MINUS_A
                }
            }
            OP_AND => {
                // Inline is_frequent_and logic
                (a == AND_CODE_ADDR_MASK
                    && (b & 0x03) == 0
                    && (AND_CODE_ADDR_FROM..AND_CODE_ADDR_TO).contains(&b))
                    || (b == AND_RESET_LAST_THREE_BITS_B && a < AND_RESET_LAST_THREE_BITS_A_TO)
                    || (b == AND_GET_LAST_THREE_BITS_B
                        && (AND_GET_LAST_THREE_BITS_FROM..AND_GET_LAST_THREE_BITS_TO).contains(&a)
                        && a & 0x7 == 0)
                    || (a < MAX_A_LOW_VALUE && b < MAX_B_LOW_VALUE)
            }
            // Other special cases - call functions for less common operations
            OP_LT => Self::is_frequent_lt(a, b),
            OP_SUBW => Self::is_frequent_sub_w(a, b),
            OP_SUB => Self::is_frequent_sub(a, b),
            OP_OR => Self::is_frequent_or(a, b),
            OP_XOR => Self::is_frequent_xor(a, b),
            _ => false,
        }
    }

    #[inline(always)]
    pub fn get_row(op: u8, a: u64, b: u64) -> usize {
        // ecall/system call functions are not candidates to be usual
        let relative_offset = match op {
            OP_ADDW | OP_EQW | OP_LTUW | OP_LTW | OP_LEU | OP_LE | OP_LEUW | OP_LEW => {
                if a < MAX_A_LOW_VALUE && b < MAX_B_LOW_VALUE {
                    Self::get_low_values_offset(a, b)
                } else {
                    Self::NO_FROPS
                }
            }
            OP_EQ => Self::get_eq_offset(a, b),
            OP_LTU => Self::get_ltu_offset(a, b),
            OP_LT => Self::get_lt_offset(a, b),
            OP_SUBW => Self::get_sub_w_offset(a, b),
            OP_SUB => Self::get_sub_offset(a, b),
            OP_OR => Self::get_or_offset(a, b),
            OP_XOR => Self::get_xor_offset(a, b),
            OP_AND => Self::get_and_offset(a, b),
            OP_ADD => Self::get_add_offset(a, b),
            _ => Self::NO_FROPS,
        };
        if relative_offset == Self::NO_FROPS {
            Self::NO_FROPS
        } else {
            relative_offset + OP_TABLE_OFFSETS[op as usize - OP_TABLE_OFFSETS_START]
        }
    }
    #[inline(always)]
    pub fn count(&self) -> usize {
        self.table.count()
    }
    #[cfg(test)]
    pub fn test_table_offsets(&mut self) {
        self.build_table();
        let (start, offsets) = self.table.generate_table_offsets();
        if (start != OP_TABLE_OFFSETS_START) || (offsets != OP_TABLE_OFFSETS) {
            self.table.print_table_offsets();
            panic!("Table offsets do not match expected values");
        }
        assert_eq!(start, OP_TABLE_OFFSETS_START);
        assert_eq!(offsets, OP_TABLE_OFFSETS);
    }
    #[inline(always)]
    pub fn generate_full_table(&self) -> Vec<(u8, u64, u64, u64, bool)> {
        self.table.generate_full_table()
    }
    #[inline(always)]
    pub fn generate_table(&self) -> Vec<(u8, u64, u64)> {
        self.table.generate_table()
    }
    #[inline(always)]
    pub fn generate_cmd(
        &mut self,
        cmd_name: &'static str,
        default_file: &'static str,
    ) -> Result<(), Box<dyn Error>> {
        self.build_table();
        let full_table = self.generate_full_table();
        let full_table_count = full_table.len();
        self.table.generate_cmd(
            "Zisk",
            "BinaryBasicFrops",
            cmd_name,
            default_file,
            full_table,
            full_table_count,
        )
    }
}

#[test]
pub fn test_table_offsets() {
    let mut fops = BinaryBasicFrops::new();
    fops.test_table_offsets();
}
// #[test]
// fn test_frequent_ops() {
//     let mut fops = FrequentOpsTable::new();
//     fops.build_table();
//     let table = fops.generate_full_table();

//     let tests = [
//         (OP_ADD, 100, 100, true),
//         (OP_ADD, 100, -1i64 as u64, true),
//         (OP_ADD, 100000, 100000, false),
//         (OP_ADD, 100, -200000i64 as u64, false),
//         (OP_ADD, 100, -2i64 as u64, true),
//         (OP_ADD, 0xFFFF_FFFF_FFFF_FFFC, 0x8000_1000, false),
//         (OP_ADD, 0xFFFF_FFFF_FFFF_FFFC, 0xA010_1000, false),
//     ];
//     check_tests(&table, &tests);
// }

// #[test]
// fn test_all_binary_basic_accesible_values() {
//     let mut fops = FrequentOpsTable::new();
//     fops.build_table();
//     let table = fops.generate_full_table();
//     test_all_accesible_values(&table);
// }

// #[test]
// fn test_binary_basic_low_values() {
//     let mut fops = FrequentOpsTable::new();
//     fops.build_table();
//     let table = fops.generate_full_table();
//     test_low_values(&LOW_VALUES_OPCODES, &table, MAX_A_LOW_VALUE, MAX_B_LOW_VALUE);
// }

// #[cfg(test)]
// fn test_all_accesible_values(table: &[(u8, u64, u64, u64, bool)]) {
//     let tests = table.iter().map(|(op, a, b, _c, _f)| (*op, *a, *b, true)).collect::<Vec<_>>();
//     check_tests(&table, &tests);
// }

// #[cfg(test)]
// fn test_low_values(
//     opcodes: &[u8],
//     table: &[(u8, u64, u64, u64, bool)],
//     max_a_low_value: u64,
//     max_b_low_value: u64,
// ) {
//     let mut tests: Vec<(u8, u64, u64, bool)> = Vec::new();

//     for op in 0..255 {
//         let found = opcodes.contains(&op);
//         tests.push((op, 0, max_b_low_value - 1, found));
//         tests.push((op, 0, max_b_low_value - 2, found));
//         tests.push((op, 1, max_b_low_value - 1, found));
//         tests.push((op, 1, max_b_low_value - 2, found));
//         tests.push((op, max_a_low_value - 1, 0, found));
//         tests.push((op, max_a_low_value - 2, 0, found));
//         tests.push((op, max_a_low_value - 1, 1, found));
//         tests.push((op, max_a_low_value - 2, 1, found));
//         tests.push((op, max_a_low_value - 1, max_b_low_value - 1, found));
//         tests.push((op, max_a_low_value - 2, max_b_low_value - 2, found));
//         tests.push((op, max_a_low_value - 1, max_b_low_value - 2, found));
//         tests.push((max_a_low_value - 2, max_b_low_value - 1, found));
//     }
//     check_tests(&table, &tests);
// }

// #[cfg(test)]
// fn check_tests(table: &[(u8, u64, u64, u64, bool)], tests: &[(u8, u64, u64, bool)]) {
//     for (itest, test) in tests.iter().enumerate() {
//         let op_name = if let Ok(_op) = ZiskOp::try_from_code(test.0) { _op.name() } else { "?" };
//         if let Some(index) = FrequentOpsTable::get_row(test.0, test.1, test.2) {
//             if !test.3
//                 || table[index].0 != test.0
//                 || table[index].1 != test.1
//                 || table[index].2 != test.2
//             {
//                 panic!(
//                     "> #{} {1} 0x{2:X}({2}) 0x{3:X}({3}) {4} = {5} 0x{6:X}({6}) 0x{7:X}({7}) = 0x{8:X}({8}) F:{9} [\x1B[31mFAIL\x1B[0m]",
//                     itest, op_name, test.1, test.2, test.3, ZiskOp::try_from_code(table[index].0).unwrap().name(), table[index].1, table[index].2, table[index].3, table[index].4 as u8
//                 );
//             }
//         } else if test.3 {
//             panic!(
//                 "> #{} {1} 0x{2:X}({2}) 0x{3:X}({3}) {4} = NOT FOUND [\x1B[31mFAIL\x1B[0m]",
//                 itest, op_name, test.1, test.2, test.3
//             );
//         }
//     }
//     println!("Table Size: {}", table.len());
// }
