use sm_frequent_ops::FrequentOpsHelpers;
use static_assertions::const_assert;
use std::error::Error;
use zisk_core::zisk_ops::ZiskOp;

const OP_SIGNEXTENDB: u8 = ZiskOp::SignExtendB.code();
const OP_SIGNEXTENDH: u8 = ZiskOp::SignExtendH.code();
const OP_SIGNEXTENDW: u8 = ZiskOp::SignExtendW.code();
const OP_SLL: u8 = ZiskOp::Sll.code();
const OP_SLLW: u8 = ZiskOp::SllW.code();
const OP_SRA: u8 = ZiskOp::Sra.code();
const OP_SRL: u8 = ZiskOp::Srl.code();
const OP_SRAW: u8 = ZiskOp::SraW.code();
const OP_SRLW: u8 = ZiskOp::SrlW.code();

const LOW_VALUES_OPCODES: [u8; 9] = [
    OP_SIGNEXTENDB,
    OP_SIGNEXTENDH,
    OP_SIGNEXTENDW,
    OP_SLL,
    OP_SLLW,
    OP_SRA,
    OP_SRL,
    OP_SRAW,
    OP_SRLW,
];

const MAX_A_LOW_VALUE: u64 = 386;
const MAX_B_LOW_VALUE: u64 = 386;
const LOW_VALUE_SIZE: usize = MAX_A_LOW_VALUE as usize * MAX_B_LOW_VALUE as usize;
const MAX_U64: u64 = 0xFFFF_FFFF_FFFF_FFFF;

const SLR_MASK_FROM: u64 = 0xFFFF_FFFF_FFFF_F000;
const SLR_TO_B: u64 = 64;

// table autogenerated with FrequentOpsTable::print_table_offsets()
// this table is used to calculate the offset (row) of each operation
const OP_TABLE_OFFSETS_START: usize = 49;
const OP_TABLE_OFFSETS: [usize; 9] =
    [0, 148996, 564232, 713228, 862224, 1011220, 1160216, 1309212, 1458208];

#[derive(Debug, Clone)]
pub struct BinaryExtensionFrops {
    table: FrequentOpsHelpers,
}

const FREQUENT_OP_EMPTY: usize = 256;

impl Default for BinaryExtensionFrops {
    fn default() -> Self {
        Self::new()
    }
}
impl BinaryExtensionFrops {
    pub const TABLE_ID: usize = 5003;
    pub const NO_FROPS: usize = FrequentOpsHelpers::NO_FROPS;
    pub fn new() -> Self {
        Self { table: FrequentOpsHelpers::new() }
    }

    fn build_low_values_operations(&mut self) {
        let mut ops = self.table.get_low_values_operations(MAX_A_LOW_VALUE, MAX_B_LOW_VALUE);
        for op in LOW_VALUES_OPCODES.iter() {
            self.table.add_ops(*op, &mut ops, false);
        }
    }

    fn build_srl(&mut self) {
        let mut ops: Vec<[u64; 2]> = Vec::new();
        for i in SLR_MASK_FROM..=MAX_U64 {
            for j in 0..=SLR_TO_B {
                ops.push([i, j]);
            }
        }
        self.table.add_ops(OP_SRL, &mut ops, true);
    }
    #[inline(always)]
    fn is_frequent_srl(a: u64, b: u64) -> bool {
        (a < MAX_A_LOW_VALUE && b < MAX_B_LOW_VALUE) || (a >= SLR_MASK_FROM && b <= SLR_TO_B)
    }
    #[inline(always)]
    fn get_srl_offset(a: u64, b: u64) -> usize {
        if a < MAX_A_LOW_VALUE && b < MAX_B_LOW_VALUE {
            Self::get_low_values_offset(a, b)
        } else if a >= SLR_MASK_FROM && b <= SLR_TO_B {
            LOW_VALUE_SIZE + ((a - SLR_MASK_FROM) * (SLR_TO_B + 1) + b) as usize
        } else {
            FrequentOpsHelpers::NO_FROPS
        }
    }
    pub fn build_table(&mut self) {
        self.build_low_values_operations();
        self.build_srl();
    }
    #[inline(always)]
    fn get_low_values_offset(a: u64, b: u64) -> usize {
        (a * MAX_B_LOW_VALUE + b) as usize
    }

    #[inline(always)]
    pub fn is_frequent_op(op: u8, a: u64, b: u64) -> bool {
        // Use lookup table for faster branching instead of match on enum
        match op {
            // Low value operations - check bounds first (most common case)
            OP_SIGNEXTENDB | OP_SIGNEXTENDH | OP_SIGNEXTENDW | OP_SLL | OP_SLLW | OP_SRA
            | OP_SRAW | OP_SRLW => a < MAX_A_LOW_VALUE && b < MAX_B_LOW_VALUE,
            // Special cases - inline the logic to avoid function calls
            OP_SRL => Self::is_frequent_srl(a, b),
            _ => false,
        }
    }

    #[inline(always)]
    pub fn get_row(op: u8, a: u64, b: u64) -> usize {
        // ecall/system call functions are not candidates to be usual
        match op {
            OP_SIGNEXTENDB | OP_SIGNEXTENDH | OP_SIGNEXTENDW | OP_SLL | OP_SLLW | OP_SRA
            | OP_SRAW | OP_SRLW => {
                if a < MAX_A_LOW_VALUE && b < MAX_B_LOW_VALUE {
                    OP_TABLE_OFFSETS[op as usize - OP_TABLE_OFFSETS_START]
                        + Self::get_low_values_offset(a, b) as usize
                } else {
                    FrequentOpsHelpers::NO_FROPS
                }
            }
            OP_SRL => {
                OP_TABLE_OFFSETS[op as usize - OP_TABLE_OFFSETS_START]
                    + Self::get_srl_offset(a, b) as usize
            }
            _ => FrequentOpsHelpers::NO_FROPS,
        }
    }
    #[inline(always)]
    pub fn count(&self) -> usize {
        self.table.count()
    }
    #[cfg(test)]
    pub fn test_table_offsets(&mut self) {
        self.build_table();
        let (start, offsets) = self.table.generate_table_offsets();
        if (start != OP_TABLE_OFFSETS_START) || (offsets != OP_TABLE_OFFSETS) {
            self.table.print_table_offsets();
            panic!("Table offsets do not match expected values");
        }
        assert_eq!(start, OP_TABLE_OFFSETS_START);
        assert_eq!(offsets, OP_TABLE_OFFSETS);
    }
    #[inline(always)]
    pub fn generate_full_table(&self) -> Vec<(u8, u64, u64, u64, bool)> {
        self.table.generate_full_table()
    }
    #[inline(always)]
    pub fn generate_table(&self) -> Vec<(u8, u64, u64)> {
        self.table.generate_table()
    }
    #[inline(always)]
    pub fn generate_cmd(
        &mut self,
        cmd_name: &'static str,
        default_file: &'static str,
    ) -> Result<(), Box<dyn Error>> {
        self.build_table();
        let full_table = self.generate_full_table();
        let full_table_count = full_table.len();
        self.table.generate_cmd(
            "Zisk",
            "BinaryExtensionFrops",
            cmd_name,
            default_file,
            full_table,
            full_table_count,
        )
    }
}

#[test]
pub fn test_table_offsets() {
    let mut fops = BinaryExtensionFrops::new();
    fops.test_table_offsets();
}

#[test]
fn test_all_binary_extension_accessible_values() {
    let mut fops = BinaryExtensionFrops::new();
    fops.build_table();
    let table = fops.generate_full_table();
    FrequentOpsHelpers::test_all_accessible_values(
        &table,
        BinaryExtensionFrops::is_frequent_op,
        BinaryExtensionFrops::get_row,
    );
}
