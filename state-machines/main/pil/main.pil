require "std_lookup.pil"
require "std_permutation.pil"
require "std_common.pil"

const int BOOT_ADDR = 0x1000;
const int END_PC_ADDR = 0x2000;

const int NOP_ROM_ADDR = 0x10000000;

airtemplate Main(int N = 2**21, int RC = 2, int stack_enabled = 0, const int operation_bus_id, int MAIN_CONTINUATION_ID = 1000) {

    col fixed SEGMENT_L1 = [1,0...];
    col fixed SEGMENT_STEP = [0,0..(N-2)];

    const expr SEGMENT_LAST = SEGMENT_L1';

    airval main_last_segment;
    airval main_segment;

    // continuations
    //
    // first row of each segment is its initial state and must match with last
    // row of previous segment. This first row it's a valid rom line, same that
    // last of previous segment. This way to do continuations implies that:
    //
    // - each segment only has N-1 valid rows.
    //
    // - it's possible reference previous row, but no next row.
    //
    // - the first two rows has same SEGMENT_STEP 0.
    //
    // - global bus constraint with initial state of main (as initial PC)
    //          [segment:0, is_last_segment: 0, pc: INITIAL_PC, a, b, c, flag]
    //
    // - global bus constraint with final state of main (as expected PC)
    //          [segment:0, is_last_segment: 1, pc: FINAL_PC, a, b, c, flag]
    //
    // - is_last_segment it's used for security to avoid used to do more cycles of main.
    //
    // - registers a,b could be removed from main continuations.
    //

    main_last_segment * (1 - main_last_segment) === 0;

    const expr STEP = main_segment * (N - 1) + SEGMENT_STEP;

    // Registers

    col witness a[RC];
    col witness b[RC];
    col witness c[RC];
    col witness flag;

    col witness pc;      // Program counter

    // Source A

    col witness a_src_imm;         // Selector
    col witness a_src_mem;         // Selector
    col witness a_offset_imm0;

    if (stack_enabled == 1) {
        col witness air.sp;
        col witness air.a_src_sp;
        col witness air.a_use_sp_imm1;
    } else {
        col witness air.a_imm1;
    }
    col witness a_src_step;

    // Source B

    col witness b_src_imm;         // Selector
    col witness b_src_mem;         // Selector
    col witness b_offset_imm0;

    if (stack_enabled) {
        col witness air.b_use_sp_imm1;
    } else {
        col witness air.b_imm1;
    }
    col witness b_src_ind;
    col witness ind_width;  // 8, 4, 2, 1

    // Operations related

    col witness is_external_op;    // 1 If it's an op proved by a different coprocessor (1 clock op).
    col witness op;                // if is_external_op1== is_external_op2 == 0 if op=0  then a->c, flag->1
                                   //                                           if op=1 then  b->c, flag->0;
                                   // else then this op is passed to the bus.

    // Destination C

    // What to store
    col witness store_ra;  // Store the return address instead of the C register.

    // Where to store
    col witness store_mem;  // 1 of the registers are read/write from memory
    col witness store_ind;

    col witness store_offset;

    col witness set_pc;


    if (stack_enabled) {
        col witness air.store_use_sp;
        col witness air.set_sp;
        col witness air.inc_sp;
    }


    col witness jmp_offset1, jmp_offset2;  // if flag, goto2, else goto 1
    col witness m32;

    const expr sel_mem_b;

    sel_mem_b = b_src_mem + b_src_ind;
    if (stack_enabled) {
        col witness air.addr0;
        col witness air.addr1;
        col witness air.addr2;

        addr0 === a_offset_imm0 + a_use_sp_imm1 * sp;
        addr1 === b_offset_imm0 + b_src_ind * (a[0] + 2**32 * a[1]) +  b_use_sp_imm1 * sp;
        addr2 === store_offset + store_ind * a[0] + store_use_sp * sp;
    } else {
        const expr air.addr0;
        col witness air.addr1;
        const expr air.addr2;
        addr0 = a_offset_imm0;
        addr1 === b_offset_imm0 + b_src_ind * (a[0] + 2**32 * a[1]);
        addr2 = store_offset + store_ind * a[0];
    }

    // Mem.load
    mem_load(sel: a_src_mem,
             step: STEP,
             addr: addr0,
             value: a);

    // Mem.load
    mem_load(sel: sel_mem_b,
             step: STEP,
             step_offset: 1,
             bytes: b_src_ind * (ind_width - 8) + 8,
             addr: addr1,
             value: b);

    const expr store_value[2];

    store_value[0] = store_ra*(pc + jmp_offset2 - c[0]) + c[0];
    store_value[1] = (1 - store_ra) * c[1];

    // Mem.store
    mem_store(sel: store_mem + store_ind,
              step: STEP,
              step_offset: 2,
              bytes: store_ind * (ind_width - 8) + 8,
              addr: addr2,
              value: store_value);

    // Operation.assume => how organize software
    col witness __debug_operation_bus_enabled;

    lookup_assumes(operation_bus_id, [STEP, op, a[0], (1 - m32) * a[1], b[0], (1 - m32) * b[1], ...c, flag], sel: is_external_op * __debug_operation_bus_enabled, name: PIOP_NAME_ISOLATED);

    const expr a_src_c;
    const expr b_src_c;

    const expr a_imm[2];
    const expr b_imm[2];

    a_imm[0] = a_offset_imm0;
    b_imm[0] = b_offset_imm0;

    if (stack_enabled) {
        a_src_c = 1 - a_src_step - a_src_mem - a_src_imm - a_src_sp;
        b_src_c = 1 - b_src_mem - b_src_imm - b_src_ind;
        a_imm[1] = a_use_sp_imm1;
        b_imm[1] = b_use_sp_imm1;
    } else {
        a_src_c = 1 - a_src_step - a_src_mem - a_src_imm;
        b_src_c = 1 - b_src_mem - b_src_imm - b_src_ind;
        a_imm[1] = a_imm1;
        b_imm[1] = b_imm1;
    }

    for (int index = 0; index < RC; ++index) {
        if (stack_enabled) {
            // a_src_sp ===> set a = sp (only less significant index, rest must be 0)
            a_src_sp * (a[index] - (index == 0 ? sp: 0 )) === 0;
        }
        a_src_step * (a[index] - (index == 0 ? STEP : 0)) === 0;
        a_src_c * (a[index] - 'c[index]) === 0;
        b_src_c * (b[index] - 'c[index]) === 0;

        a_src_imm * (a[index] - a_imm[index]) === 0;
        b_src_imm * (b[index] - b_imm[index]) === 0;

        // continuations_transition(last_c[index], c[index]); // last_c[index]' = c[index];

        // if is not an external op and op=0 set c = 0
        (1 - is_external_op) * (1 - op) * c[index] === 0;

        // if is not an external op and op=1 set c = b
        (1 - is_external_op) * op * (b[index] - c[index]) === 0;
    }


    // if is not an external op and op=0 set flag = 1
    (1 - is_external_op) * (1 - op) * (1 - flag) === 0;

    // if is not an external op and op=1 set flag = 0
    (1 - is_external_op) * op * (flag) === 0;


    flag * set_pc === 0;
    // TODO! The following constraint is correct but something is not working in the compiler

    // const expr next_pc = set_pc * (c[0] + jmp_offset1) + (1 - set_pc) * (pc + jmp_offset2) + flag * (jmp_offset1 - jmp_offset2);
    const expr next_pc = 'set_pc * ('c[0] + 'jmp_offset1) + (1 - 'set_pc) * ('pc + 'jmp_offset2) + 'flag * ('jmp_offset1 - 'jmp_offset2);
    (1 - SEGMENT_L1) * (pc - next_pc) === 0;

    const expr is_last_continuation = SEGMENT_LAST * main_last_segment;
    const expr specific_registers[stack_enabled ? 2:1];
    specific_registers[0] = pc;

    if (stack_enabled) {
        const expr next_sp = set_sp * (c[0] - sp) + sp + inc_sp;

        (1 - SEGMENT_LAST) * (sp - 'next_sp) === 0;
        specific_registers[1] = sp;
    }

    // main_last_segment = 0 => row = 0   => bus_main_segment = K      (assumes)
    //                          row = N-1 => bus_main_segment = K + 1  (proves)
    //
    // main_last_segment = 1 => row = 0   => bus_main_segment = J      (assumes)
    //                          row = N-1 => bus_main_segment = 0      (proves)
    //

    const expr bus_main_segment = main_segment - SEGMENT_LAST * (main_segment * main_last_segment - 1 + main_last_segment);
    permutation (MAIN_CONTINUATION_ID, cols: [bus_main_segment, is_last_continuation, pc, c[0], c[1], set_pc, jmp_offset1, flag * SEGMENT_LAST * (jmp_offset1 - jmp_offset2) + jmp_offset2],
                                        sel: SEGMENT_LAST - SEGMENT_L1, name: PIOP_NAME_ISOLATED, bus_type: PIOP_BUS_SUM);

    flag * (1 - flag) === 0;

    // set lsb of rom_flags always to 1 to force that padding rom rows (all values to zero), doesn't
    // match with main trace.
    const expr rom_flags = 1 + 2 * a_src_imm + 4 * a_src_mem + 8 * a_src_step + 16 * b_src_imm + 32 * b_src_mem
                           + 64 * is_external_op + 128 * store_ra + 256 * store_mem + 512 * store_ind +
                           + 1024 * set_pc + 2048 * m32 + 4096 * b_src_ind;


    // SETTINGS ROW 0
    // -----------------------------------------------------
    // b_offset_imm0 = b[0] = c[0] <== c[0] previous segment
    // b_imm1 = b[1] = c[1] <== c[1] previous segment
    // a_offset_imm0 = a[0] <== a[0] previous segment
    // a_imm1 = a[1] <== a[1] previous segment
    // op = 1 (copyb: c=b, flag=0)
    // pc <== pc previous segment (start of program at first segment; it needs to be equal to pc of row 1)
    // jmp_offset1 = jmp_offset2 = 0
    // flag = 0
    // a_src_imm = b_src_imm = 1 (rest flags to 0)

    SEGMENT_L1 * (rom_flags - 19 - set_pc * 1024) === 0; // 19 = 1 + a_src_imm(2) + b_src_imm(16)
    SEGMENT_L1 * (op - 1) === 0;

    lookup_assumes(ROM_BUS_ID, [pc, a_offset_imm0, a_imm1, b_offset_imm0, b_imm1, ind_width,
                                op, store_offset, jmp_offset1, jmp_offset2, rom_flags], sel: 1 - SEGMENT_L1);

    direct_global_update_proves(MAIN_CONTINUATION_ID, cols: [0, 0, 4096, 0, 0, 0, 0, 0], bus_type: PIOP_BUS_SUM);
    direct_global_update_assumes(MAIN_CONTINUATION_ID, cols: [0, 1, 0x1000_0000, 0, 0, 0, 0, 0], bus_type: PIOP_BUS_SUM);
}
