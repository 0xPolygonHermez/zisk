use log::info;
use p3_field::PrimeField;
use sm_common::InstanceExpanderCtx;

use std::sync::Arc;
use zisk_core::{zisk_ops::ZiskOp, ZiskRom, ROM_ENTRY};

use proofman::WitnessManager;
use proofman_common::{AirInstance, ProofCtx};

use proofman::WitnessComponent;
use zisk_pil::{MainRow, MainTrace, MAIN_AIR_IDS, ZISK_AIRGROUP_ID};
use ziskemu::{Emu, EmuTrace};

/// This is a multithreaded implementation of the Zisk MainSM state machine.
///
/// The MainSM state machine is responsible for orchestrating the execution of the program and
/// processing the inputs generated by the emulator. The MainSM state machine interacts with the
/// secondary state machines to process the inputs generated by the emulator.
pub struct MainSM<F: PrimeField> {
    /// Witness computation manager
    wcm: Arc<WitnessManager<F>>,
}

impl<F: PrimeField> MainSM<F> {
    const MY_NAME: &'static str = "MainSM  ";

    /// Constructor for the MainSM state machine
    /// Registers the state machine at the WCManager and stores references to the secondary state
    /// machines that directly interact with the MainSM
    /// Returns an Arc to the MainSM state machine
    /// # Arguments
    /// * `wcm` - Witness computation manager to register the state machine
    /// * `arith_sm` - Arc to the ArithSM state machine
    /// * `binary_sm` - Arc to the BinarySM state machine
    /// * `mem_sm` - Arc to the MemSM state machine
    /// # Returns
    /// * Arc to the MainSM state machine
    pub fn new(wcm: Arc<WitnessManager<F>>) -> Arc<Self> {
        let main_sm = Arc::new(Self { wcm: wcm.clone() });

        wcm.register_component(main_sm.clone(), Some(ZISK_AIRGROUP_ID), Some(MAIN_AIR_IDS));

        main_sm
    }

    pub fn get_instance(&self, iectx: InstanceExpanderCtx) -> MainInstance<F> {
        MainInstance::new(&self.wcm, iectx)
    }

    pub fn prove_main(
        &self,
        zisk_rom: &ZiskRom,
        vec_traces: &[EmuTrace],
        main_instance: &mut MainInstance<F>,
        pctx: &ProofCtx<F>,
    ) {
        let iectx = &main_instance.iectx;
        let current_segment = iectx.plan.segment_id.unwrap();

        let air = pctx.pilout.get_air(ZISK_AIRGROUP_ID, MAIN_AIR_IDS[0]);
        let filled = vec_traces[current_segment].steps.len() + 1;
        info!(
            "{}: ··· Creating Main segment #{} [{} / {} rows filled {:.2}%]",
            Self::MY_NAME,
            current_segment,
            filled,
            air.num_rows(),
            filled as f64 / air.num_rows() as f64 * 100.0
        );

        // Set Row 0 of the current segment
        let row0 = if current_segment == 0 {
            MainRow::<F> {
                pc: F::from_canonical_u64(ROM_ENTRY),
                op: F::from_canonical_u8(ZiskOp::CopyB.code()),
                a_src_imm: F::one(),
                b_src_imm: F::one(),
                ..MainRow::default()
            }
        } else {
            let emu_trace_previous = vec_traces[current_segment - 1].steps.last().unwrap();
            let mut emu =
                Emu::from_emu_trace_start(zisk_rom, &vec_traces[current_segment - 1].last_state);
            let row_previous = emu.step_slice_full_trace(emu_trace_previous);

            MainRow::<F> {
                set_pc: row_previous.set_pc,
                jmp_offset1: row_previous.jmp_offset1,
                jmp_offset2: if row_previous.flag == F::one() {
                    row_previous.jmp_offset1
                } else {
                    row_previous.jmp_offset2
                },
                a: row_previous.a,
                b: row_previous.c,
                c: row_previous.c,
                a_offset_imm0: row_previous.a[0],
                b_offset_imm0: row_previous.c[0],
                addr1: row_previous.c[0],
                a_imm1: row_previous.a[1],
                b_imm1: row_previous.c[1],
                op: F::from_canonical_u8(ZiskOp::CopyB.code()),
                pc: row_previous.pc,
                a_src_imm: F::one(),
                b_src_imm: F::one(),
                ..MainRow::default()
            }
        };

        let mut emu = Emu::from_emu_trace_start(zisk_rom, &vec_traces[current_segment].start_state);

        main_instance.main_trace.buffer[0] = row0;

        // Set Rows 1 to N of the current segment (N = maximum number of air rows)
        for (idx, emu_trace) in vec_traces[current_segment].steps.iter().enumerate() {
            let expanded_row = emu.step_slice_full_trace(emu_trace);

            main_instance.main_trace.buffer[idx + 1] = expanded_row;
        }

        let filled_rows = vec_traces[current_segment].steps.len();
        let last_row = main_instance.main_trace.buffer[filled_rows];

        // Fill the rest of the buffer with the last row
        for i in (filled_rows + 1)..main_instance.main_trace.buffer.len() {
            main_instance.main_trace.buffer[i] = last_row;
        }

        let buffer = std::mem::take(&mut main_instance.main_trace.buffer);
        let buffer: Vec<F> = unsafe { std::mem::transmute(buffer) };

        let sctx = self.wcm.get_sctx();
        let mut air_instance = AirInstance::new(
            sctx.clone(),
            ZISK_AIRGROUP_ID,
            MAIN_AIR_IDS[0],
            Some(current_segment),
            buffer,
        );

        let main_last_segment = F::from_bool(current_segment == vec_traces.len() - 1);
        let main_segment = F::from_canonical_usize(current_segment);

        air_instance.set_airvalue("Main.main_last_segment", None, main_last_segment);
        air_instance.set_airvalue("Main.main_segment", None, main_segment);

        self.wcm
            .get_pctx()
            .air_instance_repo
            .add_air_instance(air_instance, Some(iectx.instance_global_idx));
    }
}

impl<F: PrimeField> WitnessComponent<F> for MainSM<F> {}

pub struct MainInstance<F: PrimeField> {
    iectx: InstanceExpanderCtx,
    main_trace: MainTrace<F>,
}

impl<F: PrimeField> MainInstance<F> {
    pub fn new(wcm: &WitnessManager<F>, iectx: InstanceExpanderCtx) -> Self {
        let pctx = wcm.get_pctx();
        let plan = &iectx.plan;
        let air = pctx.pilout.get_air(plan.airgroup_id, plan.air_id);
        let main_trace = MainTrace::new(air.num_rows());

        Self { iectx, main_trace }
    }
}
