use log::info;
use p3_field::PrimeField;

use proofman_util::{timer_start, timer_stop_and_log};
use rayon::{prelude::*, vec, Scope, ThreadPoolBuilder};
use sm_binary::BinarySM;
use std::{
    fs, mem,
    path::{Path, PathBuf},
    sync::{Arc, Mutex},
    thread::sleep,
    time::Duration,
};
use zisk_core::{Riscv2zisk, ZiskRequired, ZiskRom};

use proofman::WitnessManager;
use proofman_common::{AirInstance, ExecutionCtx, ProofCtx, SetupCtx};

use zisk_pil::{Main0Row, Main0Trace, MAIN_AIRGROUP_ID, MAIN_AIR_IDS};
use ziskemu::{
    EmuFullTraceStep, EmuOptions, EmuTrace, ParEmuExecutionType, ParEmuOptions, ZiskEmulator,
};

use proofman::WitnessComponent;
use sm_arith::ArithSM;
use sm_common::{create_prover_buffer, Provable, ThreadController};
use sm_mem::MemSM;

#[derive(Default)]
pub struct MainAirSegment<F> {
    pub air_segment_id: u32,
    pub filled_inputs: usize,
    pub inputs: Vec<EmuFullTraceStep<F>>,
}

impl<F: Default + Clone> MainAirSegment<F> {
    pub fn new(segment_id: u32) -> Self {
        Self { air_segment_id: segment_id, filled_inputs: 0, inputs: Vec::new() }
    }
}

/// This is a multithreaded implementation of the Zisk MainSM state machine.
///
/// The MainSM state machine is responsible for orchestrating the execution of the program and
/// processing the inputs generated by the emulator. The MainSM state machine interacts with the
/// secondary state machines to process the inputs generated by the emulator.
pub struct MainSM<F: PrimeField> {
    // Thread controller to manage the execution of the state machines
    threads_controller: Arc<ThreadController>,
    // Zisk ROM
    zisk_rom: ZiskRom,
    zisk_rom_path: PathBuf,

    // State machines
    mem_sm: Arc<MemSM>,
    binary_sm: Arc<BinarySM<F>>,
    arith_sm: Arc<ArithSM>,
}

impl<'a, F: PrimeField> MainSM<F> {
    const MY_NAME: &'static str = "MainSM  ";

    /// Default number of inputs of the main state machine that are accumulated before being
    /// processed
    const BLOCK_SIZE: usize = 2usize.pow(18);
    const NUM_THREADS: usize = 8;
    const NUM_THREADS_REQUIRED: usize = 8;

    /// Constructor for the MainSM state machine
    /// Registers the state machine at the WCManager and stores references to the secondary state
    /// machines that directly interact with the MainSM
    /// Returns an Arc to the MainSM state machine
    /// # Arguments
    /// * `rom_path` - Path to the ROM file
    /// * `wcm` - Witness computation manager to register the state machine
    /// * `mem_sm` - Arc to the MemSM state machine
    /// * `binary_sm` - Arc to the BinarySM state machine
    /// * `arith_sm` - Arc to the ArithSM state machine
    /// * `air_ids` - Array of Main Air IDs extracted from the pilout
    /// # Returns
    /// * Arc to the MainSM state machine
    pub fn new(
        rom_path: PathBuf,
        wcm: Arc<WitnessManager<F>>,
        mem_sm: Arc<MemSM>,
        binary_sm: Arc<BinarySM<F>>,
        arith_sm: Arc<ArithSM>,
    ) -> Arc<Self> {
        // If rom_path has an .elf extension it must be converted to a ZisK ROM
        let zisk_rom = if rom_path.extension().unwrap() == "elf" {
            // Create an instance of the RISCV -> ZisK program converter
            let rv2zk = Riscv2zisk::new(
                rom_path.display().to_string(),
                String::new(),
                String::new(),
                String::new(),
            );

            // Convert program to rom
            match rv2zk.run() {
                Ok(rom) => rom,
                Err(e) => {
                    panic!("Application error: {}", e);
                }
            }
        } else {
            // TODO - Remove this when the ZisK ROM is able to be loaded from a file
            panic!("ROM file must be an ELF file");
        };

        // TODO - Compute MAX_ACCUMULATED having the num_rows of the Main AIR
        // TODO - If there is more than one Main AIR available, the MAX_ACCUMULATED will be the one
        // with the highest num_rows. It has to be a power of 2.

        let main_sm = Arc::new(Self {
            threads_controller: Arc::new(ThreadController::new()),
            zisk_rom,
            zisk_rom_path: rom_path.to_path_buf(),
            mem_sm: mem_sm.clone(),
            binary_sm: binary_sm.clone(),
            arith_sm: arith_sm.clone(),
        });

        wcm.register_component(main_sm.clone(), Some(MAIN_AIRGROUP_ID), Some(MAIN_AIR_IDS));

        // For all the secondary state machines, register the main state machine as a predecessor
        main_sm.mem_sm.register_predecessor();
        main_sm.binary_sm.register_predecessor();
        main_sm.arith_sm.register_predecessor();

        main_sm
    }

    /// Executes the MainSM state machine and processes the inputs in batches when the maximum
    /// number of accumulated inputs is reached. The MainSM state machine uses the emulator to
    /// execute the a program and using a callback the main state machine receives batches of
    /// inputs generated by the emulator. The inputs are processed in batches when the maximum
    /// number of accumulated inputs is reached
    /// # Arguments
    /// * `pctx` - Proof context to interact with the proof system
    /// * `ectx` - Execution context to interact with the execution environment
    pub fn execute(
        &self,
        public_inputs_path: &Path,
        pctx: Arc<ProofCtx<F>>,
        ectx: Arc<ExecutionCtx>,
        sctx: Arc<SetupCtx>,
    ) {
        // Create a thread pool to manage the execution of all the state machines related to the
        // execution process
        let pool = ThreadPoolBuilder::new().num_threads(16).build().unwrap();

        timer_start!(PREPARE_EMULATOR);
        // Prepare the settings for the emulator
        let emulator_options = EmuOptions {
            elf: Some(self.zisk_rom_path.clone().display().to_string()),
            inputs: Some(public_inputs_path.display().to_string()),
            trace_steps: Some(Self::BLOCK_SIZE as u64),
            ..EmuOptions::default()
        };

        // Call emulate with these options
        let public_inputs = {
            // Read inputs data from the provided inputs path
            let path = PathBuf::from(public_inputs_path.display().to_string());
            fs::read(path).expect("Could not read inputs file")
        };

        // Execute the emulator inside a thread
        let vec_full_trace = Mutex::new(vec![Vec::new(); Self::NUM_THREADS]);
        let vec_requireds = Mutex::new(vec![Vec::new(); Self::NUM_THREADS]);
        timer_stop_and_log!(PREPARE_EMULATOR);

        timer_start!(PAR_PROCESS_ROM);
        pool.scope(|scope| {
            (0..(Self::NUM_THREADS + Self::NUM_THREADS_REQUIRED)).into_par_iter().for_each(|i| {
                let par_emu_options = ParEmuOptions::new(
                    Self::NUM_THREADS,
                    i,
                    Self::BLOCK_SIZE,
                    if i < Self::NUM_THREADS {
                        ParEmuExecutionType::MainTrace
                    } else {
                        ParEmuExecutionType::RequiredInputs
                    },
                );

                let result = ZiskEmulator::par_process_rom::<F>(
                    &self.zisk_rom,
                    &public_inputs,
                    &emulator_options,
                    &par_emu_options,
                );

                // Eval the return value of the emulator to launch a panic if an error occurred
                let (_vec_full_trace, _vec_requireds) = match result {
                    Ok((a, b)) => (a, b),
                    Err(e) => panic!("Error during emulator execution: {:?}", e),
                };

                if par_emu_options.execution_type == ParEmuExecutionType::MainTrace {
                    vec_full_trace.lock().unwrap()[i] = _vec_full_trace;
                } else {
                    vec_requireds.lock().unwrap()[i - 8] = _vec_requireds;
                }
            });
            timer_stop_and_log!(PAR_PROCESS_ROM);

            scope.spawn(|_| {
                let vec_full_trace = vec_full_trace.into_inner().unwrap();
                Self::prove_main(vec_full_trace, &pctx, &ectx, &sctx);
            });

            let vec_requireds = vec_requireds.into_inner().unwrap();
            self.binary_sm.prove_basic(&vec_requireds, scope);
            // self.prove_inputs(vec_requireds, scope);
        });
    }

    fn prove_main(
        vec_full_trace: Vec<Vec<Vec<Main0Row<F>>>>,
        pctx: &ProofCtx<F>,
        ectx: &ExecutionCtx,
        sctx: &SetupCtx,
    ) {
        timer_start!(CREATE_INSTANCES);
        let num_steps: usize = vec_full_trace
            .iter()
            .map(|full_trace_thread| {
                full_trace_thread.iter().map(|full_trace| full_trace.len()).sum::<usize>()
            })
            .sum();

        let air = pctx.pilout.get_air(MAIN_AIRGROUP_ID, MAIN_AIR_IDS[0]);

        let num_main_sm_instances = (num_steps as f64 / air.num_rows() as f64).ceil() as usize;
        let num_blocks_in_instance = air.num_rows() / Self::BLOCK_SIZE;

        println!("Num main instances: {}", num_main_sm_instances);
        println!("Num blocks in instance: {}", num_blocks_in_instance);

        (0..num_main_sm_instances).into_par_iter().for_each(|instance_id| {
            let main_first_segment = F::from_bool(instance_id == 0);
            let main_last_segment = F::from_bool(instance_id == num_main_sm_instances - 1);
            let main_segment = F::from_canonical_usize(instance_id);

            let filled_rows = if instance_id == num_main_sm_instances - 1 {
                num_steps % air.num_rows()
            } else {
                air.num_rows()
            };
            info!(
                "{}: ··· Creating Main segment #{} [{} / {} rows filled {:.2}%]",
                Self::MY_NAME,
                instance_id,
                filled_rows,
                air.num_rows(),
                filled_rows as f64 / air.num_rows() as f64 * 100.0
            );

            // Create the prover buffer
            let (mut prover_buffer, offset) =
                create_prover_buffer(&ectx, &sctx, MAIN_AIRGROUP_ID, MAIN_AIR_IDS[0]);

            let mut last_row = Main0Row::<F>::default();
            let mut rng;
            for k in 0..num_blocks_in_instance {
                let block_id = instance_id * num_blocks_in_instance + k;
                let box_id = block_id % Self::NUM_THREADS;
                let box_level = block_id / Self::NUM_THREADS;

                // Check if [box_id][box_level] exists
                if box_level < vec_full_trace[box_id].len() {
                    let block = &vec_full_trace[box_id][box_level];

                    for l in 0..block.len() {
                        let offset_block =
                            offset as usize + (k * Self::BLOCK_SIZE + l) * Main0Row::<F>::ROW_SIZE;

                        last_row = block[l];
                        // Set segment information in the inputs
                        last_row.main_first_segment = main_first_segment;
                        last_row.main_last_segment = main_last_segment;
                        last_row.main_segment = main_segment;

                        prover_buffer[offset_block..offset_block + Main0Row::<F>::ROW_SIZE]
                            .copy_from_slice(last_row.as_slice());
                    }

                    rng = block.len()..Self::BLOCK_SIZE;
                } else {
                    rng = 0..Self::BLOCK_SIZE;
                }

                for l in rng {
                    let offset_block =
                        offset as usize + (k * Self::BLOCK_SIZE + l) * Main0Row::<F>::ROW_SIZE;

                    prover_buffer[offset_block..offset_block + Main0Row::<F>::ROW_SIZE]
                        .copy_from_slice(last_row.as_slice());
                }
            }

            let air_instance = AirInstance::new(
                MAIN_AIRGROUP_ID,
                MAIN_AIR_IDS[0],
                Some(instance_id),
                prover_buffer,
            );

            pctx.air_instance_repo.add_air_instance(air_instance);
        });
        timer_stop_and_log!(CREATE_INSTANCES);

        // self.threads_controller.wait_for_threads();

        // Unregister main state machine as a predecessor for all the secondary state machines
        // timer_start!(UNREGISTER_PREDECESSORS);
        // self.mem_sm.unregister_predecessor::<F>(scope);
        // self.binary_sm.unregister_predecessor(scope);
        // self.arith_sm.unregister_predecessor::<F>(scope);
        // timer_stop_and_log!(UNREGISTER_PREDECESSORS);
        // });

        std::thread::spawn(move || {
            drop(vec_full_trace);
        });
    }

    fn prove_inputs(&self, mut vec_required: Vec<Vec<ZiskRequired>>, scope: &Scope<'a>) {
        let mut current_box = 0;
        let mut level = 0;
        loop {
            if vec_required[current_box].len() <= level {
                break;
            }

            let required = &mut vec_required[current_box][level];

            // self.arith_sm.prove(&required.arith, false, scope);

            let req_binary = std::mem::take(&mut required.binary);
            self.binary_sm.prove_xxx(req_binary, false, false, scope);

            let req_extension = std::mem::take(&mut required.binary_extension);
            self.binary_sm.prove_xxx(req_extension, true, false, scope);

            // self.mem_sm.prove(&required.memory, false);

            current_box += 1;
            if current_box == Self::NUM_THREADS {
                current_box = 0;
                level += 1;
            }
        }

        std::thread::spawn(move || {
            drop(vec_required);
        });
    }

    // Callback method to process the inputs generated by the emulator
    #[inline(always)]
    fn emulator_callback(
        &'a self,
        zisk_rom: &'a ZiskRom,
        emu_traces: EmuTrace,
        scope: &Scope<'a>,
        pctx: Arc<ProofCtx<F>>,
        ectx: Arc<ExecutionCtx>,
        sctx: Arc<SetupCtx>,
    ) {
        let air = pctx.pilout.get_air(MAIN_AIRGROUP_ID, MAIN_AIR_IDS[0]);

        // To go faster, we receive from the simulator callback a tiny trace that we are going
        // to process to get the full trace. This is done to avoid the overhead of processing
        // the full trace in the simulator callback and now can be parallelized.
        timer_start!(EXPANDING);
        let emu_slice = match ZiskEmulator::process_slice::<F>(zisk_rom, &emu_traces) {
            Ok(slice) => slice,
            Err(e) => panic!("Error processing slice: {:?}", e),
        };
        timer_stop_and_log!(EXPANDING);

        timer_start!(PROCESS_MAIN);
        let num_segments =
            (emu_slice.full_trace.len() as f64 / air.num_rows() as f64).ceil() as usize;
        let mut total_drained = 0;

        // self.prove(emu_slice.required, ectx.clone(), scope);

        for segment_id in 0..num_segments {
            let num_drained =
                std::cmp::min(air.num_rows(), &emu_slice.full_trace.len() - total_drained);
            let drained_inputs = &emu_slice.full_trace
                [segment_id * air.num_rows()..segment_id * air.num_rows() + num_drained];

            total_drained += num_drained;

            let pctx_cloned = pctx.clone();
            let ectx_cloned = ectx.clone();
            let sctx_cloned = sctx.clone();

            let threads_controller = self.threads_controller.clone();
            threads_controller.add_working_thread();

            timer_start!(TO_VEC);
            let mut air_segment = MainAirSegment::new(segment_id as u32);
            air_segment.inputs = drained_inputs.to_vec();
            air_segment.filled_inputs += num_drained;
            timer_stop_and_log!(TO_VEC);

            scope.spawn(move |_| {
                // As CALLBACK_SIZE is a power of 2, we can check if the segment is full by checking
                let air_segment = mem::take(&mut air_segment);
                Self::create_air_instance(
                    air_segment,
                    pctx_cloned,
                    ectx_cloned,
                    sctx_cloned,
                    false,
                );

                threads_controller.remove_working_thread();
            });
        }
        timer_stop_and_log!(PROCESS_MAIN);

        // scope.spawn(move |scope| {
        //     // To go faster, we receive from the simulator callback a tiny trace that we are going
        //     // to process to get the full trace. This is done to avoid the overhead of processing
        //     // the full trace in the simulator callback and now can be parallelized.
        //     let emu_slice = match ZiskEmulator::process_slice::<F>(zisk_rom, &emu_traces) {
        //         Ok(slice) => slice,
        //         Err(e) => panic!("Error processing slice: {:?}", e),
        //     };

        //     let len = emu_slice.full_trace.len();
        //     let source_iter = emu_slice.full_trace.into_iter();

        //     let mut inputs = self.callback_inputs.lock().unwrap();
        //     let air_segment = &mut inputs[segment_id];

        //     air_segment.inputs.splice(
        //         pos_id * Self::CALLBACK_SIZE..pos_id * Self::CALLBACK_SIZE + source_iter.len(),
        //         source_iter,
        //     );

        //     air_segment.filled_inputs += len;
        //     assert!(air_segment.filled_inputs <= num_rows, "Too many inputs in a Main AIR segment");

        //     self.prove(emu_slice.required, ectx.clone(), scope);

        //     // As CALLBACK_SIZE is a power of 2, we can check if the segment is full by checking
        //     if air_segment.filled_inputs == num_rows {
        //         let air_segment = mem::take(air_segment);
        //         let cloned_ectx = ectx.clone();
        //         Self::create_air_instance(air_segment, pctx, cloned_ectx, sctx, false);
        //     }

        //     threads_controller.remove_working_thread();
        // });
    }

    /// Proves a batch of inputs
    /// When the maximum number of accumulated inputs is reached, the MainSM state machine processes
    /// the inputs in batches. The inputs are processed in parallel using the thread pool
    /// # Arguments
    /// * `inputs` - Vector of EmuTrace inputs to prove
    /// * `pctx` - Proof context to interact with the proof system
    /// * `ectx` - Execution context to interact with the execution environment
    #[inline(always)]
    fn create_air_instance(
        mut air_segment: MainAirSegment<F>,
        pctx: Arc<ProofCtx<F>>,
        ectx: Arc<ExecutionCtx>,
        sctx: Arc<SetupCtx>,
        last_segment: bool,
    ) {
        let air = pctx.pilout.get_air(MAIN_AIRGROUP_ID, MAIN_AIR_IDS[0]);
        info!(
            "{}: ··· Creating Main segment #{} [{} / {} rows filled {:.2}%]",
            Self::MY_NAME,
            air_segment.air_segment_id,
            air_segment.filled_inputs,
            air.num_rows(),
            air_segment.filled_inputs as f64 / air.num_rows() as f64 * 100.0
        );

        // Set remaining rows equals to the last filled row
        let copied_value = air_segment.inputs[air_segment.filled_inputs - 1];
        air_segment.inputs[air_segment.filled_inputs..]
            .par_iter_mut()
            .for_each(|input| *input = copied_value);

        // Set segment information in the inputs
        let main_first_segment = F::from_bool(air_segment.air_segment_id == 0);
        let main_last_segment = F::from_bool(last_segment);
        let main_segment = F::from_canonical_usize(air_segment.air_segment_id as usize);
        air_segment.inputs[..].par_iter_mut().for_each(|input| {
            input.main_first_segment = main_first_segment;
            input.main_last_segment = main_last_segment;
            input.main_segment = main_segment;
        });

        // Create the prover buffer
        let (mut prover_buffer, offset) =
            create_prover_buffer(&ectx, &sctx, MAIN_AIRGROUP_ID, MAIN_AIR_IDS[0]);

        // Convert the Vec<Main0Row<F>> to a flat Vec<F> and copy the resulting values into the
        // prover buffer
        let main_trace_buffer =
            Main0Trace::<F>::from_row_vec(air_segment.inputs).unwrap().buffer.unwrap();
        prover_buffer[offset as usize..offset as usize + main_trace_buffer.len()]
            .par_iter_mut()
            .zip(main_trace_buffer.par_iter())
            .for_each(|(buffer_elem, main_elem)| {
                *buffer_elem = *main_elem;
            });

        let air_instance = AirInstance::new(
            MAIN_AIRGROUP_ID,
            MAIN_AIR_IDS[0],
            Some(air_segment.air_segment_id as usize),
            prover_buffer,
        );

        pctx.air_instance_repo.add_air_instance(air_instance);
    }

    /// Proves a batch of inputs
    /// When the maximum number of accumulated inputs is reached, the MainSM state machine processes
    /// the inputs in batches. The inputs are processed in parallel using the thread pool
    /// # Arguments
    /// * `emu_required` - Inputs to be proved
    /// * `ectx` - Execution context to interact with the execution environment
    #[inline(always)]
    fn prove(&self, mut emu_required: ZiskRequired, _ectx: Arc<ExecutionCtx>, scope: &Scope<'a>) {
        let memory = mem::take(&mut emu_required.memory);
        let binary = mem::take(&mut emu_required.binary);
        let arith = mem::take(&mut emu_required.arith);

        let mem_sm = self.mem_sm.clone();
        let binary_sm = self.binary_sm.clone();
        let arith_sm = self.arith_sm.clone();

        let threads_controller = self.threads_controller.clone();
        threads_controller.add_working_thread();
        scope.spawn(move |scope| {
            mem_sm.prove(&memory, false, scope);

            threads_controller.remove_working_thread();
        });

        let threads_controller = self.threads_controller.clone();
        threads_controller.add_working_thread();
        scope.spawn(move |scope| {
            binary_sm.prove(&binary, false, scope);

            threads_controller.remove_working_thread();
        });

        let threads_controller = self.threads_controller.clone();
        threads_controller.add_working_thread();
        scope.spawn(move |scope| {
            arith_sm.prove(&arith, false, scope);

            threads_controller.remove_working_thread();
        });
    }
}

impl<F: PrimeField> WitnessComponent<F> for MainSM<F> {}
