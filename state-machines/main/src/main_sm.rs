use log::info;
use p3_field::PrimeField;

use core::{num, panic};
use proofman_util::{timer_start_debug, timer_stop_and_log_debug};
use rayon::{prelude::*, ThreadPoolBuilder};
use sm_binary::BinarySM;
use std::{
    fs,
    path::{Path, PathBuf},
    sync::{Arc, Mutex},
};
use zisk_core::{
    Riscv2zisk, ZiskOperationType, ZiskRequiredMemory, ZiskRom, ZISK_OPERATION_TYPE_VARIANTS,
};

use proofman::WitnessManager;
use proofman_common::{AirInstance, ExecutionCtx, ProofCtx, SetupCtx};

use zisk_pil::{
    Main0Row, Main0Trace, BINARY_AIRGROUP_ID, BINARY_AIR_IDS, BINARY_EXTENSION_AIRGROUP_ID,
    BINARY_EXTENSION_AIR_IDS, MAIN_AIRGROUP_ID, MAIN_AIR_IDS, MEM_AIRGROUP_ID, MEM_AIR_IDS,
};
use ziskemu::{Emu, EmuOptions, EmuStartingPoints, EmuTrace, EmuTraceStart, ZiskEmulator};

//use process::Command;
use proofman::WitnessComponent;
use sm_arith::ArithSM;
use sm_common::create_prover_buffer;
use sm_mem::MemProxy;

pub struct InstanceExtensionCtx<F> {
    pub prover_buffer: Vec<F>,
    pub offset: u64,
    pub op_type: ZiskOperationType,
    pub emu_trace_start: EmuTraceStart,
    pub air_instance: Option<AirInstance<F>>,
}

impl<F: Default + Clone> InstanceExtensionCtx<F> {
    pub fn new(
        prover_buffer: Vec<F>,
        offset: u64,
        op_type: ZiskOperationType,
        emu_trace_start: EmuTraceStart,
        air_instance: Option<AirInstance<F>>,
    ) -> Self {
        Self { prover_buffer, offset, op_type, emu_trace_start, air_instance }
    }
}
/// This is a multithreaded implementation of the Zisk MainSM state machine.
///
/// The MainSM state machine is responsible for orchestrating the execution of the program and
/// processing the inputs generated by the emulator. The MainSM state machine interacts with the
/// secondary state machines to process the inputs generated by the emulator.
pub struct MainSM<F: PrimeField> {
    // Zisk ROM
    zisk_rom: ZiskRom,
    zisk_rom_path: PathBuf,

    // State machines
    mem_proxy: Arc<MemProxy<F>>,
    binary_sm: Arc<BinarySM<F>>,
    arith_sm: Arc<ArithSM>,
}

impl<F: PrimeField> MainSM<F> {
    const MY_NAME: &'static str = "MainSM  ";

    /// Default number of inputs of the main state machine that are accumulated before being
    /// processed
    const BLOCK_SIZE: usize = 2usize.pow(21);
    const NUM_THREADS: usize = 8;

    /// Constructor for the MainSM state machine
    /// Registers the state machine at the WCManager and stores references to the secondary state
    /// machines that directly interact with the MainSM
    /// Returns an Arc to the MainSM state machine
    /// # Arguments
    /// * `rom_path` - Path to the ROM file
    /// * `wcm` - Witness computation manager to register the state machine
    /// * `mem_sm` - Arc to the MemSM state machine
    /// * `binary_sm` - Arc to the BinarySM state machine
    /// * `arith_sm` - Arc to the ArithSM state machine
    /// * `air_ids` - Array of Main Air IDs extracted from the pilout
    /// # Returns
    /// * Arc to the MainSM state machine
    pub fn new(
        rom_path: PathBuf,
        wcm: Arc<WitnessManager<F>>,
        mem_proxy: Arc<MemProxy<F>>,
        binary_sm: Arc<BinarySM<F>>,
        arith_sm: Arc<ArithSM>,
    ) -> Arc<Self> {
        // If rom_path has an .elf extension it must be converted to a ZisK ROM
        let zisk_rom = if rom_path.extension().unwrap() == "elf" {
            // Create an instance of the RISCV -> ZisK program converter
            let rv2zk = Riscv2zisk::new(
                rom_path.display().to_string(),
                String::new(),
                String::new(),
                String::new(),
            );

            // Convert program to rom
            match rv2zk.run() {
                Ok(rom) => rom,
                Err(e) => {
                    panic!("Application error: {}", e);
                }
            }
        } else {
            // TODO - Remove this when the ZisK ROM is able to be loaded from a file
            panic!("ROM file must be an ELF file");
        };

        // TODO - Compute MAX_ACCUMULATED having the num_rows of the Main AIR
        // TODO - If there is more than one Main AIR available, the MAX_ACCUMULATED will be the one
        // with the highest num_rows. It has to be a power of 2.

        let main_sm = Arc::new(Self {
            zisk_rom,
            zisk_rom_path: rom_path.to_path_buf(),
            mem_proxy: mem_proxy.clone(),
            binary_sm: binary_sm.clone(),
            arith_sm: arith_sm.clone(),
        });

        wcm.register_component(main_sm.clone(), Some(MAIN_AIRGROUP_ID), Some(MAIN_AIR_IDS));

        // For all the secondary state machines, register the main state machine as a predecessor
        main_sm.mem_proxy.register_predecessor();
        main_sm.binary_sm.register_predecessor();
        main_sm.arith_sm.register_predecessor();

        main_sm
    }

    /// Executes the MainSM state machine and processes the inputs in batches when the maximum
    /// number of accumulated inputs is reached. The MainSM state machine uses the emulator to
    /// execute the a program and using a callback the main state machine receives batches of
    /// inputs generated by the emulator. The inputs are processed in batches when the maximum
    /// number of accumulated inputs is reached
    /// # Arguments
    /// * `pctx` - Proof context to interact with the proof system
    /// * `ectx` - Execution context to interact with the execution environment
    pub fn execute(
        &self,
        public_inputs_path: &Path,
        pctx: Arc<ProofCtx<F>>,
        ectx: Arc<ExecutionCtx>,
        sctx: Arc<SetupCtx>,
    ) {
        // Create a thread pool to manage the execution of all the state machines related to the
        // execution process
        let pool = ThreadPoolBuilder::new().build().unwrap();

        // Prepare the settings for the emulator
        let emu_options = EmuOptions {
            elf: Some(self.zisk_rom_path.clone().display().to_string()),
            inputs: Some(public_inputs_path.display().to_string()),
            trace_steps: Some(Self::BLOCK_SIZE as u64),
            ..EmuOptions::default()
        };

        // Call emulate with these options
        let public_inputs = {
            // Read inputs data from the provided inputs path
            let path = PathBuf::from(public_inputs_path.display().to_string());
            fs::read(path).expect("Could not read inputs file")
        };

        // During ROM processing, we gather execution data necessary for creating the AIR instances.
        // This data is collected by the emulator and includes the minimal execution trace,
        // along with essential state information of the processor. This ensures that the execution
        // can be reproduced from specific points in the trace to generate the inputs for each state
        // machine. We aim to track the starting point of execution for every N instructions
        // across different operation types. Currently, we are only collecting data for
        // Binary and BinaryE operations.
        let air_main = pctx.pilout.get_air(MAIN_AIRGROUP_ID, MAIN_AIR_IDS[0]);
        let air_binary = pctx.pilout.get_air(BINARY_AIRGROUP_ID, BINARY_AIR_IDS[0]);
        let air_binary_e =
            pctx.pilout.get_air(BINARY_EXTENSION_AIRGROUP_ID, BINARY_EXTENSION_AIR_IDS[0]);

        let mut op_sizes = [0u64; ZISK_OPERATION_TYPE_VARIANTS];
        // The starting points for the Main is allocated using None operation
        op_sizes[ZiskOperationType::None as usize] = air_main.num_rows() as u64;
        op_sizes[ZiskOperationType::Binary as usize] = air_binary.num_rows() as u64;
        op_sizes[ZiskOperationType::BinaryE as usize] = air_binary_e.num_rows() as u64;

        let mut instances_ctx = vec![];
        let mut emu_traces = vec![];
        let mut emu_slices = EmuStartingPoints::default();
        let emu_mem = Mutex::new(Vec::new());

        pool.scope(|scope| {
            Self::execute_mem(scope, &public_inputs, &self.zisk_rom, &emu_mem);

            // Run the emulator in parallel n times to collect execution traces
            // and record the execution starting points for each AIR instance
            timer_start_debug!(PAR_PROCESS_ROM);
            (emu_traces, emu_slices) = ZiskEmulator::par_process_rom::<F>(
                &self.zisk_rom,
                &public_inputs,
                &emu_options,
                Self::NUM_THREADS,
                op_sizes,
            )
            .expect("Error during emulator execution");
            timer_stop_and_log_debug!(PAR_PROCESS_ROM);
        });

        pool.scope(|_| {
            emu_slices.points.sort_by(|a, b| a.op_type.partial_cmp(&b.op_type).unwrap());

            // Once Main, Binary and BinaryE instances are created, we add the Memory instances
            let emu_mem = emu_mem.into_inner().unwrap();

            instances_ctx = Vec::with_capacity(emu_slices.points.len() + emu_mem.len());

            // *******************************************
            // Calculate mem_slices
            let air_mem = pctx.pilout.get_air(MEM_AIRGROUP_ID, MEM_AIR_IDS[0]);

            let chunk_size = air_mem.num_rows() - 1;
            let num_chunks = (emu_mem.len() + chunk_size - 1) / chunk_size;
            emu_mem.par_chunks(chunk_size).enumerate().for_each(|(index, chunk)| {
                // Determine the last element of the previous chunk
                let previous_last = if index == 0 {
                    // If this is the first chunk, get the last element of the vector (circular behavior)
                    emu_mem.last().unwrap()
                } else {
                    // Otherwise, get the last element of the previous chunk
                    &emu_mem[(index - 1) * chunk_size]
                };

                let (buffer, offset) =
                    create_prover_buffer::<F>(&ectx, &sctx, MEM_AIRGROUP_ID, MEM_AIR_IDS[0]);
                self.mem_proxy.prove_instance(
                    chunk,
                    previous_last.clone(),
                    index,
                    index == num_chunks - 1,
                    buffer,
                    offset,
                    pctx.clone(),
                    ectx.clone(),
                    sctx.clone(),
                );

                // Your processing logic goes here
            });
            // *******************************************

            let mut dctx = ectx.dctx.write().unwrap();
            for (idx, emu_slice) in emu_slices.points.iter().enumerate() {
                let (airgroup_id, air_id) = match emu_slice.op_type {
                    ZiskOperationType::None => (MAIN_AIRGROUP_ID, MAIN_AIR_IDS[0]),
                    ZiskOperationType::Binary => (BINARY_AIRGROUP_ID, BINARY_AIR_IDS[0]),
                    ZiskOperationType::BinaryE => {
                        (BINARY_EXTENSION_AIRGROUP_ID, BINARY_EXTENSION_AIR_IDS[0])
                    }
                    _ => panic!("Invalid operation type"),
                };
                dctx.add_instance(airgroup_id, air_id, idx, 1);

                if dctx.is_my_instance(idx) {
                    let (buffer, offset) =
                        create_prover_buffer::<F>(&ectx, &sctx, airgroup_id, air_id);
                    instances_ctx.push(InstanceExtensionCtx::new(
                        buffer,
                        offset,
                        emu_slice.op_type,
                        emu_slice.emu_trace_start.clone(),
                        None,
                    ));
                }
            }
            drop(dctx);
        });

        pool.scope(|scope| {
            instances_ctx.par_iter_mut().enumerate().for_each(|(segment_id, iectx)| {
                match iectx.op_type {
                    ZiskOperationType::None => {
                        self.prove_main(&emu_traces, segment_id, iectx, &pctx);
                    }
                    ZiskOperationType::Binary => {
                        self.prove_binary(&emu_traces, segment_id, iectx, &pctx, scope);
                    }
                    ZiskOperationType::BinaryE => {
                        self.prove_binary_extension(&emu_traces, segment_id, iectx, &pctx, scope);
                    }
                    _ => panic!("Invalid operation type"),
                }
            });

            timer_start_debug!(ADD_INSTANCES_TO_THE_REPO);
            for iectx in instances_ctx {
                if let Some(air_instance) = iectx.air_instance {
                    pctx.air_instance_repo.add_air_instance(air_instance);
                }
            }
            timer_stop_and_log_debug!(ADD_INSTANCES_TO_THE_REPO);

            std::thread::spawn(move || {
                drop(emu_traces);
            });

            // self.mem_sm.unregister_predecessor(scope);
            self.binary_sm.unregister_predecessor(scope);
            // self.arith_sm.register_predecessor(scope);
        });
    }

    fn execute_mem<'a>(
        scope: &rayon::Scope<'a>,
        public_inputs: &'a [u8],
        zisk_rom: &'a ZiskRom,
        emu_mem: &'a Mutex<Vec<ZiskRequiredMemory>>,
    ) {
        scope.spawn(move |_| {
            timer_start_debug!(PAR_PROCESS_ROM_MEM);
            let mut required_mem = ZiskEmulator::par_process_rom_mem::<F>(zisk_rom, public_inputs)
                .expect("Error during emulator execution");
            timer_stop_and_log_debug!(PAR_PROCESS_ROM_MEM);

            timer_start_debug!(MEM_SORT);
            required_mem.sort_by_key(|mem| mem.address);
            timer_stop_and_log_debug!(MEM_SORT);

            println!("Emulator memory usage: {:?}", required_mem.len());
            *emu_mem.lock().unwrap() = required_mem;
        });
    }

    fn prove_main(
        &self,
        vec_traces: &[EmuTrace],
        segment_id: usize,
        iectx: &mut InstanceExtensionCtx<F>,
        pctx: &ProofCtx<F>,
    ) {
        let segment_trace = &vec_traces[segment_id];

        let offset = iectx.offset;
        let air = pctx.pilout.get_air(MAIN_AIRGROUP_ID, MAIN_AIR_IDS[0]);
        let filled = segment_trace.steps.len();
        info!(
            "{}: ··· Creating Main segment #{} [{} / {} rows filled {:.2}%]",
            Self::MY_NAME,
            segment_id,
            filled,
            air.num_rows(),
            filled as f64 / air.num_rows() as f64 * 100.0
        );

        let mut emu = Emu::from_emu_trace_start(&self.zisk_rom, &segment_trace.start);

        let total_steps = segment_trace.steps.len();
        const CHUNK_SIZE: usize = 4096;
        let mut tmp_trace = Main0Trace::<F>::new(CHUNK_SIZE);

        let main_first_segment = F::from_bool(segment_id == 0);
        let main_last_segment = F::from_bool(segment_id == vec_traces.len() - 1);
        let main_segment = F::from_canonical_usize(segment_id);

        let mut last_row = Main0Row::<F>::default();
        for chunk_start in (0..air.num_rows()).step_by(CHUNK_SIZE) {
            // process the steps of the chunk
            let start_pos_abs = std::cmp::min(chunk_start, total_steps);
            let end_pos_abs = (chunk_start + CHUNK_SIZE).min(total_steps);
            for (i, step) in segment_trace.steps[start_pos_abs..end_pos_abs].iter().enumerate() {
                tmp_trace[i] = emu.step_slice_full_trace(step);
                tmp_trace[i].main_first_segment = main_first_segment;
                tmp_trace[i].main_last_segment = main_last_segment;
                tmp_trace[i].main_segment = main_segment;
            }

            // if there are steps in the chunk update last row
            if end_pos_abs - start_pos_abs > 0 {
                last_row = tmp_trace[end_pos_abs - start_pos_abs - 1];
            }

            // if there are less steps than the chunk size, fill the rest with the
            // last row
            for i in (end_pos_abs - start_pos_abs)..CHUNK_SIZE {
                tmp_trace[i] = last_row;
            }

            //copy the chunk to the prover buffer
            let tmp_buffer = tmp_trace.buffer.as_mut().unwrap();
            let buffer_offset_chunk = offset as usize + chunk_start * Main0Row::<F>::ROW_SIZE;
            iectx.prover_buffer[buffer_offset_chunk..buffer_offset_chunk + tmp_buffer.len()]
                .copy_from_slice(tmp_buffer);
        }

        let buffer = std::mem::take(&mut iectx.prover_buffer);
        iectx.air_instance =
            Some(AirInstance::new(MAIN_AIRGROUP_ID, MAIN_AIR_IDS[0], Some(segment_id), buffer));
    }

    fn prove_binary(
        &self,
        vec_traces: &[EmuTrace],
        segment_id: usize,
        iectx: &mut InstanceExtensionCtx<F>,
        pctx: &ProofCtx<F>,
        scope: &rayon::Scope,
    ) {
        let air = pctx.pilout.get_air(BINARY_AIRGROUP_ID, BINARY_AIR_IDS[0]);

        timer_start_debug!(PROCESS_BINARY);
        let inputs = ZiskEmulator::process_slice_required::<F>(
            &self.zisk_rom,
            vec_traces,
            iectx.op_type,
            &iectx.emu_trace_start,
            air.num_rows(),
        );
        timer_stop_and_log_debug!(PROCESS_BINARY);

        timer_start_debug!(PROVE_BINARY);
        self.binary_sm.prove_instance(inputs, false, &mut iectx.prover_buffer, iectx.offset, scope);
        timer_stop_and_log_debug!(PROVE_BINARY);

        timer_start_debug!(CREATE_AIR_INSTANCE);
        let buffer = std::mem::take(&mut iectx.prover_buffer);
        iectx.air_instance =
            Some(AirInstance::new(BINARY_AIRGROUP_ID, BINARY_AIR_IDS[0], Some(segment_id), buffer));
        timer_stop_and_log_debug!(CREATE_AIR_INSTANCE);
    }

    fn prove_binary_extension(
        &self,
        vec_traces: &[EmuTrace],
        segment_id: usize,
        iectx: &mut InstanceExtensionCtx<F>,
        pctx: &ProofCtx<F>,
        scope: &rayon::Scope,
    ) {
        let air = pctx.pilout.get_air(BINARY_EXTENSION_AIRGROUP_ID, BINARY_EXTENSION_AIR_IDS[0]);

        let inputs = ZiskEmulator::process_slice_required::<F>(
            &self.zisk_rom,
            vec_traces,
            iectx.op_type,
            &iectx.emu_trace_start,
            air.num_rows(),
        );

        self.binary_sm.prove_instance(inputs, true, &mut iectx.prover_buffer, iectx.offset, scope);

        let buffer = std::mem::take(&mut iectx.prover_buffer);
        iectx.air_instance = Some(AirInstance::new(
            BINARY_EXTENSION_AIRGROUP_ID,
            BINARY_EXTENSION_AIR_IDS[0],
            Some(segment_id),
            buffer,
        ));
    }
}

impl<F: PrimeField> WitnessComponent<F> for MainSM<F> {}
