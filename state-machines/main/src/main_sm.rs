use log::{debug, info, trace};
use p3_field::{AbstractField, PackedValue};

use rayon::{Scope, ThreadPoolBuilder};
use std::{
    fs, mem,
    path::{Path, PathBuf},
    sync::{Arc, Mutex},
};
use zisk_core::{Riscv2zisk, ZiskRom};

use proofman::WitnessManager;
use proofman_common::{AirInstanceCtx, ExecutionCtx, ProofCtx};

use zisk_pil::{Main0Row, Main0Trace, MAIN_AIR_IDS, MAIN_SUBPROOF_ID};
use ziskemu::{EmuFullTraceStep, EmuOptions, EmuTrace, Emulator, ZiskEmulator};

use proofman::WitnessComponent;
use sm_arith::ArithSM;
use sm_mem::MemSM;

/// This is a multithreaded implementation of the Zisk MainSM state machine.
/// The MainSM state machine is responsible for orchestrating the execution of the program and
/// processing the inputs generated by the emulator. The MainSM state machine interacts with the
/// secondary state machines to process the inputs generated by the emulator.
pub struct MainSM<F> {
    zisk_rom: ZiskRom,
    zisk_rom_path: PathBuf,
    // Main proving key path
    main_pk: PathBuf,
    // Inputs accumulator from the emulator
    callback_inputs: Arc<Mutex<Vec<EmuFullTraceStep<F>>>>,
    //State machines
    arith_sm: Arc<ArithSM>,
    mem_sm: Arc<MemSM>,
}

impl<'a, F: AbstractField + Copy + Send + Sync + 'static> MainSM<F> {
    const MY_NAME: &'static str = "MainSM  ";

    /// Default number of inputs of the main state machine that are accumulated before being
    /// processed
    const CALLBACK_SIZE: usize = 2usize.pow(16);
    const MAX_ACCUMULATED: usize = 2usize.pow(21);

    /// Constructor for the MainSM state machine
    /// Registers the state machine at the WCManager and stores references to the secondary state
    /// machines that directly interact with the MainSM
    /// Returns an Arc to the MainSM state machine
    /// # Arguments
    /// * `wcm` - WCManager to register the state machine
    /// * `mem_sm` - Arc to the MemSM state machine
    /// * `arith_sm` - Arc to the ArithSM state machine
    /// * `air_ids` - Array of Main Air IDs extracted from the pilout
    /// * `max_accumulated` - Maximum number of inputs to accumulate before processing
    /// # Preconditions
    /// * The maximum number of accumulated inputs must be greater than 0
    /// # Returns
    /// * Arc to the MainSM state machine
    pub fn new(
        rom_path: &Path,
        proving_key_path: &PathBuf,
        wcm: &mut WitnessManager<F>,
        mem_sm: Arc<MemSM>,
        arith_sm: Arc<ArithSM>,
        air_ids: &[usize],
    ) -> Arc<Self> {
        // Check if the Main proving key path exists
        let mut main_pk = proving_key_path.clone();
        main_pk.push("build");
        main_pk.push("FibonacciSquare"); // TODO Change this to the correct path when generated

        if !main_pk.exists() {
            panic!("Main proving key path does not exist: {:?}", proving_key_path);
        }

        // If rom_path has an .elf extension it must be converted to a ZisK ROM
        let mut zisk_rom = if rom_path.extension().unwrap() == "elf" {
            // Create an instance of the RISCV -> ZisK program converter
            let rv2zk = Riscv2zisk::new(
                rom_path.display().to_string(),
                String::new(),
                String::new(),
                String::new(),
            );

            // Convert program to rom
            match rv2zk.run() {
                Ok(rom) => rom,
                Err(e) => {
                    panic!("Application error: {}", e);
                }
            }
        } else {
            // TODO - Remove this when the ZisK ROM is able to be loaded from a file
            panic!("ROM file must be an ELF file");
        };

        let mut callback_inputs = Vec::with_capacity(Self::MAX_ACCUMULATED);

        let main = Arc::new(Self {
            zisk_rom,
            zisk_rom_path: rom_path.to_path_buf(),
            mem_sm,
            arith_sm,
            callback_inputs: Arc::new(Mutex::new(callback_inputs)),
            main_pk,
        });

        wcm.register_component(main.clone() as Arc<dyn WitnessComponent<F>>, Some(air_ids));

        main
    }

    /// Executes the MainSM state machine and processes the inputs in batches when the maximum
    /// number of accumulated inputs is reached. The MainSM state machine uses the emulator to
    /// execute the a program and using a callback the main state machine receives batches of
    /// inputs generated by the emulator. The inputs are processed in batches when the maximum
    /// number of accumulated inputs is reached
    /// # Arguments
    /// * `pctx` - Proof context to interact with the proof system
    /// * `ectx` - Execution context to interact with the execution environment
    pub fn execute(
        &self,
        public_inputs_path: &Path,
        pctx: &mut ProofCtx<F>,
        ectx: &mut ExecutionCtx,
    ) {
        // Create a thread pool to manage the execution of all the state machines related to the
        // execution process
        let pool = ThreadPoolBuilder::new().build().unwrap();

        // Prepare the settings for the emulator
        let emulator_options = EmuOptions {
            elf: Some(self.zisk_rom_path.clone().display().to_string()),
            inputs: Some(public_inputs_path.display().to_string()),
            trace_steps: Some(Self::CALLBACK_SIZE as u64),
            ..EmuOptions::default()
        };

        // Call emulate with these options
        let zisk_emulator = ZiskEmulator;

        let mut public_inputs = {
            // Read inputs data from the provided inputs path
            let path = PathBuf::from(public_inputs_path.display().to_string());
            fs::read(path).expect("Could not read inputs file")
        };

        // Execute the emulator inside a thread
        pool.scope(|scope| {
            // Wrap the callback to capture the scope variable
            let callback = |emu_traces: EmuTrace| {
                self.emulator_callback(&self.zisk_rom, emu_traces, scope, pctx, ectx)
            };

            let result = ZiskEmulator::process_rom(
                &self.zisk_rom,
                &public_inputs,
                &emulator_options,
                Some(Box::new(callback)),
            );

            // Eval the return value of the emulator to launch a panic if an error occurred
            if let Err(e) = result {
                panic!("Error during emulator execution: {:?}", e);
            }
        });

        // Terminate the state machines with the remaining inputs
        if let Ok(mut inputs) = self.callback_inputs.lock() {
            if !inputs.is_empty() {
                let remaining_inputs = std::mem::take(&mut *inputs);
                pool.scope(|scope| {
                    scope.spawn(move |scope| {
                        Self::prove(&self.zisk_rom, remaining_inputs, pctx, ectx);
                    });
                });
            }
        }
    }

    // Callback method to process the inputs generated by the emulator
    #[inline(always)]
    fn emulator_callback(
        &'a self,
        zisk_rom: &'a ZiskRom,
        emu_traces: EmuTrace,
        scope: &Scope<'a>,
        pctx: &'a ProofCtx<F>,
        ectx: &'a ExecutionCtx,
    ) {
        scope.spawn(move |scope| {
            let mut expanded_emu_traces =
                match ZiskEmulator::process_slice::<F>(zisk_rom, &emu_traces) {
                    Ok(slice) => slice,
                    Err(e) => panic!("Error processing slice: {:?}", e),
                };

            let mut inputs = self.callback_inputs.lock().unwrap();

            while !expanded_emu_traces.is_empty() {
                let num_to_drain =
                    expanded_emu_traces.len().min(Self::MAX_ACCUMULATED - inputs.len());

                let mut drained = expanded_emu_traces.drain(..num_to_drain).collect::<Vec<_>>();
                inputs.append(&mut drained);

                if inputs.len() == Self::MAX_ACCUMULATED {
                    let _inputs =
                        mem::replace(&mut *inputs, Vec::with_capacity(Self::MAX_ACCUMULATED));

                    scope.spawn(move |scope| {
                        Self::prove(zisk_rom, _inputs, pctx, ectx);
                    });
                }
            }
        });
    }

    /// Proves a batch of inputs
    /// When the maximum number of accumulated inputs is reached, the MainSM state machine processes
    /// the inputs in batches. The inputs are processed in parallel using the thread pool
    /// # Arguments
    /// * `inputs` - Vector of EmuTrace inputs to prove
    /// * `pctx` - Proof context to interact with the proof system
    /// * `ectx` - Execution context to interact with the execution environment
    #[inline(always)]
    fn prove(
        zisk_rom: &ZiskRom,
        inputs: Vec<Main0Row<F>>,
        pctx: &ProofCtx<F>,
        ectx: &ExecutionCtx,
    ) {
        info!("{}: ··· generating new SM Main segment with {} inputs", Self::MY_NAME, inputs.len());

        // Compute buffer size using the BufferAllocator
        // let air_setup_path = Path::new(
        //     "../pil2-components/test/fibonacci/build_x/provingKey/build/FibonacciSquare/airs/
        // FibonacciSquare_0/air/", );

        // let buffer_size = ectx.buffer_allocator.as_ref().get_buffer_info(air_setup_path);
        // if let Err(e) = buffer_size {
        //     panic!("Error getting buffer size: {:?}", e);
        // }

        // Option 1: Create a new buffer to allocate all stark data and copy the data into it
        // let num_rows = inputs.len().next_power_of_two();
        // let mut main_trace = Box::new(Main0Trace::<F>::new(num_rows));

        // if inputs.len() < num_rows {
        //     main_trace.slice[..inputs.len()].copy_from_slice(&inputs);
        // } else {
        //     main_trace.slice.copy_from_slice(&inputs);
        // }

        // Option 2: Wrap the existing vector to create a Main0Trace and avoid to copy the data
        let main_trace = Main0Trace::<F>::map_row_vec(inputs).unwrap();

        let mut air_instances = pctx.air_instances.write().unwrap();

        air_instances.push(AirInstanceCtx {
            air_group_id: MAIN_SUBPROOF_ID[0],
            air_id: MAIN_AIR_IDS[0],
            buffer: Some(main_trace.buffer.unwrap()),
        });
    }
}

impl<F> WitnessComponent<F> for MainSM<F> {
    fn calculate_witness(
        &self,
        stage: u32,
        air_instance: usize,
        pctx: &mut ProofCtx<F>,
        ectx: &ExecutionCtx,
    ) {
    }
}
