use log::{debug, info, trace};
use p3_field::AbstractField;

use rayon::{Scope, ThreadPoolBuilder};
use std::{
    path::{Path, PathBuf},
    sync::{Arc, Mutex},
};

use proofman::WitnessManager;
use proofman_common::{AirInstance, ExecutionCtx, ProofCtx};

use zisk_pil::Main0Trace;
use ziskemu::{EmuOptions, EmuTrace, Emulator, ZiskEmulator};

use sm_arith::ArithSM;
use sm_mem::MemSM;
use witness_helpers::WitnessComponent;

/// This is a multithreaded implementation of the Zisk MainSM state machine.
/// The MainSM state machine is responsible for orchestrating the execution of the program and
/// processing the inputs generated by the emulator. The MainSM state machine interacts with the
/// secondary state machines to process the inputs generated by the emulator.
pub struct MainSM {
    rom_path: PathBuf,
    main_pk: PathBuf,
    arith_sm: Arc<ArithSM>,
    mem_sm: Arc<MemSM>,
    inputs: Arc<Mutex<Vec<EmuTrace>>>,
    // Main proving key path
}

impl MainSM {
    const MY_NAME: &'static str = "MainSM  ";

    /// Default number of inputs of the main state machine that are accumulated before being
    /// processed
    const MAX_ACCUMULATED: usize = 2_097_152;

    /// Constructor for the MainSM state machine
    /// Registers the state machine at the WCManager and stores references to the secondary state
    /// machines that directly interact with the MainSM
    /// Returns an Arc to the MainSM state machine
    /// # Arguments
    /// * `wcm` - WCManager to register the state machine
    /// * `mem_sm` - Arc to the MemSM state machine
    /// * `arith_sm` - Arc to the ArithSM state machine
    /// * `air_ids` - Array of Main Air IDs extracted from the pilout
    /// * `max_accumulated` - Maximum number of inputs to accumulate before processing
    /// # Preconditions
    /// * The maximum number of accumulated inputs must be greater than 0
    /// # Returns
    /// * Arc to the MainSM state machine
    pub fn new<F>(
        rom_path: &Path,
        proving_key_path: &PathBuf,
        wcm: &mut WitnessManager<F>,
        mem_sm: Arc<MemSM>,
        arith_sm: Arc<ArithSM>,
        air_ids: &[usize],
    ) -> Arc<Self> {
        // Check if the Main proving key path exists
        let mut main_pk = proving_key_path.clone();
        main_pk.push("build");
        main_pk.push("FibonacciSquare"); // TODO Change this to the correct path when generated

        if !main_pk.exists() {
            panic!("Main proving key path does not exist: {:?}", proving_key_path);
        }

        // TODO - if ROM has .elf extension, then use convert it to a ZiskROM, otherwise it will be
        // loaded as a ZiskROM

        let main = Arc::new(Self {
            rom_path: rom_path.to_path_buf(),
            mem_sm,
            arith_sm,
            inputs: Arc::new(Mutex::new(Vec::new())),
            main_pk,
        });

        wcm.register_component(main.clone() as Arc<dyn WitnessComponent<F>>, Some(air_ids));

        main
    }

    /// Executes the MainSM state machine and processes the inputs in batches when the maximum
    /// number of accumulated inputs is reached. The MainSM state machine uses the emulator to
    /// execute the a program and using a callback the main state machine receives batches of
    /// inputs generated by the emulator. The inputs are processed in batches when the maximum
    /// number of accumulated inputs is reached
    /// # Arguments
    /// * `pctx` - Proof context to interact with the proof system
    /// * `ectx` - Execution context to interact with the execution environment
    pub fn execute<F: AbstractField + Send + Sync>(
        &self,
        public_inputs_path: &Path,
        pctx: &mut ProofCtx<F>,
        ectx: &mut ExecutionCtx,
    ) {
        trace!("{}: --> execute()", Self::MY_NAME);

        // Create a thread pool to manage the execution of all the state machines related to the
        // execution process
        let pool = ThreadPoolBuilder::new().build().unwrap();

        // Prepare the settings for the emulator
        let emulator_options = EmuOptions {
            elf: Some(self.rom_path.clone().display().to_string()),
            inputs: Some(public_inputs_path.display().to_string()),
            trace_steps: Some(Self::MAX_ACCUMULATED as u64),
            ..EmuOptions::default()
        };

        // Call emulate with these options
        let zisk_emulator = ZiskEmulator;

        // Execute the emulator inside a thread
        pool.scope(|scope| {
            // Wrap the callback to capture the scope variable
            let callback =
                |inputs: Vec<EmuTrace>| self.emulator_callback(inputs, scope, pctx, ectx);
            let result = zisk_emulator.emulate(&emulator_options, Some(Box::new(callback)));

            // Eval the return value of the emulator to launch a panic if an error occurred
            if let Err(e) = result {
                panic!("Error during emulator execution: {:?}", e);
            }
        });

        // Terminate the state machines with the remaining inputs
        if let Ok(mut inputs) = self.inputs.lock() {
            if !inputs.is_empty() {
                let remaining_inputs = std::mem::take(&mut *inputs);
                pool.scope(|scope| {
                    scope.spawn(move |scope| {
                        Self::prove(remaining_inputs, pctx, ectx);
                    });
                });
            }
        }

        trace!("{}: <-- execute()", Self::MY_NAME);
    }

    // Callback method to process the inputs generated by the emulator
    fn emulator_callback<'a, F: AbstractField + Send + Sync>(
        &self,
        emu_inputs: Vec<EmuTrace>,
        scope: &Scope<'a>,
        pctx: &'a ProofCtx<F>,
        ectx: &'a ExecutionCtx,
    ) {
        let self_inputs = self.inputs.clone();

        scope.spawn(move |scope| {
            if let Ok(mut inputs) = self_inputs.lock() {
                inputs.extend(emu_inputs);

                while inputs.len() >= Self::MAX_ACCUMULATED {
                    let inputs_batch = inputs.drain(..Self::MAX_ACCUMULATED).collect::<Vec<_>>();

                    scope.spawn(move |_| {
                        Self::prove(inputs_batch, pctx, ectx);
                    });
                }
            }
        });
    }

    /// Proves a batch of inputs
    /// When the maximum number of accumulated inputs is reached, the MainSM state machine processes
    /// the inputs in batches. The inputs are processed in parallel using the thread pool
    /// # Arguments
    /// * `inputs` - Vector of EmuTrace inputs to prove
    /// * `pctx` - Proof context to interact with the proof system
    /// * `ectx` - Execution context to interact with the execution environment
    fn prove<F: AbstractField>(inputs: Vec<EmuTrace>, pctx: &ProofCtx<F>, ectx: &ExecutionCtx) {
        info!("{}: ··· prove_inputs_batch() with {} inputs", Self::MY_NAME, inputs.len());

        // Capture inputs.len() and calculate the next power of two for the number of rows needed
        let num_rows = inputs.len().next_power_of_two();

        // Use BufferAllocator to get the buffer size and create a new trace segment for the main
        let size = ectx.buffer_allocator.as_ref().get_buffer_info(Path::new("../pil2-components/test/fibonacci/build_x/provingKey/build/FibonacciSquare/airs/FibonacciSquare_0/air/"));
        if let Err(e) = size {
            panic!("Error getting buffer size: {:?}", e);
        }

        // TODO - Create a new buffer using the size and map the trace segment over the buffer using
        // from_ptr TODO - At the time being we are using a fixed size for the trace segment
        // Create a new trace segment for the main
        let mut trace = Main0Trace::<F>::new(num_rows);

        // Create the values for the trace segment
        for (idx, input) in inputs.iter().enumerate() {
            // How to handle a[2] for input.a ?
            trace.a[0][idx] = F::from_canonical_u64(input.a);
            trace.b[0][idx] = F::from_canonical_u64(input.b);
            trace.c[0][idx] = F::from_canonical_u64(input.c);
            trace.last_c[0][idx] =
                if idx == 0 { F::zero() } else { trace.last_c[0][idx - 1].clone() };
            trace.flag[idx] = if input.flag { F::one() } else { F::zero() };

            trace.pc[idx] = F::from_canonical_u64(input.pc);

            //trace.a_src_imm[idx] =
            //trace.a_src_mem[idx] =
            //trace.a_offset_imm0[idx] =

            trace.sp[idx] = F::from_canonical_u64(input.sp);

            // trace.a_src_sp[idx] = F::zero();
            // trace.a_use_sp_imm1[idx] = F::zero();
            // trace.a_src_step[idx] = F::zero();

            // trace.b_src_imm[idx] = F::zero();
            // trace.b_src_mem[idx] = F::zero();
            // trace.b_offset_imm0[idx] = F::zero();
            // trace.b_use_sp_imm1[idx] = F::zero();
            // trace.b_src_ind[idx] = F::zero();

            // trace.ind_width[idx] = F::zero();

            // trace.is_external_op[idx] = F::zero();

            trace.op[idx] = F::from_canonical_u8(input.opcode);

            // trace.store_ra[idx] = F::zero();
            // trace.store_mem[idx] = F::zero();
            // trace.store_ind[idx] = F::zero();
            // trace.store_offset[idx] = F::zero();
            // trace.set_pc[idx] = F::zero();
            // trace.store_use_sp[idx] = F::zero();
            // trace.set_sp[idx] = F::zero();
            // trace.inc_sp[idx] = F::zero();
            // trace.jmp_offset1[idx] = F::zero();
            // trace.jmp_offset2[idx] = F::zero();
        }

        // Add trace to instances vector
        // pctx.air_instances.push(AirInstanceCtx {
        //     air_group_id: MAIN_AIRGROUP_IDS[0],
        //     air_id: MAIN_AIR_IDS[0],
        //     buffer: trace});

        // TODO Ask Jordi about this
    }
}

impl<F> WitnessComponent<F> for MainSM {
    fn calculate_witness(
        &self,
        stage: u32,
        air_instance: &AirInstance,
        pctx: &mut ProofCtx<F>,
        ectx: &ExecutionCtx,
    ) {
    }

    fn suggest_plan(&self, _ectx: &mut ExecutionCtx) {}
}
