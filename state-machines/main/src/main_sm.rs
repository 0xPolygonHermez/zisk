use log::info;
use p3_field::AbstractField;

use rayon::{Scope, ThreadPoolBuilder};
use sm_binary::BinarySM;
use std::{
    fs, mem,
    path::{Path, PathBuf},
    sync::{Arc, Mutex},
};
use zisk_core::{Riscv2zisk, ZiskRequired, ZiskRom};

use proofman::WitnessManager;
use proofman_common::{ExecutionCtx, ProofCtx, SetupCtx};

use zisk_pil::{Main0Row, Main0Trace, MAIN_AIR_IDS, MAIN_SUBPROOF_ID};
use ziskemu::{EmuFullTraceStep, EmuOptions, EmuTrace, ZiskEmulator};

use proofman::WitnessComponent;
use sm_arith::ArithSM;
use sm_common::{Provable, ThreadController};
use sm_mem::MemSM;

#[derive(Default)]
pub struct MainAirSegment<F> {
    pub segment_id: u32,
    pub filled_inputs: usize,
    pub inputs: Vec<EmuFullTraceStep<F>>,
}

impl<F: Default + Clone> MainAirSegment<F> {
    pub fn new(segment_id: u32, inputs_size: usize) -> Self {
        Self { segment_id, filled_inputs: 0, inputs: vec![Main0Row::<F>::default(); inputs_size] }
    }
}

/// This is a multithreaded implementation of the Zisk MainSM state machine.
///
/// The MainSM state machine is responsible for orchestrating the execution of the program and
/// processing the inputs generated by the emulator. The MainSM state machine interacts with the
/// secondary state machines to process the inputs generated by the emulator.
pub struct MainSM<F> {
    // Thread controller to manage the execution of the state machines
    threads_controller: Arc<ThreadController>,
    // Zisk ROM
    zisk_rom: ZiskRom,
    zisk_rom_path: PathBuf,
    // Inputs accumulator from the emulator
    callback_inputs: Arc<Mutex<Vec<MainAirSegment<F>>>>,
    //State machines
    mem_sm: Arc<MemSM>,
    binary_sm: Arc<BinarySM>,
    arith_sm: Arc<ArithSM>,
}

impl<'a, F: AbstractField + Default + Copy + Send + Sync + 'static> MainSM<F> {
    const MY_NAME: &'static str = "MainSM  ";

    /// Default number of inputs of the main state machine that are accumulated before being
    /// processed
    const CALLBACK_SIZE: usize = 2usize.pow(16);
    const MAX_ACCUMULATED: usize = 2usize.pow(21);

    /// Constructor for the MainSM state machine
    /// Registers the state machine at the WCManager and stores references to the secondary state
    /// machines that directly interact with the MainSM
    /// Returns an Arc to the MainSM state machine
    /// # Arguments
    /// * `rom_path` - Path to the ROM file
    /// * `wcm` - Witness computation manager to register the state machine
    /// * `mem_sm` - Arc to the MemSM state machine
    /// * `binary_sm` - Arc to the BinarySM state machine
    /// * `arith_sm` - Arc to the ArithSM state machine
    /// * `air_ids` - Array of Main Air IDs extracted from the pilout
    /// # Returns
    /// * Arc to the MainSM state machine
    pub fn new(
        rom_path: &Path,
        wcm: &mut WitnessManager<F>,
        mem_sm: Arc<MemSM>,
        binary_sm: Arc<BinarySM>,
        arith_sm: Arc<ArithSM>,
        air_ids: &[usize],
    ) -> Arc<Self> {
        // If rom_path has an .elf extension it must be converted to a ZisK ROM
        let zisk_rom = if rom_path.extension().unwrap() == "elf" {
            // Create an instance of the RISCV -> ZisK program converter
            let rv2zk = Riscv2zisk::new(
                rom_path.display().to_string(),
                String::new(),
                String::new(),
                String::new(),
            );

            // Convert program to rom
            match rv2zk.run() {
                Ok(rom) => rom,
                Err(e) => {
                    panic!("Application error: {}", e);
                }
            }
        } else {
            // TODO - Remove this when the ZisK ROM is able to be loaded from a file
            panic!("ROM file must be an ELF file");
        };

        // TODO - Compute MAX_ACCUMULATED having the num_rows of the Main AIR
        // TODO - If there is more than one Main AIR available, the MAX_ACCUMULATED will be the one
        // with the highest num_rows. It has to be a power of 2.

        let main_sm = Arc::new(Self {
            threads_controller: Arc::new(ThreadController::new()),
            zisk_rom,
            zisk_rom_path: rom_path.to_path_buf(),
            mem_sm: mem_sm.clone(),
            binary_sm: binary_sm.clone(),
            arith_sm: arith_sm.clone(),
            callback_inputs: Arc::new(Mutex::new(Vec::new())),
        });

        wcm.register_component(main_sm.clone(), Some(air_ids));

        // For all the secondary state machines, register the main state machine as a predecessor
        main_sm.mem_sm.register_predecessor();
        main_sm.binary_sm.register_predecessor();
        main_sm.arith_sm.register_predecessor();

        main_sm
    }

    /// Executes the MainSM state machine and processes the inputs in batches when the maximum
    /// number of accumulated inputs is reached. The MainSM state machine uses the emulator to
    /// execute the a program and using a callback the main state machine receives batches of
    /// inputs generated by the emulator. The inputs are processed in batches when the maximum
    /// number of accumulated inputs is reached
    /// # Arguments
    /// * `pctx` - Proof context to interact with the proof system
    /// * `ectx` - Execution context to interact with the execution environment
    pub fn execute(
        &self,
        public_inputs_path: &Path,
        pctx: &mut ProofCtx<F>,
        ectx: &mut ExecutionCtx,
        _sctx: &SetupCtx,
    ) {
        // Create a thread pool to manage the execution of all the state machines related to the
        // execution process
        let pool = ThreadPoolBuilder::new().build().unwrap();

        // Prepare the settings for the emulator
        let emulator_options = EmuOptions {
            elf: Some(self.zisk_rom_path.clone().display().to_string()),
            inputs: Some(public_inputs_path.display().to_string()),
            trace_steps: Some(Self::CALLBACK_SIZE as u64),
            ..EmuOptions::default()
        };

        // Call emulate with these options
        let public_inputs = {
            // Read inputs data from the provided inputs path
            let path = PathBuf::from(public_inputs_path.display().to_string());
            fs::read(path).expect("Could not read inputs file")
        };

        // Execute the emulator inside a thread
        pool.scope(|scope| {
            // Wrap the callback to capture the scope variable
            let callback = |emu_traces: EmuTrace| {
                self.emulator_callback(&self.zisk_rom, emu_traces, scope, pctx, ectx)
            };

            let result = ZiskEmulator::process_rom(
                &self.zisk_rom,
                &public_inputs,
                &emulator_options,
                Some(Box::new(callback)),
            );

            self.threads_controller.wait_for_threads();

            // Unregister main state machine as a predecessor for all the secondary state machines
            self.mem_sm.unregister_predecessor(scope);
            self.binary_sm.unregister_predecessor(scope);
            self.arith_sm.unregister_predecessor(scope);

            // Eval the return value of the emulator to launch a panic if an error occurred
            if let Err(e) = result {
                panic!("Error during emulator execution: {:?}", e);
            }
        });

        // Terminate the state machines with the remaining inputs
        let mut callback_inputs = self.callback_inputs.lock().unwrap();
        let last_air_segment = callback_inputs.last_mut().unwrap();

        if !last_air_segment.inputs.is_empty() {
            let air_segment = mem::take(last_air_segment);
            pool.scope(|scope| {
                scope.spawn(move |_| {
                    Self::create_air_instance(air_segment, pctx, ectx);
                });
            });
        }

        // TODO: SET LAST MAIN SEGMENT!!
    }

    // Callback method to process the inputs generated by the emulator
    #[inline(always)]
    fn emulator_callback(
        &'a self,
        zisk_rom: &'a ZiskRom,
        emu_traces: EmuTrace,
        scope: &Scope<'a>,
        pctx: &'a ProofCtx<F>,
        ectx: &'a ExecutionCtx,
    ) {
        // Compute the AIR segment and the position where the current EmuTrace should be placed
        let air_step = emu_traces.start.step as f64 / Self::MAX_ACCUMULATED as f64;
        let air_id = air_step.floor() as usize;
        let pos_id =
            (air_step.fract() * Self::MAX_ACCUMULATED as f64 / Self::CALLBACK_SIZE as f64) as usize;

        // As this calls are received sequentially, when pos_id is 0, a new segment is created
        if pos_id == 0 {
            self.callback_inputs
                .lock()
                .unwrap()
                .push(MainAirSegment::new(air_id as u32, Self::MAX_ACCUMULATED));
        }

        self.threads_controller.add_working_thread();

        scope.spawn(move |scope| {
            // To go faster, we receive from the simulator callback a tiny trace that we are going
            // to process to get the full trace. This is done to avoid the overhead of processing
            // the full trace in the simulator callback and now can be parallelized.
            let emu_slice = match ZiskEmulator::process_slice::<F>(zisk_rom, &emu_traces) {
                Ok(slice) => slice,
                Err(e) => panic!("Error processing slice: {:?}", e),
            };

            let len = emu_slice.full_trace.len();
            let source_iter = emu_slice.full_trace.into_iter();

            let mut inputs = self.callback_inputs.lock().unwrap();
            let air_segment = &mut inputs[air_id];
            air_segment.inputs.splice(
                pos_id * Self::CALLBACK_SIZE..(pos_id + 1) * Self::CALLBACK_SIZE,
                source_iter,
            );
            air_segment.filled_inputs += len;
            assert!(
                air_segment.filled_inputs <= Self::MAX_ACCUMULATED,
                "Too many inputs in a Main AIR segment"
            );

            self.prove(emu_slice.required, ectx, scope);

            // As CALLBACK_SIZE is a power of 2, we can check if the segment is full by checking
            if air_segment.filled_inputs == Self::MAX_ACCUMULATED {
                let air_segment = mem::take(air_segment);
                scope.spawn(move |_| {
                    Self::create_air_instance(air_segment, pctx, ectx);
                });
            }
        });
    }

    /// Proves a batch of inputs
    /// When the maximum number of accumulated inputs is reached, the MainSM state machine processes
    /// the inputs in batches. The inputs are processed in parallel using the thread pool
    /// # Arguments
    /// * `inputs` - Vector of EmuTrace inputs to prove
    /// * `pctx` - Proof context to interact with the proof system
    /// * `ectx` - Execution context to interact with the execution environment
    #[inline(always)]
    fn create_air_instance(
        air_segment: MainAirSegment<F>,
        pctx: &ProofCtx<F>,
        ectx: &ExecutionCtx,
    ) {
        info!(
            "{}: ··· Creating Main segment #{} [{} inputs]",
            Self::MY_NAME,
            air_segment.segment_id,
            air_segment.filled_inputs
        );

        // Compute buffer size using the BufferAllocator
        let (buffer_size, offsets) =
            match ectx.buffer_allocator.as_ref().get_buffer_info("Main".into(), MAIN_AIR_IDS[0]) {
                Ok((size, offsets)) => (size, offsets),
                Err(err) => {
                    // Handle the error case, for example:
                    panic!("Error getting buffer info: {}", err);
                }
            };

        // Option 1: Create a new buffer to allocate all stark data and copy the data into it
        // let num_rows = inputs.len().next_power_of_two();
        // let mut main_trace = Box::new(Main0Trace::<F>::new(num_rows));

        // if air_segment.inputs.len() < num_rows {
        //     main_trace.slice[..air_segment.inputs.len()].copy_from_slice(&air_segment.inputs);
        // } else {
        //     main_trace.slice.copy_from_slice(&air_segment.inputs);
        // }

        // Option 2: Wrap the existing vector to create a Main0Trace and avoid to copy the data
        let mut main_trace = Main0Trace::<F>::map_row_vec(air_segment.inputs).unwrap();

        for i in air_segment.filled_inputs..main_trace.num_rows() {
            main_trace[i].flag = F::from_canonical_usize(1);
        }

        // TODO: Do it in parallel
        let main_first_segment = F::from_bool(air_segment.segment_id == 0);
        let main_segment = F::from_canonical_usize(air_segment.segment_id as usize);
        for i in 0..main_trace.num_rows() {
            main_trace[i].main_first_segment = main_first_segment;
            main_trace[i].main_segment = main_segment;
        }

        let main_trace_buffer = main_trace.buffer.unwrap();

        let mut buffer: Vec<F> = vec![F::zero(); buffer_size as usize];

        buffer[offsets[0] as usize..offsets[0] as usize + main_trace_buffer.len()]
            .copy_from_slice(&main_trace_buffer);

        pctx.add_air_instance_ctx(MAIN_SUBPROOF_ID[0], MAIN_AIR_IDS[0], Some(buffer));
    }

    /// Proves a batch of inputs
    /// When the maximum number of accumulated inputs is reached, the MainSM state machine processes
    /// the inputs in batches. The inputs are processed in parallel using the thread pool
    /// # Arguments
    /// * `emu_required` - Inputs to be proved
    /// * `ectx` - Execution context to interact with the execution environment
    #[inline(always)]
    fn prove(&self, mut emu_required: ZiskRequired, _ectx: &'a ExecutionCtx, scope: &Scope<'a>) {
        let memory = mem::take(&mut emu_required.memory);
        let binary = mem::take(&mut emu_required.binary);
        let arith = mem::take(&mut emu_required.arith);

        let mem_sm = self.mem_sm.clone();
        let binary_sm = self.binary_sm.clone();
        let arith_sm = self.arith_sm.clone();

        let threads_controller = self.threads_controller.clone();

        scope.spawn(move |scope| {
            mem_sm.prove(&memory, false, scope);
            binary_sm.prove(&binary, false, scope);
            arith_sm.prove(&arith, false, scope);

            threads_controller.remove_working_thread();
        });
    }
}

impl<F> WitnessComponent<F> for MainSM<F> {
    fn calculate_witness(
        &self,
        _stage: u32,
        _air_instance: Option<usize>,
        _pctx: &mut ProofCtx<F>,
        _ectx: &ExecutionCtx,
        _sctx: &SetupCtx,
    ) {
    }
}
