use log::info;
use p3_field::PrimeField;

use proofman_util::{timer_start_info, timer_stop_and_log_info};
use rayon::{prelude::*, Scope, ThreadPoolBuilder};
use sm_binary::BinarySM;
use std::{
    fs, mem,
    path::{Path, PathBuf},
    process,
    sync::{Arc, Mutex},
};
use zisk_core::{Riscv2zisk, ZiskOperationType, ZiskRequired, ZiskRom};

use proofman::WitnessManager;
use proofman_common::{AirInstance, ExecutionCtx, ProofCtx, SetupCtx};

use zisk_pil::{Main0Row, Main0Trace, MAIN_AIRGROUP_ID, MAIN_AIR_IDS};
use ziskemu::{
    Emu, EmuFullTraceStep, EmuOptions, EmuTrace, EmuTraceStart, ParEmuOptions, ZiskEmulator,
};

//use process::Command;
use proofman::WitnessComponent;
use sm_arith::ArithSM;
use sm_common::{create_prover_buffer, Provable};
use sm_mem::MemSM;

#[derive(Default)]
pub struct MainAirSegment<F> {
    pub air_segment_id: u32,
    pub filled_inputs: usize,
    pub inputs: Vec<EmuFullTraceStep<F>>,
}

impl<F: Default + Clone> MainAirSegment<F> {
    pub fn new(segment_id: u32) -> Self {
        Self { air_segment_id: segment_id, filled_inputs: 0, inputs: Vec::new() }
    }
}

pub struct InstanceExtensionInputs<F> {
    pub prover_buffer: Vec<F>,
    pub offset: u64,
    pub segment_type: Option<ZiskOperationType>,
    pub emu_trace_start: Option<EmuTraceStart>,
}

impl<F: Default + Clone> InstanceExtensionInputs<F> {
    pub fn new(
        prover_buffer: Vec<F>,
        offset: u64,
        segment_type: Option<ZiskOperationType>,
        emu_trace_start: Option<EmuTraceStart>,
    ) -> Self {
        Self { prover_buffer, offset, segment_type, emu_trace_start }
    }
}
/// This is a multithreaded implementation of the Zisk MainSM state machine.
///
/// The MainSM state machine is responsible for orchestrating the execution of the program and
/// processing the inputs generated by the emulator. The MainSM state machine interacts with the
/// secondary state machines to process the inputs generated by the emulator.
pub struct MainSM<F: PrimeField> {
    // Zisk ROM
    zisk_rom: ZiskRom,
    zisk_rom_path: PathBuf,

    // State machines
    mem_sm: Arc<MemSM>,
    binary_sm: Arc<BinarySM<F>>,
    arith_sm: Arc<ArithSM>,
}

impl<'a, F: PrimeField> MainSM<F> {
    const MY_NAME: &'static str = "MainSM  ";

    /// Default number of inputs of the main state machine that are accumulated before being
    /// processed
    const BLOCK_SIZE: usize = 2usize.pow(21);
    const NUM_THREADS: usize = 8;

    /// Constructor for the MainSM state machine
    /// Registers the state machine at the WCManager and stores references to the secondary state
    /// machines that directly interact with the MainSM
    /// Returns an Arc to the MainSM state machine
    /// # Arguments
    /// * `rom_path` - Path to the ROM file
    /// * `wcm` - Witness computation manager to register the state machine
    /// * `mem_sm` - Arc to the MemSM state machine
    /// * `binary_sm` - Arc to the BinarySM state machine
    /// * `arith_sm` - Arc to the ArithSM state machine
    /// * `air_ids` - Array of Main Air IDs extracted from the pilout
    /// # Returns
    /// * Arc to the MainSM state machine
    pub fn new(
        rom_path: PathBuf,
        wcm: Arc<WitnessManager<F>>,
        mem_sm: Arc<MemSM>,
        binary_sm: Arc<BinarySM<F>>,
        arith_sm: Arc<ArithSM>,
    ) -> Arc<Self> {
        // If rom_path has an .elf extension it must be converted to a ZisK ROM
        let zisk_rom = if rom_path.extension().unwrap() == "elf" {
            // Create an instance of the RISCV -> ZisK program converter
            let rv2zk = Riscv2zisk::new(
                rom_path.display().to_string(),
                String::new(),
                String::new(),
                String::new(),
            );

            // Convert program to rom
            match rv2zk.run() {
                Ok(rom) => rom,
                Err(e) => {
                    panic!("Application error: {}", e);
                }
            }
        } else {
            // TODO - Remove this when the ZisK ROM is able to be loaded from a file
            panic!("ROM file must be an ELF file");
        };

        // TODO - Compute MAX_ACCUMULATED having the num_rows of the Main AIR
        // TODO - If there is more than one Main AIR available, the MAX_ACCUMULATED will be the one
        // with the highest num_rows. It has to be a power of 2.

        let main_sm = Arc::new(Self {
            zisk_rom,
            zisk_rom_path: rom_path.to_path_buf(),
            mem_sm: mem_sm.clone(),
            binary_sm: binary_sm.clone(),
            arith_sm: arith_sm.clone(),
        });

        wcm.register_component(main_sm.clone(), Some(MAIN_AIRGROUP_ID), Some(MAIN_AIR_IDS));

        // For all the secondary state machines, register the main state machine as a predecessor
        main_sm.mem_sm.register_predecessor();
        main_sm.binary_sm.register_predecessor();
        main_sm.arith_sm.register_predecessor();

        main_sm
    }

    /// Executes the MainSM state machine and processes the inputs in batches when the maximum
    /// number of accumulated inputs is reached. The MainSM state machine uses the emulator to
    /// execute the a program and using a callback the main state machine receives batches of
    /// inputs generated by the emulator. The inputs are processed in batches when the maximum
    /// number of accumulated inputs is reached
    /// # Arguments
    /// * `pctx` - Proof context to interact with the proof system
    /// * `ectx` - Execution context to interact with the execution environment
    pub fn execute(
        &self,
        public_inputs_path: &Path,
        pctx: Arc<ProofCtx<F>>,
        ectx: Arc<ExecutionCtx>,
        sctx: Arc<SetupCtx>,
    ) {
        // Create a thread pool to manage the execution of all the state machines related to the
        // execution process
        let pool = ThreadPoolBuilder::new().build().unwrap();

        // Prepare the settings for the emulator
        let emulator_options = EmuOptions {
            elf: Some(self.zisk_rom_path.clone().display().to_string()),
            inputs: Some(public_inputs_path.display().to_string()),
            trace_steps: Some(Self::BLOCK_SIZE as u64),
            ..EmuOptions::default()
        };

        // Call emulate with these options
        let public_inputs = {
            // Read inputs data from the provided inputs path
            let path = PathBuf::from(public_inputs_path.display().to_string());
            fs::read(path).expect("Could not read inputs file")
        };

        // Execute the emulator inside a thread
        let mut exe_traces = vec![Vec::new(); Self::NUM_THREADS];

        pool.scope(|_| {
            timer_start_info!(PAR_PROCESS_ROM);
            let operation_counts = Arc::new(Mutex::new(Vec::new()));
            exe_traces.par_iter_mut().enumerate().for_each(|(thread_id, exe_trace)| {
                let par_emu_options = ParEmuOptions::new(
                    Self::NUM_THREADS,
                    thread_id,
                    Self::BLOCK_SIZE,
                    [2u64.pow(21), 0, 2u64.pow(21), 2u64.pow(21), 2u64.pow(21), 2u64.pow(21)],
                );

                let result = ZiskEmulator::par_process_rom::<F>(
                    &self.zisk_rom,
                    &public_inputs,
                    &emulator_options,
                    &par_emu_options,
                )
                .unwrap_or_else(|e| panic!("Error during emulator execution: {:?}", e));

                *exe_trace = result.0;
                println!("emu segment {:?}", result.1);
                if thread_id == 0 {
                    let mut op_counts = operation_counts.lock().unwrap();
                    *op_counts = result.2.to_vec();
                }
            });
            timer_stop_and_log_info!(PAR_PROCESS_ROM);
            println!("operation counts: {:?}", operation_counts);
            process::exit(0);

            timer_start_info!(FLAT);
            let num_boxes = exe_traces.iter().map(|trace| trace.len()).sum::<usize>();
            let mut vec_traces = Vec::with_capacity(num_boxes);
            for i in 0..num_boxes {
                let x = i % Self::NUM_THREADS;
                let y = i / Self::NUM_THREADS;

                let exe_trace = std::mem::take(&mut exe_traces[x][y]);
                vec_traces.push(exe_trace);
            }
            timer_stop_and_log_info!(FLAT);

            timer_start_info!(ALLOCATE_EXTENDED_TRACES);
            let mut prover_buffers: Vec<(Vec<F>, u64)> = Vec::with_capacity(vec_traces.len());
            let mut instance_extension_inputs: Vec<InstanceExtensionInputs<F>> =
                Vec::with_capacity(vec_traces.len());
            for _ in 0..vec_traces.len() {
                let prover_buffer: (Vec<F>, u64) =
                    create_prover_buffer::<F>(&ectx, &sctx, MAIN_AIRGROUP_ID, MAIN_AIR_IDS[0]);
                prover_buffers.push(prover_buffer);
                instance_extension_inputs.push(InstanceExtensionInputs::new(
                    prover_buffer.0,
                    prover_buffer.1,
                    None,
                    None,
                ));
            }
            timer_stop_and_log_info!(ALLOCATE_EXTENDED_TRACES);

            timer_start_info!(PAR_EXPANSION);
            let num_segments = vec_traces.len();
            let air = pctx.pilout.get_air(MAIN_AIRGROUP_ID, MAIN_AIR_IDS[0]);
            prover_buffers.par_iter_mut().enumerate().for_each(|(segment_id, (buffer, offset))| {
                let segment_trace = &vec_traces[segment_id];
                let offset = *offset;

                timer_start_info!(COPY_ROWS);
                let mut emu: Emu<'_> = Emu::new(&self.zisk_rom);
                emu.ctx.inst_ctx.pc = segment_trace.start.pc;
                emu.ctx.inst_ctx.sp = segment_trace.start.sp;
                emu.ctx.inst_ctx.step = segment_trace.start.step;
                emu.ctx.inst_ctx.c = segment_trace.start.c;

                let total_steps = segment_trace.steps.len();
                const CHUNK_SIZE: usize = 4096;
                let mut tmp_trace = Main0Trace::<F>::new(CHUNK_SIZE);

                let main_first_segment = F::from_bool(segment_id == 0);
                let main_last_segment = F::from_bool(segment_id == num_segments - 1);
                let main_segment = F::from_canonical_usize(segment_id);

                let mut last_row = Main0Row::<F>::default();
                for chunk_start in (0..air.num_rows()).step_by(CHUNK_SIZE) {
                    // process the steps of the chunk
                    let start_pos_abs = std::cmp::min(chunk_start, total_steps);
                    let end_pos_abs = (chunk_start + CHUNK_SIZE).min(total_steps);
                    for (i, step) in
                        segment_trace.steps[start_pos_abs..end_pos_abs].iter().enumerate()
                    {
                        tmp_trace[i] = emu.step_slice_buff(step);
                        tmp_trace[i].main_first_segment = main_first_segment;
                        tmp_trace[i].main_last_segment = main_last_segment;
                        tmp_trace[i].main_segment = main_segment;
                    }

                    // if there are steps in the chunk update last row
                    if end_pos_abs - start_pos_abs > 0 {
                        last_row = tmp_trace[end_pos_abs - start_pos_abs - 1];
                    }

                    // if there are less steps than the chunk size, fill the rest with the last row
                    for i in (end_pos_abs - start_pos_abs)..CHUNK_SIZE {
                        tmp_trace[i] = last_row;
                    }

                    //copy the chunk to the prover buffer
                    let tmp_buffer = tmp_trace.buffer.as_mut().unwrap();
                    let buffer_offset_chunk =
                        offset as usize + chunk_start * Main0Row::<F>::ROW_SIZE;
                    buffer[buffer_offset_chunk..buffer_offset_chunk + tmp_buffer.len()]
                        .copy_from_slice(tmp_buffer);
                }
                timer_stop_and_log_info!(COPY_ROWS);

                let filled = segment_trace.steps.len();
                let buffer = std::mem::take(buffer);
                timer_start_info!(PROVE_MAIN);
                Self::prove_main(buffer, segment_id, filled, &pctx);
                timer_stop_and_log_info!(PROVE_MAIN);
            });
            timer_stop_and_log_info!(PAR_EXPANSION);

            std::thread::spawn(move || {
                drop(exe_traces);
            });
        });
    }

    #[inline(always)]
    fn prove_main(buffer: Vec<F>, segment_id: usize, filled_rows: usize, pctx: &ProofCtx<F>) {
        timer_start_info!(CREATE_INSTANCES);

        let air = pctx.pilout.get_air(MAIN_AIRGROUP_ID, MAIN_AIR_IDS[0]);
        // let main_trace =
        //     Main0Trace::<F>::map_buffer(&mut buffer, air.num_rows(), offset as usize).unwrap();

        // println!("First row: {:?}", main_trace[0]);
        // let main_first_segment = F::from_bool(segment_id == 0);
        // let main_last_segment = F::from_bool(segment_id == num_segments - 1);
        // let main_segment = F::from_canonical_usize(segment_id);

        info!(
            "{}: ··· Creating Main segment #{} [{} / {} rows filled {:.2}%]",
            Self::MY_NAME,
            segment_id,
            filled_rows,
            air.num_rows(),
            filled_rows as f64 / air.num_rows() as f64 * 100.0
        );

        // let last_row = main_trace[filled_rows - 1];
        // for i in filled_rows..air.num_rows() {
        //     main_trace[i] = last_row;
        // }

        // for i in 0..air.num_rows() {
        //     main_trace[i].main_first_segment = main_first_segment;
        //     main_trace[i].main_last_segment = main_last_segment;
        //     main_trace[i].main_segment = main_segment;
        // }

        let air_instance =
            AirInstance::new(MAIN_AIRGROUP_ID, MAIN_AIR_IDS[0], Some(segment_id), buffer);

        pctx.air_instance_repo.add_air_instance(air_instance);

        timer_stop_and_log_info!(CREATE_INSTANCES);
    }

    fn prove_inputs(&self, mut vec_required: Vec<Vec<ZiskRequired>>, scope: &Scope<'a>) {
        let mut current_box = 0;
        let mut level = 0;
        loop {
            if vec_required[current_box].len() <= level {
                break;
            }

            let required = &mut vec_required[current_box][level];

            // self.arith_sm.prove(&required.arith, false, scope);

            let req_binary = std::mem::take(&mut required.binary);
            self.binary_sm.prove_xxx(req_binary, false, false, scope);

            let req_extension = std::mem::take(&mut required.binary_extension);
            self.binary_sm.prove_xxx(req_extension, true, false, scope);

            // self.mem_sm.prove(&required.memory, false);

            current_box += 1;
            if current_box == Self::NUM_THREADS {
                current_box = 0;
                level += 1;
            }
        }

        std::thread::spawn(move || {
            drop(vec_required);
        });
    }

    // Callback method to process the inputs generated by the emulator
    #[inline(always)]
    fn emulator_callback(
        &'a self,
        zisk_rom: &'a ZiskRom,
        emu_traces: EmuTrace,
        scope: &Scope<'a>,
        pctx: Arc<ProofCtx<F>>,
        ectx: Arc<ExecutionCtx>,
        sctx: Arc<SetupCtx>,
    ) {
        let air = pctx.pilout.get_air(MAIN_AIRGROUP_ID, MAIN_AIR_IDS[0]);

        // To go faster, we receive from the simulator callback a tiny trace that we are going
        // to process to get the full trace. This is done to avoid the overhead of processing
        // the full trace in the simulator callback and now can be parallelized.
        timer_start_info!(EXPANDING);
        let emu_slice = match ZiskEmulator::process_slice::<F>(zisk_rom, &emu_traces) {
            Ok(slice) => slice,
            Err(e) => panic!("Error processing slice: {:?}", e),
        };
        timer_stop_and_log_info!(EXPANDING);

        timer_start_info!(PROCESS_MAIN);
        let num_segments =
            (emu_slice.full_trace.len() as f64 / air.num_rows() as f64).ceil() as usize;
        let mut total_drained = 0;

        // self.prove(emu_slice.required, ectx.clone(), scope);

        for segment_id in 0..num_segments {
            let num_drained =
                std::cmp::min(air.num_rows(), &emu_slice.full_trace.len() - total_drained);
            let drained_inputs = &emu_slice.full_trace
                [segment_id * air.num_rows()..segment_id * air.num_rows() + num_drained];

            total_drained += num_drained;

            let pctx_cloned = pctx.clone();
            let ectx_cloned = ectx.clone();
            let sctx_cloned = sctx.clone();

            timer_start_info!(TO_VEC);
            let mut air_segment = MainAirSegment::new(segment_id as u32);
            air_segment.inputs = drained_inputs.to_vec();
            air_segment.filled_inputs += num_drained;
            timer_stop_and_log_info!(TO_VEC);

            scope.spawn(move |_| {
                // As CALLBACK_SIZE is a power of 2, we can check if the segment is full by checking
                let air_segment = mem::take(&mut air_segment);
                Self::create_air_instance(
                    air_segment,
                    pctx_cloned,
                    ectx_cloned,
                    sctx_cloned,
                    false,
                );
            });
        }
        timer_stop_and_log_info!(PROCESS_MAIN);

        // scope.spawn(move |scope| {
        //     // To go faster, we receive from the simulator callback a tiny trace that we are
        // going     // to process to get the full trace. This is done to avoid the overhead
        // of processing     // the full trace in the simulator callback and now can be
        // parallelized.     let emu_slice = match
        // ZiskEmulator::process_slice::<F>(zisk_rom, &emu_traces) {         Ok(slice) =>
        // slice,         Err(e) => panic!("Error processing slice: {:?}", e),
        //     };

        //     let len = emu_slice.full_trace.len();
        //     let source_iter = emu_slice.full_trace.into_iter();

        //     let mut inputs = self.callback_inputs.lock().unwrap();
        //     let air_segment = &mut inputs[segment_id];

        //     air_segment.inputs.splice(
        //         pos_id * Self::CALLBACK_SIZE..pos_id * Self::CALLBACK_SIZE + source_iter.len(),
        //         source_iter,
        //     );

        //     air_segment.filled_inputs += len;
        //     assert!(air_segment.filled_inputs <= num_rows, "Too many inputs in a Main AIR
        // segment");

        //     self.prove(emu_slice.required, ectx.clone(), scope);

        //     // As CALLBACK_SIZE is a power of 2, we can check if the segment is full by checking
        //     if air_segment.filled_inputs == num_rows {
        //         let air_segment = mem::take(air_segment);
        //         let cloned_ectx = ectx.clone();
        //         Self::create_air_instance(air_segment, pctx, cloned_ectx, sctx, false);
        //     }

        //     threads_controller.remove_working_thread();
        // });
    }

    /// Proves a batch of inputs
    /// When the maximum number of accumulated inputs is reached, the MainSM state machine processes
    /// the inputs in batches. The inputs are processed in parallel using the thread pool
    /// # Arguments
    /// * `inputs` - Vector of EmuTrace inputs to prove
    /// * `pctx` - Proof context to interact with the proof system
    /// * `ectx` - Execution context to interact with the execution environment
    #[inline(always)]
    fn create_air_instance(
        mut air_segment: MainAirSegment<F>,
        pctx: Arc<ProofCtx<F>>,
        ectx: Arc<ExecutionCtx>,
        sctx: Arc<SetupCtx>,
        last_segment: bool,
    ) {
        let air = pctx.pilout.get_air(MAIN_AIRGROUP_ID, MAIN_AIR_IDS[0]);
        info!(
            "{}: ··· Creating Main segment #{} [{} / {} rows filled {:.2}%]",
            Self::MY_NAME,
            air_segment.air_segment_id,
            air_segment.filled_inputs,
            air.num_rows(),
            air_segment.filled_inputs as f64 / air.num_rows() as f64 * 100.0
        );

        // Set remaining rows equals to the last filled row
        let copied_value = air_segment.inputs[air_segment.filled_inputs - 1];
        air_segment.inputs[air_segment.filled_inputs..]
            .par_iter_mut()
            .for_each(|input| *input = copied_value);

        // Set segment information in the inputs
        let main_first_segment = F::from_bool(air_segment.air_segment_id == 0);
        let main_last_segment = F::from_bool(last_segment);
        let main_segment = F::from_canonical_usize(air_segment.air_segment_id as usize);
        air_segment.inputs[..].par_iter_mut().for_each(|input| {
            input.main_first_segment = main_first_segment;
            input.main_last_segment = main_last_segment;
            input.main_segment = main_segment;
        });

        // Create the prover buffer
        let (mut prover_buffer, offset) =
            create_prover_buffer(&ectx, &sctx, MAIN_AIRGROUP_ID, MAIN_AIR_IDS[0]);

        // Convert the Vec<Main0Row<F>> to a flat Vec<F> and copy the resulting values into the
        // prover buffer
        let main_trace_buffer =
            Main0Trace::<F>::map_row_vec(air_segment.inputs, true).unwrap().buffer.unwrap();
        prover_buffer[offset as usize..offset as usize + main_trace_buffer.len()]
            .par_iter_mut()
            .zip(main_trace_buffer.par_iter())
            .for_each(|(buffer_elem, main_elem)| {
                *buffer_elem = *main_elem;
            });

        let air_instance = AirInstance::new(
            MAIN_AIRGROUP_ID,
            MAIN_AIR_IDS[0],
            Some(air_segment.air_segment_id as usize),
            prover_buffer,
        );

        pctx.air_instance_repo.add_air_instance(air_instance);
    }

    /// Proves a batch of inputs
    /// When the maximum number of accumulated inputs is reached, the MainSM state machine processes
    /// the inputs in batches. The inputs are processed in parallel using the thread pool
    /// # Arguments
    /// * `emu_required` - Inputs to be proved
    /// * `ectx` - Execution context to interact with the execution environment
    #[inline(always)]
    fn prove(&self, mut emu_required: ZiskRequired, _ectx: Arc<ExecutionCtx>, scope: &Scope<'a>) {
        let memory = mem::take(&mut emu_required.memory);
        let binary = mem::take(&mut emu_required.binary);
        let arith = mem::take(&mut emu_required.arith);

        let mem_sm = self.mem_sm.clone();
        let binary_sm = self.binary_sm.clone();
        let arith_sm = self.arith_sm.clone();

        scope.spawn(move |scope| {
            mem_sm.prove(&memory, false, scope);
        });

        scope.spawn(move |scope| {
            binary_sm.prove(&binary, false, scope);
        });

        scope.spawn(move |scope| {
            arith_sm.prove(&arith, false, scope);
        });
    }
}

impl<F: PrimeField> WitnessComponent<F> for MainSM<F> {}
