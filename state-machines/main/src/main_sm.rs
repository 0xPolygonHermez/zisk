use log::info;
use p3_field::PrimeField;
use sm_common::InstanceExpanderCtx;

use std::sync::Arc;
use zisk_core::{zisk_ops::ZiskOp, ZiskRom, ROM_ENTRY};

use proofman::WitnessManager;
use proofman_common::{AirInstance, FromTrace};

use zisk_pil::{MainAirValues, MainTrace, MainTraceRow};
use ziskemu::{Emu, EmuTrace};

/// This is a multithreaded implementation of the Zisk MainSM state machine.
///
/// The MainSM state machine is responsible for orchestrating the execution of the program and
/// processing the inputs generated by the emulator. The MainSM state machine interacts with the
/// secondary state machines to process the inputs generated by the emulator.
pub struct MainSM<F: PrimeField> {
    /// Witness computation manager
    wcm: Arc<WitnessManager<F>>,
}

impl<F: PrimeField> MainSM<F> {
    const MY_NAME: &'static str = "MainSM  ";

    /// Constructor for the MainSM state machine
    /// Registers the state machine at the WCManager and stores references to the secondary state
    /// machines that directly interact with the MainSM
    /// Returns an Arc to the MainSM state machine
    /// # Arguments
    /// * `wcm` - Witness computation manager to register the state machine
    /// * `arith_sm` - Arc to the ArithSM state machine
    /// * `binary_sm` - Arc to the BinarySM state machine
    /// * `mem_sm` - Arc to the MemSM state machine
    /// # Returns
    /// * Arc to the MainSM state machine
    pub fn new(wcm: Arc<WitnessManager<F>>) -> Arc<Self> {
        Arc::new(Self { wcm: wcm.clone() })
    }

    pub fn get_instance(&self, iectx: InstanceExpanderCtx) -> MainInstance<F> {
        MainInstance::new(iectx)
    }

    pub fn prove_main(
        &self,
        zisk_rom: &ZiskRom,
        vec_traces: &[EmuTrace],
        main_instance: &mut MainInstance<F>,
    ) {
        let iectx = &main_instance.iectx;
        let current_segment = iectx.plan.segment_id.unwrap();
        let num_rows = MainTrace::<F>::NUM_ROWS;

        let filled = vec_traces[current_segment].steps.steps + 1;
        info!(
            "{}: ··· Creating Main segment #{} [{} / {} rows filled {:.2}%]",
            Self::MY_NAME,
            current_segment,
            filled,
            num_rows,
            filled as f64 / num_rows as f64 * 100.0
        );

        // Set Row 0 of the current segment
        let row0 = if current_segment == 0 {
            MainTraceRow::<F> {
                pc: F::from_canonical_u64(ROM_ENTRY),
                op: F::from_canonical_u8(ZiskOp::CopyB.code()),
                a_src_imm: F::one(),
                b_src_imm: F::one(),
                ..MainTraceRow::default()
            }
        } else {
            //let emu_trace_previous = vec_traces[segment_id - 1].last_state;
            let mut emu =
                Emu::from_emu_trace_start(zisk_rom, &vec_traces[current_segment - 1].last_state);
            let mut mem_reads_index: usize =
                vec_traces[current_segment - 1].last_state.mem_reads_index;
            let row_previous = emu.step_slice_full_trace(
                &vec_traces[current_segment - 1].steps,
                &mut mem_reads_index,
            );

            MainTraceRow::<F> {
                set_pc: row_previous.set_pc,
                jmp_offset1: row_previous.jmp_offset1,
                jmp_offset2: if row_previous.flag == F::one() {
                    row_previous.jmp_offset1
                } else {
                    row_previous.jmp_offset2
                },
                a: row_previous.a,
                b: row_previous.c,
                c: row_previous.c,
                a_offset_imm0: row_previous.a[0],
                b_offset_imm0: row_previous.c[0],
                addr1: row_previous.c[0],
                a_imm1: row_previous.a[1],
                b_imm1: row_previous.c[1],
                op: F::from_canonical_u8(ZiskOp::CopyB.code()),
                pc: row_previous.pc,
                a_src_imm: F::one(),
                b_src_imm: F::one(),
                ..MainTraceRow::default()
            }
        };

        let mut emu = Emu::from_emu_trace_start(zisk_rom, &vec_traces[current_segment].start_state);

        main_instance.main_trace.buffer[0] = row0;

        // Set Rows 1 to N of the current segment (N = maximum number of air rows)
        let emu_trace_step = &vec_traces[current_segment].steps;
        let mut mem_reads_index: usize = 0;
        //for (idx, emu_trace) in vec_traces[current_segment].steps.iter().enumerate() {
        for idx in 0..vec_traces[current_segment].steps.steps as usize {
            let expanded_row = emu.step_slice_full_trace(emu_trace_step, &mut mem_reads_index);

            main_instance.main_trace.buffer[idx + 1] = expanded_row;
        }

        let filled_rows = vec_traces[current_segment].steps.steps as usize;
        let last_row = main_instance.main_trace.buffer[filled_rows];
        // Fill the rest of the buffer with the last row
        for i in (filled_rows + 1)..num_rows {
            main_instance.main_trace.buffer[i] = last_row;
        }

        let main_last_segment = F::from_bool(current_segment == vec_traces.len() - 1);
        let main_segment = F::from_canonical_usize(current_segment);

        let mut main_air_values = MainAirValues::<F>::new();
        main_air_values.main_last_segment[0] = main_last_segment;
        main_air_values.main_segment[0] = main_segment;

        let air_instance = AirInstance::new_from_trace(
            self.wcm.get_sctx(),
            FromTrace::new(&mut main_instance.main_trace).with_air_values(&mut main_air_values),
        );

        self.wcm
            .get_pctx()
            .air_instance_repo
            .add_air_instance(air_instance, Some(main_instance.iectx.global_idx));
    }
}

pub struct MainInstance<F: PrimeField> {
    iectx: InstanceExpanderCtx,
    main_trace: MainTrace<F>,
}

impl<F: PrimeField> MainInstance<F> {
    pub fn new(iectx: InstanceExpanderCtx) -> Self {
        let main_trace = MainTrace::new();

        Self { iectx, main_trace }
    }
}
