use log::info;
use p3_field::PrimeField;

use crate::InstanceExtensionCtx;
use proofman_util::{timer_start_debug, timer_stop_and_log_debug};
use sm_binary::BinarySM;
use std::sync::Arc;
use zisk_core::{zisk_ops::ZiskOp, ZiskRom, ROM_ENTRY};

use proofman::WitnessManager;
use proofman_common::{AirInstance, ProofCtx};

use proofman::WitnessComponent;
use sm_arith::ArithSM;
use sm_mem::MemSM;
use zisk_pil::{
    Main0Row, Main0Trace, BINARY_AIRGROUP_ID, BINARY_AIR_IDS, BINARY_EXTENSION_AIRGROUP_ID,
    BINARY_EXTENSION_AIR_IDS, MAIN_AIRGROUP_ID, MAIN_AIR_IDS,
};
use ziskemu::{Emu, EmuTrace, ZiskEmulator};

/// This is a multithreaded implementation of the Zisk MainSM state machine.
///
/// The MainSM state machine is responsible for orchestrating the execution of the program and
/// processing the inputs generated by the emulator. The MainSM state machine interacts with the
/// secondary state machines to process the inputs generated by the emulator.
pub struct MainSM<F: PrimeField> {
    /// Witness computation manager
    wcm: Arc<WitnessManager<F>>,

    /// Arithmetic state machine
    arith_sm: Arc<ArithSM>,

    /// Binary state machine
    binary_sm: Arc<BinarySM<F>>,

    /// Memory state machine
    mem_sm: Arc<MemSM>,
}

impl<F: PrimeField> MainSM<F> {
    const MY_NAME: &'static str = "MainSM  ";

    /// Constructor for the MainSM state machine
    /// Registers the state machine at the WCManager and stores references to the secondary state
    /// machines that directly interact with the MainSM
    /// Returns an Arc to the MainSM state machine
    /// # Arguments
    /// * `wcm` - Witness computation manager to register the state machine
    /// * `arith_sm` - Arc to the ArithSM state machine
    /// * `binary_sm` - Arc to the BinarySM state machine
    /// * `mem_sm` - Arc to the MemSM state machine
    /// # Returns
    /// * Arc to the MainSM state machine
    pub fn new(
        wcm: Arc<WitnessManager<F>>,
        arith_sm: Arc<ArithSM>,
        binary_sm: Arc<BinarySM<F>>,
        mem_sm: Arc<MemSM>,
    ) -> Arc<Self> {
        let main_sm = Arc::new(Self { wcm: wcm.clone(), arith_sm, binary_sm, mem_sm });

        wcm.register_component(main_sm.clone(), Some(MAIN_AIRGROUP_ID), Some(MAIN_AIR_IDS));

        // For all the secondary state machines, register the main state machine as a predecessor
        main_sm.mem_sm.register_predecessor();
        main_sm.binary_sm.register_predecessor();
        main_sm.arith_sm.register_predecessor();

        main_sm
    }

    pub fn prove_main(
        &self,
        zisk_rom: &ZiskRom,
        vec_traces: &[EmuTrace],
        iectx: &mut InstanceExtensionCtx<F>,
        pctx: &ProofCtx<F>,
    ) {
        let segment_id = iectx.segment_id.unwrap();
        let segment_trace = &vec_traces[segment_id];

        let offset = iectx.offset;
        let air = pctx.pilout.get_air(MAIN_AIRGROUP_ID, MAIN_AIR_IDS[0]);
        let filled = segment_trace.steps.len();
        info!(
            "{}: ··· Creating Main segment #{} [{} / {} rows filled {:.2}%]",
            Self::MY_NAME,
            segment_id,
            filled,
            air.num_rows(),
            filled as f64 / air.num_rows() as f64 * 100.0
        );

        let mut emu = Emu::from_emu_trace_start(zisk_rom, &segment_trace.start);

        // Set Row 0 of the current segment
        let row0 = if segment_id == 0 {
            Main0Row::<F> {
                pc: F::from_canonical_u64(ROM_ENTRY),
                op: F::from_canonical_u8(ZiskOp::CopyB.code()),
                a_src_imm: F::one(),
                b_src_imm: F::one(),
                ..Main0Row::default()
            }
        } else {
            let emu_trace_previous = vec_traces[segment_id - 1].steps.last().unwrap();
            let row_previous = emu.step_slice_full_trace(emu_trace_previous);

            Main0Row::<F> {
                a: row_previous.a,
                b: row_previous.c,
                c: row_previous.c,
                a_offset_imm0: row_previous.a[0],
                b_offset_imm0: row_previous.c[0],
                a_imm1: row_previous.a[1],
                b_imm1: row_previous.c[1],
                op: F::from_canonical_u8(ZiskOp::CopyB.code()),
                pc: row_previous.pc,
                a_src_imm: F::one(),
                b_src_imm: F::one(),
                ..Main0Row::default()
            }
        };

        let rng = offset as usize..(offset as usize + Main0Row::<F>::ROW_SIZE);
        iectx.prover_buffer[rng].copy_from_slice(row0.as_slice());

        // Set Rows 1 to N of the current segment (N = maximum number of air rows)
        let total_rows = segment_trace.steps.len();
        const SLICE_ROWS: usize = 4096;
        let mut partial_trace = Main0Trace::<F>::new(SLICE_ROWS);

        let mut last_row = Main0Row::<F>::default();
        for slice in (0..(air.num_rows())).step_by(SLICE_ROWS) {
            // process the steps of the chunk
            let slice_start = std::cmp::min(slice, total_rows);
            let slice_end = std::cmp::min(slice + SLICE_ROWS, total_rows);

            for (i, emu_trace_step) in
                segment_trace.steps[slice_start..slice_end].iter().enumerate()
            {
                partial_trace[i] = emu.step_slice_full_trace(emu_trace_step);
            }

            // if there are steps in the chunk update last row
            if slice_end - slice_start > 0 {
                last_row = partial_trace[slice_end - slice_start - 1];
            }

            // if there are less steps than the chunk size, fill the rest with the last row
            for i in (slice_end - slice_start)..SLICE_ROWS {
                partial_trace[i] = last_row;
            }

            //copy the chunk to the prover buffer
            let partial_buffer = partial_trace.buffer.as_ref().unwrap();
            let buffer_offset_slice = offset as usize + (slice + 1) * Main0Row::<F>::ROW_SIZE;

            let rng = buffer_offset_slice..buffer_offset_slice + partial_buffer.len();
            iectx.prover_buffer[rng].copy_from_slice(partial_buffer);
        }

        let buffer = std::mem::take(&mut iectx.prover_buffer);
        let sctx = self.wcm.get_sctx();
        let mut air_instance = AirInstance::new(
            sctx.clone(),
            MAIN_AIRGROUP_ID,
            MAIN_AIR_IDS[0],
            Some(segment_id),
            buffer,
        );

        let main_last_segment = F::from_bool(segment_id == vec_traces.len() - 1);
        let main_segment = F::from_canonical_usize(segment_id);

        air_instance.set_airvalue(&sctx, "Main.main_last_segment", main_last_segment);
        air_instance.set_airvalue(&sctx, "Main.main_segment", main_segment);

        iectx.air_instance = Some(air_instance);
    }

    pub fn prove_binary(
        &self,
        zisk_rom: &ZiskRom,
        vec_traces: &[EmuTrace],
        iectx: &mut InstanceExtensionCtx<F>,
        pctx: &ProofCtx<F>,
    ) {
        let air = pctx.pilout.get_air(BINARY_AIRGROUP_ID, BINARY_AIR_IDS[0]);

        timer_start_debug!(PROCESS_BINARY);
        let inputs = ZiskEmulator::process_slice_required::<F>(
            zisk_rom,
            vec_traces,
            iectx.op_type,
            &iectx.emu_trace_start,
            air.num_rows(),
        );
        timer_stop_and_log_debug!(PROCESS_BINARY);

        timer_start_debug!(PROVE_BINARY);
        self.binary_sm.prove_instance(inputs, false, &mut iectx.prover_buffer, iectx.offset);
        timer_stop_and_log_debug!(PROVE_BINARY);

        timer_start_debug!(CREATE_AIR_INSTANCE);
        let buffer = std::mem::take(&mut iectx.prover_buffer);
        iectx.air_instance = Some(AirInstance::new(
            self.wcm.get_sctx(),
            BINARY_AIRGROUP_ID,
            BINARY_AIR_IDS[0],
            None,
            buffer,
        ));
        timer_stop_and_log_debug!(CREATE_AIR_INSTANCE);
    }

    pub fn prove_binary_extension(
        &self,
        zisk_rom: &ZiskRom,
        vec_traces: &[EmuTrace],
        iectx: &mut InstanceExtensionCtx<F>,
        pctx: &ProofCtx<F>,
    ) {
        let air = pctx.pilout.get_air(BINARY_EXTENSION_AIRGROUP_ID, BINARY_EXTENSION_AIR_IDS[0]);

        let inputs = ZiskEmulator::process_slice_required::<F>(
            zisk_rom,
            vec_traces,
            iectx.op_type,
            &iectx.emu_trace_start,
            air.num_rows(),
        );

        self.binary_sm.prove_instance(inputs, true, &mut iectx.prover_buffer, iectx.offset);

        let buffer = std::mem::take(&mut iectx.prover_buffer);
        iectx.air_instance = Some(AirInstance::new(
            self.wcm.get_sctx(),
            BINARY_EXTENSION_AIRGROUP_ID,
            BINARY_EXTENSION_AIR_IDS[0],
            None,
            buffer,
        ));
    }
}

impl<F: PrimeField> WitnessComponent<F> for MainSM<F> {}
