use log::info;
use p3_field::Field;

use proofman_util::{timer_start, timer_stop_and_log};
use rayon::{Scope, ThreadPoolBuilder};
use sm_binary::BinarySM;
use std::{
    fs, mem,
    path::{Path, PathBuf},
    sync::{Arc, Mutex},
};
use zisk_core::{Riscv2zisk, ZiskRequired, ZiskRom};

use proofman::WitnessManager;
use proofman_common::{AirInstance, ExecutionCtx, ProofCtx, SetupCtx};

use zisk_pil::{Main0Trace, MAIN_AIRGROUP_ID, MAIN_AIR_IDS};
use ziskemu::{EmuFullTraceStep, EmuOptions, EmuTrace, ZiskEmulator};

use proofman::WitnessComponent;
use sm_arith::ArithSM;
use sm_common::{create_buffer_fast, Provable, ThreadController};
use sm_mem::MemSM;

#[derive(Default)]
pub struct MainAirSegment<F> {
    pub air_segment_id: u32,
    pub filled_inputs: usize,
    pub inputs: Vec<EmuFullTraceStep<F>>,
}

impl<F: Default + Clone> MainAirSegment<F> {
    pub fn new(segment_id: u32, inputs_size: usize) -> Self {
        Self {
            air_segment_id: segment_id,
            filled_inputs: 0,
            inputs: create_buffer_fast(inputs_size),
        }
    }
}

/// This is a multithreaded implementation of the Zisk MainSM state machine.
///
/// The MainSM state machine is responsible for orchestrating the execution of the program and
/// processing the inputs generated by the emulator. The MainSM state machine interacts with the
/// secondary state machines to process the inputs generated by the emulator.
pub struct MainSM<F> {
    // Thread controller to manage the execution of the state machines
    threads_controller: Arc<ThreadController>,
    // Zisk ROM
    zisk_rom: ZiskRom,
    zisk_rom_path: PathBuf,
    // Inputs accumulator from the emulator
    callback_inputs: Arc<Mutex<Vec<MainAirSegment<F>>>>,
    // State machines
    mem_sm: Arc<MemSM>,
    binary_sm: Arc<BinarySM<F>>,
    arith_sm: Arc<ArithSM>,
}

impl<'a, F: Field> MainSM<F> {
    const MY_NAME: &'static str = "MainSM  ";

    /// Default number of inputs of the main state machine that are accumulated before being
    /// processed
    const CALLBACK_SIZE: usize = 2usize.pow(16);
    const MAX_ACCUMULATED: usize = 2usize.pow(21);

    /// Constructor for the MainSM state machine
    /// Registers the state machine at the WCManager and stores references to the secondary state
    /// machines that directly interact with the MainSM
    /// Returns an Arc to the MainSM state machine
    /// # Arguments
    /// * `rom_path` - Path to the ROM file
    /// * `wcm` - Witness computation manager to register the state machine
    /// * `mem_sm` - Arc to the MemSM state machine
    /// * `binary_sm` - Arc to the BinarySM state machine
    /// * `arith_sm` - Arc to the ArithSM state machine
    /// * `air_ids` - Array of Main Air IDs extracted from the pilout
    /// # Returns
    /// * Arc to the MainSM state machine
    pub fn new(
        rom_path: PathBuf,
        wcm: Arc<WitnessManager<F>>,
        mem_sm: Arc<MemSM>,
        binary_sm: Arc<BinarySM<F>>,
        arith_sm: Arc<ArithSM>,
    ) -> Arc<Self> {
        // If rom_path has an .elf extension it must be converted to a ZisK ROM
        let zisk_rom = if rom_path.extension().unwrap() == "elf" {
            // Create an instance of the RISCV -> ZisK program converter
            let rv2zk = Riscv2zisk::new(
                rom_path.display().to_string(),
                String::new(),
                String::new(),
                String::new(),
            );

            // Convert program to rom
            match rv2zk.run() {
                Ok(rom) => rom,
                Err(e) => {
                    panic!("Application error: {}", e);
                }
            }
        } else {
            // TODO - Remove this when the ZisK ROM is able to be loaded from a file
            panic!("ROM file must be an ELF file");
        };

        // TODO - Compute MAX_ACCUMULATED having the num_rows of the Main AIR
        // TODO - If there is more than one Main AIR available, the MAX_ACCUMULATED will be the one
        // with the highest num_rows. It has to be a power of 2.

        let main_sm = Arc::new(Self {
            threads_controller: Arc::new(ThreadController::new()),
            zisk_rom,
            zisk_rom_path: rom_path.to_path_buf(),
            mem_sm: mem_sm.clone(),
            binary_sm: binary_sm.clone(),
            arith_sm: arith_sm.clone(),
            callback_inputs: Arc::new(Mutex::new(Vec::new())),
        });

        wcm.register_component(main_sm.clone(), Some(MAIN_AIRGROUP_ID), Some(MAIN_AIR_IDS));

        // For all the secondary state machines, register the main state machine as a predecessor
        main_sm.mem_sm.register_predecessor();
        main_sm.binary_sm.register_predecessor();
        main_sm.arith_sm.register_predecessor();

        main_sm
    }

    /// Executes the MainSM state machine and processes the inputs in batches when the maximum
    /// number of accumulated inputs is reached. The MainSM state machine uses the emulator to
    /// execute the a program and using a callback the main state machine receives batches of
    /// inputs generated by the emulator. The inputs are processed in batches when the maximum
    /// number of accumulated inputs is reached
    /// # Arguments
    /// * `pctx` - Proof context to interact with the proof system
    /// * `ectx` - Execution context to interact with the execution environment
    pub fn execute(
        &self,
        public_inputs_path: &Path,
        pctx: Arc<ProofCtx<F>>,
        ectx: Arc<ExecutionCtx>,
        sctx: Arc<SetupCtx>,
    ) {
        // Create a thread pool to manage the execution of all the state machines related to the
        // execution process
        let pool = ThreadPoolBuilder::new().build().unwrap();

        // Prepare the settings for the emulator
        let emulator_options = EmuOptions {
            elf: Some(self.zisk_rom_path.clone().display().to_string()),
            inputs: Some(public_inputs_path.display().to_string()),
            trace_steps: Some(Self::CALLBACK_SIZE as u64),
            ..EmuOptions::default()
        };

        // Call emulate with these options
        let public_inputs = {
            // Read inputs data from the provided inputs path
            let path = PathBuf::from(public_inputs_path.display().to_string());
            fs::read(path).expect("Could not read inputs file")
        };

        // Execute the emulator inside a thread
        pool.scope(|scope| {
            // Wrap the callback to capture the scope variable
            let callback = |emu_traces: EmuTrace| {
                self.emulator_callback(
                    &self.zisk_rom,
                    emu_traces,
                    scope,
                    pctx.clone(),
                    ectx.clone(),
                    sctx.clone(),
                )
            };

            let result = ZiskEmulator::process_rom(
                &self.zisk_rom,
                &public_inputs,
                &emulator_options,
                Some(Box::new(callback)),
            );

            self.threads_controller.wait_for_threads();

            // Unregister main state machine as a predecessor for all the secondary state machines
            timer_start!(UNREGISTER_PREDECESSORS);
            self.mem_sm.unregister_predecessor::<F>(scope);
            self.binary_sm.unregister_predecessor(scope);
            self.arith_sm.unregister_predecessor::<F>(scope);
            timer_stop_and_log!(UNREGISTER_PREDECESSORS);

            // Eval the return value of the emulator to launch a panic if an error occurred
            if let Err(e) = result {
                panic!("Error during emulator execution: {:?}", e);
            }
        });

        // Terminate the state machines with the remaining inputs
        let mut callback_inputs = self.callback_inputs.lock().unwrap();
        let last_air_segment = callback_inputs.last_mut().unwrap();

        // If `last_air_segment` is full, it means the air instance for the last segment is already
        // created. We need to mark this air instance as the last segment.
        if last_air_segment.filled_inputs == Self::MAX_ACCUMULATED {
            // Get the last segment
            let last_air_segment_idx =
                pctx.air_instance_repo.find_last_segment(MAIN_AIRGROUP_ID, MAIN_AIR_IDS[0]).expect(
                    "MainSM: No last segment found. This should not happen as the last segment is created in the previous block",
                );

            // Look for the last segment and set the last_segment flag to true
            let mut air_instances = pctx.air_instance_repo.air_instances.write().unwrap();

            let air_instance = &mut air_instances[last_air_segment_idx];

            // Get the buffer size and offsets to be able to access the trace
            let (_, offsets) = ectx
                .buffer_allocator
                .as_ref()
                .get_buffer_info(&sctx, MAIN_AIRGROUP_ID, MAIN_AIR_IDS[0])
                .expect("Error getting buffer info");

            // Map the F buffer to a Main0Trace
            let mut main_trace = Main0Trace::<F>::map_buffer(
                &mut air_instance.buffer,
                Self::MAX_ACCUMULATED,
                offsets[0] as usize,
            )
            .unwrap();

            // Set the last segment flag to true
            let main_last_segment = F::from_bool(true);
            for i in 0..main_trace.num_rows() {
                main_trace[i].main_last_segment = main_last_segment;
            }
        } else {
            let air_segment = mem::take(last_air_segment);
            pool.scope(|scope| {
                scope.spawn(move |_| {
                    Self::create_air_instance(air_segment, pctx, ectx, sctx, true);
                });
            });
        }
    }

    // Callback method to process the inputs generated by the emulator
    #[inline(always)]
    fn emulator_callback(
        &'a self,
        zisk_rom: &'a ZiskRom,
        emu_traces: EmuTrace,
        scope: &Scope<'a>,
        pctx: Arc<ProofCtx<F>>,
        ectx: Arc<ExecutionCtx>,
        sctx: Arc<SetupCtx>,
    ) {
        // Compute the AIR segment and the position where the current EmuTrace should be placed
        let air_step = emu_traces.start.step as f64 / Self::MAX_ACCUMULATED as f64;
        let segment_id = air_step.floor() as usize;
        let pos_id =
            (air_step.fract() * Self::MAX_ACCUMULATED as f64 / Self::CALLBACK_SIZE as f64) as usize;

        // As this calls are received sequentially, when pos_id is 0, a new segment is created
        if pos_id == 0 {
            let buffer = MainAirSegment::new(segment_id as u32, Self::MAX_ACCUMULATED);
            self.callback_inputs.lock().unwrap().push(buffer);
        }

        self.threads_controller.add_working_thread();

        scope.spawn(move |scope| {
            // To go faster, we receive from the simulator callback a tiny trace that we are going
            // to process to get the full trace. This is done to avoid the overhead of processing
            // the full trace in the simulator callback and now can be parallelized.
            let emu_slice = match ZiskEmulator::process_slice::<F>(zisk_rom, &emu_traces) {
                Ok(slice) => slice,
                Err(e) => panic!("Error processing slice: {:?}", e),
            };

            let len = emu_slice.full_trace.len();
            let source_iter = emu_slice.full_trace.into_iter();

            let mut inputs = self.callback_inputs.lock().unwrap();
            let air_segment = &mut inputs[segment_id];
            air_segment.inputs.splice(
                pos_id * Self::CALLBACK_SIZE..(pos_id + 1) * Self::CALLBACK_SIZE,
                source_iter,
            );
            air_segment.filled_inputs += len;
            assert!(
                air_segment.filled_inputs <= Self::MAX_ACCUMULATED,
                "Too many inputs in a Main AIR segment"
            );

            // As CALLBACK_SIZE is a power of 2, we can check if the segment is full by checking
            if air_segment.filled_inputs == Self::MAX_ACCUMULATED {
                let air_segment = mem::take(air_segment);
                let cloned_ectx = ectx.clone();
                scope.spawn(move |_| {
                    Self::create_air_instance(air_segment, pctx, cloned_ectx, sctx, false);
                });
            }
            drop(inputs);

            self.prove(emu_slice.required, ectx.clone(), scope);
        });
    }

    /// Proves a batch of inputs
    /// When the maximum number of accumulated inputs is reached, the MainSM state machine processes
    /// the inputs in batches. The inputs are processed in parallel using the thread pool
    /// # Arguments
    /// * `inputs` - Vector of EmuTrace inputs to prove
    /// * `pctx` - Proof context to interact with the proof system
    /// * `ectx` - Execution context to interact with the execution environment
    #[inline(always)]
    fn create_air_instance(
        air_segment: MainAirSegment<F>,
        pctx: Arc<ProofCtx<F>>,
        ectx: Arc<ExecutionCtx>,
        sctx: Arc<SetupCtx>,
        last_segment: bool,
    ) {
        info!(
            "{}: ··· Creating Main segment #{} [{} rows]",
            Self::MY_NAME,
            air_segment.air_segment_id,
            air_segment.filled_inputs
        );
        timer_start!(CREATE_AIR_INSTANCE);

        // Compute buffer size using the BufferAllocator
        let (buffer_size, offsets) = ectx
            .buffer_allocator
            .as_ref()
            .get_buffer_info(&sctx, MAIN_AIRGROUP_ID, MAIN_AIR_IDS[0])
            .unwrap_or_else(|err| panic!("Error getting buffer info: {}", err));

        let mut main_trace = Main0Trace::<F>::map_row_vec(air_segment.inputs, false).unwrap();

        for i in air_segment.filled_inputs..main_trace.num_rows() {
            main_trace[i] = main_trace[i - 1];
        }

        // TODO: Do it in parallel
        let main_first_segment = F::from_bool(air_segment.air_segment_id == 0);
        let main_last_segment = F::from_bool(last_segment);
        let main_segment = F::from_canonical_usize(air_segment.air_segment_id as usize);
        for i in 0..main_trace.num_rows() {
            main_trace[i].main_first_segment = main_first_segment;
            main_trace[i].main_last_segment = main_last_segment;
            main_trace[i].main_segment = main_segment;
        }

        let main_trace_buffer = main_trace.buffer.unwrap();

        let mut buffer = create_buffer_fast(buffer_size as usize);

        let start = offsets[0] as usize;
        let end = start + main_trace_buffer.len();
        use rayon::prelude::*;
        buffer[start..end]
            .par_chunks_mut(main_trace_buffer.len() / rayon::current_num_threads())
            .zip(
                main_trace_buffer
                    .par_chunks(main_trace_buffer.len() / rayon::current_num_threads()),
            )
            .for_each(|(buffer_chunk, main_chunk)| {
                buffer_chunk.copy_from_slice(main_chunk);
            });

        let air_instance = AirInstance::new(
            MAIN_AIRGROUP_ID,
            MAIN_AIR_IDS[0],
            Some(air_segment.air_segment_id as usize),
            buffer,
        );

        pctx.air_instance_repo.add_air_instance(air_instance);

        timer_stop_and_log!(CREATE_AIR_INSTANCE);
    }

    /// Proves a batch of inputs
    /// When the maximum number of accumulated inputs is reached, the MainSM state machine processes
    /// the inputs in batches. The inputs are processed in parallel using the thread pool
    /// # Arguments
    /// * `emu_required` - Inputs to be proved
    /// * `ectx` - Execution context to interact with the execution environment
    #[inline(always)]
    fn prove(&self, mut emu_required: ZiskRequired, _ectx: Arc<ExecutionCtx>, scope: &Scope<'a>) {
        let memory = mem::take(&mut emu_required.memory);
        let _binary = mem::take(&mut emu_required.binary);
        let _arith = mem::take(&mut emu_required.arith);

        let mem_sm = self.mem_sm.clone();
        let _binary_sm = self.binary_sm.clone();
        let _arith_sm = self.arith_sm.clone();

        let threads_controller = self.threads_controller.clone();

        scope.spawn(move |scope| {
            mem_sm.prove(&memory, false, scope);
            // binary_sm.prove(&binary, false, scope);
            //arith_sm.prove(&arith, false, scope);

            threads_controller.remove_working_thread();
        });
    }
}

impl<F: Send + Sync> WitnessComponent<F> for MainSM<F> {
    fn calculate_witness(
        &self,
        _stage: u32,
        _air_instance: Option<usize>,
        _pctx: Arc<ProofCtx<F>>,
        _ectx: Arc<ExecutionCtx>,
        _sctx: Arc<SetupCtx>,
    ) {
    }
}
