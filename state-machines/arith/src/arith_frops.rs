use std::error::Error;
use std::u64::MAX;

use sm_frequent_ops::FrequentOpsHelpers;
use zisk_core::zisk_ops::ZiskOp;

const OP_MULU: u8 = ZiskOp::Mulu.code();
const OP_MULUH: u8 = ZiskOp::Muluh.code();
const OP_MULSUH: u8 = ZiskOp::Mulsuh.code();
const OP_MUL: u8 = ZiskOp::Mul.code();
const OP_MULH: u8 = ZiskOp::Mulh.code();
const OP_MULW: u8 = ZiskOp::MulW.code();
const OP_DIVU: u8 = ZiskOp::Divu.code();
const OP_REMU: u8 = ZiskOp::Remu.code();
const OP_DIV: u8 = ZiskOp::Div.code();
const OP_REM: u8 = ZiskOp::Rem.code();
const OP_DIVUW: u8 = ZiskOp::DivuW.code();
const OP_REMUW: u8 = ZiskOp::RemuW.code();
const OP_DIVW: u8 = ZiskOp::DivW.code();
const OP_REMW: u8 = ZiskOp::RemW.code();

const LOW_VALUES_OPCODES: [u8; 14] = [
    OP_MULU, OP_MULUH, OP_MULSUH, OP_MUL, OP_MULH, OP_MULW, OP_DIVU, OP_REMU, OP_DIV, OP_REM,
    OP_DIVUW, OP_REMUW, OP_DIVW, OP_REMW,
];

const MAX_A_LOW_VALUE: u64 = 386;
const MAX_B_LOW_VALUE: u64 = 386;

// table autogenerated with FrequentOpsTable::print_table_offsets()
// this table is used to calculate the offset (row) of each operation
const OP_TABLE_OFFSETS_START: usize = 176;
const OP_TABLE_OFFSETS: [usize; 16] = [
    0, 148996, 0, 297992, 446988, 595984, 744980, 0, 893976, 1042972, 1191968, 1340964, 1489960,
    1638956, 1787952, 1936948,
];

#[derive(Debug, Clone)]
pub struct ArithFrops {
    table: FrequentOpsHelpers,
}

const FREQUENT_OP_EMPTY: usize = 256;

impl Default for ArithFrops {
    fn default() -> Self {
        Self::new()
    }
}
impl ArithFrops {
    pub const TABLE_ID: usize = 5001;
    pub const NO_FROPS: usize = FrequentOpsHelpers::NO_FROPS;
    pub fn new() -> Self {
        Self { table: FrequentOpsHelpers::new() }
    }

    fn build_low_values_operations(&mut self) {
        let mut ops = self.table.get_low_values_operations(MAX_A_LOW_VALUE, MAX_B_LOW_VALUE);
        for op in LOW_VALUES_OPCODES.iter() {
            self.table.add_ops(*op, &mut ops, false);
        }
    }
    pub fn build_table(&mut self) {
        self.build_low_values_operations();
    }
    #[inline(always)]
    fn get_low_values_offset(a: u64, b: u64) -> usize {
        (a * MAX_B_LOW_VALUE + b) as usize
    }

    #[inline(always)]
    pub fn is_frequent_op(op: u8, a: u64, b: u64) -> bool {
        // Use lookup table for faster branching instead of match on enum
        match op {
            // Low value operations - check bounds first (most common case)
            OP_MULU | OP_MULUH | OP_MULSUH | OP_MUL | OP_MULH | OP_MULW | OP_DIVU | OP_REMU
            | OP_DIV | OP_REM | OP_DIVUW | OP_REMUW | OP_DIVW | OP_REMW => {
                a < MAX_A_LOW_VALUE && b < MAX_B_LOW_VALUE
            }
            _ => false,
        }
    }

    #[inline(always)]
    pub fn get_row(op: u8, a: u64, b: u64) -> usize {
        // ecall/system call functions are not candidates to be usual
        let relative_offset = match op {
            OP_MULU | OP_MULUH | OP_MULSUH | OP_MUL | OP_MULH | OP_MULW | OP_DIVU | OP_REMU
            | OP_DIV | OP_REM | OP_DIVUW | OP_REMUW | OP_DIVW | OP_REMW => {
                if a < MAX_A_LOW_VALUE && b < MAX_B_LOW_VALUE {
                    return OP_TABLE_OFFSETS[op as usize - OP_TABLE_OFFSETS_START]
                        + Self::get_low_values_offset(a, b);
                } else {
                    return FrequentOpsHelpers::NO_FROPS;
                }
            }
            _ => return FrequentOpsHelpers::NO_FROPS,
        };
    }
    #[inline(always)]
    pub fn count(&self) -> usize {
        self.table.count()
    }

    #[cfg(test)]
    pub fn test_table_offsets(&mut self) {
        self.build_table();
        let (start, offsets) = self.table.generate_table_offsets();
        if (start != OP_TABLE_OFFSETS_START) || (offsets != OP_TABLE_OFFSETS) {
            self.table.print_table_offsets();
            panic!("Table offsets do not match expected values");
        }
        assert_eq!(start, OP_TABLE_OFFSETS_START);
        assert_eq!(offsets, OP_TABLE_OFFSETS);
    }
    #[inline(always)]
    pub fn generate_full_table(&self) -> Vec<(u8, u64, u64, u64, bool)> {
        self.table.generate_full_table()
    }
    #[inline(always)]
    pub fn generate_table(&self) -> Vec<(u8, u64, u64)> {
        self.table.generate_table()
    }
    #[inline(always)]
    pub fn generate_cmd(
        &mut self,
        cmd_name: &'static str,
        default_file: &'static str,
    ) -> Result<(), Box<dyn Error>> {
        self.build_table();
        let full_table = self.generate_full_table();
        let full_table_count = full_table.len();
        self.table.generate_cmd(
            "Zisk",
            "ArithFrops",
            cmd_name,
            default_file,
            full_table,
            full_table_count,
        )
    }
}

#[test]
pub fn test_table_offsets() {
    let mut fops = ArithFrops::new();
    fops.test_table_offsets();
}

/*
#[test]
fn test_arith_frequent_ops() {
    let mut fops = ArithFrops::new();
    fops.build_table();
    let table = fops.generate_full_table();

    let tests = [];
    check_tests(&table, &tests);
}

#[test]
fn test_all_arith_accesible_values() {
    let mut fops = ArithFrops::new();
    fops.build_table();
    let table = fops.generate_full_table();
    test_all_accesible_values(&table);
}

#[test]
fn test_airth_low_values() {
    let mut fops = ArithFrops::new();
    fops.build_table();
    let table = fops.generate_full_table();
    test_low_values(&LOW_VALUES_OPCODES, &table, MAX_A_LOW_VALUE, MAX_B_LOW_VALUE);
}
*/
