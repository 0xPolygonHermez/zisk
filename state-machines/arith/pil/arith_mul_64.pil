require "std_lookup.pil"
require "std_range_check.pil"
require "operations.pil"
require "arith_table.pil"

airtemplate ArithMul64(int N = 2**18, const int operation_bus_id, const int dual_result = 0) {

    // NOTE:
    // Divisions and remainders by 0 are done by QuickOps

    const int CHUNK_SIZE = 2**16;
    const int CHUNKS = 8;

    col witness carry[CHUNKS - 1];
    col witness a[4];
    col witness b[4];
    col witness c[4];
    col witness d[4];

    col witness na;     // a is negative
    col witness nb;     // b is negative
    col witness np;     // prod is negative

    col witness fab;    // fab, to decrease degree of intermediate products a * b 
                        // fab = 1  if sign of a,b are the same
                        // fab = -1 if sign of a,b are different

    if (!dual_result) {
        col witness air.secondary_res;       // op_index: 0 => first result, 1 => second result;
        secondary_res * (secondary_res - 1) === 0;        
    } else {
        const expr air.secondary_res = 0;
    }

    // factor ab â‚¬ {-1, 1}
    fab === 1 - 2 * na - 2 * nb + 4 * na * nb;

    const expr eq[CHUNKS]; 

    eq[0] = fab * a[0] * b[0] 
            - c[0]
            + 2 * np * c[0];

    eq[1] = fab * a[1] * b[0] 
            + fab * a[0] * b[1]
            - c[1] 
            + 2 * np * c[1];

    eq[2] = fab * a[2] * b[0]
            + fab * a[1] * b[1] 
            + fab * a[0] * b[2]
            - c[2] 
            + 2 * np * c[2];
                            
    eq[3] = fab * a[3] * b[0]
            + fab * a[2] * b[1]
            + fab * a[1] * b[2]
            + fab * a[0] * b[3]
            - c[3] 
            + 2 * np * c[3];
                            
    eq[4] = fab * a[3] * b[1]
            + fab * a[2] * b[2]
            + fab * a[1] * b[3]
            + na * b[0] * (1 - 2 * nb) 
            + nb * a[0] * (1 - 2 * na)
            - d[0]
            + 2 * np * d[0];

    eq[5] = fab * a[3] * b[2]
            + fab * a[2] * b[3]
            + nb * a[1] * (1 - 2 * na)
            + na * b[1] * (1 - 2 * nb)
            - d[1]
            + 2 * np * d[1];
                            
    eq[6] = fab * a[3] * b[3]
            + nb * a[2] * (1 - 2 * na)
            + na * b[2] * (1 - 2 * nb)
            - d[2] 
            + 2 * np * d[2];
    
    eq[7] = CHUNK_SIZE * na * nb
            + na * b[3] * (1 - 2 * nb)
            + nb * a[3] * (1 - 2 * na)
            - CHUNK_SIZE * np
            - d[3]
            + 2 * np * d[3];

    eq[0] - carry[0] * CHUNK_SIZE === 0;
    for (int index = 1; index < (CHUNKS - 1); ++index) {
        eq[index] + carry[index-1] - carry[index] * CHUNK_SIZE === 0;
    }   

    // binary contraint
    na * (1 - na) === 0;
    nb * (1 - nb) === 0;
    np * (1 - np) === 0;

    col witness op;    

    // div m32 sa  sb  comm primary  secondary  opcodes       na   nb   nr   np na32 nd32 
    // ----------------------------------------------------------------------------------
    //  0   0   0   0    x  mulu     muluh      (0xb0,0xb1)   =0   =0   =0   =0   =0   =0   
    //  0   0   1   0       *n/a*    mulsuh     (0xb2,0xb3)   a3   =0   =0   d3   =0   =0  a3,      d3
    //  0   0   1   1    x  mul      mulh       (0xb4,0xb5)   a3   b3   =0   d3   =0   =0  a3,b3,   d3  

    // (*) removed combinations of flags div,m32,sa,sb did allow combinations div, m32, sa, sb 
    // see 5 previous constraints.
    // =0 means forced to zero by previous constraints
    // comm = commutative (trivial: commutative operations)

    const expr bus_a_low = a[0] + CHUNK_SIZE * a[1];
    const expr bus_a_high = a[2] + CHUNK_SIZE * a[3];


    const expr bus_b_low = b[0] + CHUNK_SIZE * b[1];
    const expr bus_b_high = b[2] + CHUNK_SIZE * b[3];

    const expr res2_low  = d[0] + CHUNK_SIZE * d[1]; 
    const expr res2_high = d[2] + CHUNK_SIZE * d[3];

    if (dual_result) {
        // theorical cost: 4 columns
        col witness multiplicity_2;
        lookup_proves(operation_bus_id, [op+1, bus_a_low, bus_a_high, bus_b_low, bus_b_high, res2_low, res2_high, 0], mul: multiplicity_2);

        const expr air.res1_low = a[0] + c[0] + CHUNK_SIZE * a[1] + CHUNK_SIZE * c[1] - bus_a_low;
        const expr air.res1_high = c[2] + CHUNK_SIZE * c[3];
    } else {
        col witness air.res1_low;
        res1_low === secondary_res * res2_low - (1 - secondary_res)  * (a[0] + c[0] + CHUNK_SIZE * a[1] + CHUNK_SIZE * c[1] - bus_a_low);
        
        col witness air.res1_high;
        // res1_high === secondary_res * res2_high + (1 - secondary_res) * ((1 - m32) * (div * (a[2] - c[2]) + c[2] + 2**16 * div * (a[3] - c[3]) + 2**16 * c[3]) + div * na32 * 0xFFFFFFFF + (1 - div) * nd32 * 0xFFFFFFFF);
        res1_high === secondary_res * res2_high + (1 - secondary_res) * (c[2] + CHUNK_SIZE * c[3]);
    }
    

    col witness multiplicity;

    lookup_proves(operation_bus_id, [op + secondary_res,
                                     bus_a_low, bus_a_high, 
                                     bus_b_low, bus_b_high, 
                                     res1_low, res1_high,
//                                     secondary_res * (res2_low - res1_low) + res1_low, 
//                                     secondary_res * (res2_high - res1_high) + res1_high,
                                     0], mul: multiplicity);

    for (int index = 0; index < length(carry); ++index) {
         range_check(colu: carry[index], min:-2**20, max: 2**20-1);     // TODO: review range
    }

    // loop for range checks index 0, 2
    for (int index = 0; index < 3; ++index) {
        range_check(colu: a[index], min:0, max: CHUNK_SIZE-1);
        range_check(colu: b[index], min:0, max: CHUNK_SIZE-1);
        range_check(colu: c[index], min:0, max: CHUNK_SIZE-1);
        range_check(colu: d[index], min:0, max: CHUNK_SIZE-1);
    }  

    range_check(colu: c[3], min:0, max: 2**16-1);

    col witness range_a3;
    col witness range_b3;
    col witness range_d3;

    lookup_assumes(ARITH_TABLE_ID, cols: [ op, 4 * na + 8 * nb + 32 * np + 2**16 * range_a3 + 2**18 * range_b3 + 2**22 * range_d3]);
    
    range_a3 * (1 - range_a3) * (2 - range_a3) === 0;
    range_b3 * (1 - range_b3) * (2 - range_b3) === 0;
    range_d3 * (1 - range_d3) * (2 - range_d3) === 0;

    lookup_assumes(QUICK_RANGE_TABLE_ID, [range_a3, a[3]]);
    lookup_assumes(QUICK_RANGE_TABLE_ID, [range_b3, b[3]]);
    lookup_assumes(QUICK_RANGE_TABLE_ID, [range_d3, d[3]]);
}