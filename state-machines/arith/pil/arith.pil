require "std_lookup.pil"
require "std_range_check.pil"
require "operations.pil"
require "arith_table.pil"
require "arith_range_table.pil"

//          full   mul_64  full_32  mul_32
// TOTAL      88       77       57      44

airtemplate Arith(int N = 2**18, const int operation_bus_id, const int dual_result = 0) {
    // TODO: const int enable_div = 1, const int enable_32_bits = 1, const int enable_64_bits = 1

    // NOTE:
    // Divisions and remainders by 0 are done by QuickOps

    const int CHUNK_SIZE = 2**16;
    const int CHUNKS_INPUT = 4;
    const int CHUNKS_OP = CHUNKS_INPUT * 2;

    col witness carry[CHUNKS_OP - 1];
    col witness a[CHUNKS_INPUT];
    col witness b[CHUNKS_INPUT];
    col witness c[CHUNKS_INPUT];
    col witness d[CHUNKS_INPUT];

    col witness na;     // a is negative
    col witness nb;     // b is negative
    col witness nr;     // rem is negative
    col witness np;     // prod is negative
    col witness sext;   // sign extend for 32 bits result

    col witness m32;    // 32 bits operation
    col witness div;    // division operation (div,rem)

    col witness fab;    // fab, to decrease degree of intermediate products a * b
                        // fab = 1  if sign of a,b are the same
                        // fab = -1 if sign of a,b are different

    col witness na_fb;
    col witness nb_fa;

    col witness debug_main_step; // only for debug

    col witness secondary_res;       // op_index: 0 => first result, 1 => second result;
    secondary_res * (secondary_res - 1) === 0;

    // factor ab € {-1, 1}
    fab === 1 - 2 * na - 2 * nb + 4 * na * nb;
    na_fb === na * (1 - 2 * nb);
    nb_fa === nb * (1 - 2 * na);

    const expr eq[CHUNKS_OP];

    // NOTE: Equations with m32 for multiplication not exists, because mul m32 it's an unsigned operation.
    //       In internal equations, it's same than unsigned mul 64 where high part of a and b are zero

    // abs(x)  x >= 0 ➜ nx == 0 ➜ x
    //         x < 0  ➜ nx == 1 ➜ 2^64 - x
    //
    // abs(x,nx) = nx * (2^64 - 2 * x) + x = 2^64 * nx - 2 * nx * x + x
    //
    //    chunk[0] = x[0] - 2 * nx + x[0]  // 2^0
    //    chunk[1] = x[1] - 2 * nx + x[1]  // 2^16
    //    chunk[2] = x[2] - 2 * nx + x[2]  // 2^24
    //    chunk[3] = x[3] - 2 * nx + x[3]  // 2^48
    //    chunk[4] = nx                    // 2^64
    //
    //    or chunk[3] = x[3] - 2 * nx + x[3] + 2^16 * nx
    //       chunk[4] = 0
    //
    //    dual use of d, on multiplication d is high part of result, while in division d
    //    is the remainder. Selector of these two uses is div or nr (because nr = 0 for div = 0)
    //
    //    div = 0  ➜   a * b = 2^64 * d + c ➜  a * b - 2^64 * d - c === 0
    //    div = 1  ➜   a * b + d = c ➜  a * b - c + d === 0
    //
    //    eq = a * b + c - div * d - (1 - div) * 2^64 * d

    eq[0] = fab * a[0] * b[0]
            - c[0]              // ⎫ np == 0 ➜ - c
            + 2 * np * c[0]     // ⎭ np == 1 ➜ - c + 2c = c
            + div * d[0]        // ⎫ div == 0 ➜ nr = 0  ➜ 0
            - 2 * nr * d[0];    // ⎥ div == 1 and nr == 0 ➜ d
                                // ⎭ div == 1 and nr == 1 ➜ d - 2d = -d

    eq[1] = fab * a[1] * b[0]
            + fab * a[0] * b[1]
            - c[1]              // ⎫ np == 0 ➜ - c
            + 2 * np * c[1]     // ⎭ np == 1 ➜ c
            + div * d[1]        // ⎫ div == 1 ➜ d or -d
            - 2 * nr * d[1];    // ⎭ div == 0 ➜ 0

    eq[2] = fab * a[2] * b[0]
            + fab * a[1] * b[1]
            + fab * a[0] * b[2]
            + a[0] * nb_fa * m32 // ⎫ sign contribution when m32
            + b[0] * na_fb * m32 // ⎭
            - c[2]               // ⎫ np == 0 ➜ - c
            + 2 * np * c[2]      // ⎭ np == 1 ➜ c
            + div * d[2]         // ⎫ div == 1 ➜ d or -d
            - 2 * nr * d[2]      // ⎭ div == 0 ➜ 0
            - np * div * m32     // m32 == 1 and np == 1 ➜ -2^32 (global) or -1 (in 3rd chunk)
            + nr * m32;          // m32 == 1 and nr == 1 ➜ div == 1 ➜ 2^32 (global) or 1 (in 3rd chunk)

    eq[3] = fab * a[3] * b[0]
            + fab * a[2] * b[1]
            + fab * a[1] * b[2]
            + fab * a[0] * b[3]  // NOTE: m32 => high part is 0
            + a[1] * nb_fa * m32 // ⎫ sign contribution when m32
            + b[1] * na_fb * m32 // ⎭
            - c[3]               // ⎫ np == 0 ➜ - c
            + 2 * np * c[3]      // ⎭ np == 1 ➜ c
            + div * d[3]         // ⎫ div == 1 ➜ d or -d
            - 2 * nr * d[3];     // ⎭ div == 0 ➜ 0

    eq[4] = fab * a[3] * b[1]
            + fab * a[2] * b[2]
            + fab * a[1] * b[3]
            + na * nb * m32
            // + b[0] * na * (1 - 2 * nb)
            // + a[0] * nb * (1 - 2 * na)
            + b[0] * na_fb * (1 - m32)
            + a[0] * nb_fa * (1 - m32)

            - np * m32 * (1 - div)  //
            - np * (1 - m32) * div // 2^64 (np)
            + nr * (1 - m32)  // 2^64 (nr)

            - d[0] * (1 - div)           // 3 degree
            + 2 * np * d[0] * (1 - div); // 3 degree

    eq[5] = fab * a[3] * b[2]       // 3 degree
            + fab * a[2] * b[3]     // 3 degree
            + a[1] * nb_fa * (1 - m32)
            + b[1] * na_fb * (1 - m32)
            - d[1] * (1 - div)
            + d[1] * 2 * np * (1 - div);

    eq[6] = fab * a[3] * b[3]            // 3 degree
            + a[2] * nb_fa * (1 - m32)
            + b[2] * na_fb * (1 - m32)
            - d[2] * (1 - div)
            + 2 * np * d[2] * (1 - div); // 3 degree

    eq[7] = CHUNK_SIZE * na * nb * (1 - m32)
            + a[3] * nb_fa * (1 - m32)
            + b[3] * na_fb * (1 - m32)
            - CHUNK_SIZE * np * (1 - div) * (1 - m32) // 3 degree
            // - CHUNK_SIZE * np * (1 - div)
            - d[3] * (1 - div)
            + 2 * np * d[3] * (1 - div); // 3 degree

    eq[0] - carry[0] * CHUNK_SIZE === 0;
    for (int index = 1; index < (CHUNKS_OP - 1); ++index) {
        eq[index] + carry[index-1] - carry[index] * CHUNK_SIZE === 0;
    }
    eq[CHUNKS_OP-1] + carry[CHUNKS_OP-2] === 0;

    // binary contraint
    div * (1 - div) === 0;
    m32 * (1 - m32) === 0;
    na * (1 - na) === 0;
    nb * (1 - nb) === 0;
    nr * (1 - nr) === 0;
    np * (1 - np) === 0;
    sext * (1 - sext) === 0;

    col witness op;

    // div m32 sa  sb  primary  secondary  opcodes       na   nb   np   nr    sext
    // -----------------------------------------------------------------------------
    //  0   0   0   0  mulu     muluh      (0xb0,0xb1)   =0   =0   =0   =0   =0   =0
    //  0   0   1   0  *n/a*    mulsuh     (0xb2,0xb3)   a3   =0   d3   =0   =0   =0  a3,      d3
    //  0   0   1   1  mul      mulh       (0xb4,0xb5)   a3   b3   d3   =0   =0   =0  a3,b3,   d3
    //  0   1   0   0  mul_w    *n/a*      (0xb6,0xb7)   =0   =0   =0   =0   c1   =0               a1,b1,c1
    //  1   0   0   0  divu     remu       (0xb8,0xb9)   =0   =0   =0   =0   =0   =0
    //  1   0   1   1  div      rem        (0xba,0xbb)   a3   b3   c3   d3   =0   =0  a3,b3,c3,d3
    //  1   1   0   0  divu_w   remu_w     (0xbc,0xbd)   =0   =0   =0   =0   c1   d1                     c1,d1
    //  1   1   1   1  div_w    rem_w      (0xbe,0xbf)   a1   b1   c1   d1   c1   d1               a1,b1,c1,d1


    // div m32 sa  sb  primary  secondary  opcodes       na   nb   np   nr   sext(c)
    // -----------------------------------------------------------------------------
    //  0   0   0   0  mulu     muluh      (0xb0,0xb1)   =0   =0   =0   =0   =0   =0
    //  0   0   1   0  *n/a*    mulsuh     (0xb2,0xb3)   a3   =0   d3   =0   =0   =0  a3,      d3
    //  0   0   1   1  mul      mulh       (0xb4,0xb5)   a3   b3   d3   =0   =0   =0  a3,b3,   d3
    //  0   1   0   0  mul_w    *n/a*      (0xb6,0xb7)   =0   =0   =0   =0   c1   =0

    // div m32 sa  sb  primary  secondary  opcodes       na   nb   np   nr   sext(a,d)(*2)
    // ------------------------------------------------------------------------------
    //  1   0   0   0  divu     remu       (0xb8,0xb9)   =0   =0   =0   =0   =0   =0
    //  1   0   1   1  div      rem        (0xba,0xbb)   a3   b3   c3   d3   =0   =0  a3,b3,c3,d3
    //  1   1   0   0  divu_w   remu_w     (0xbc,0xbd)   =0   =0   =0   =0   a1   d1               a1      ,d1
    //  1   1   1   1  div_w    rem_w      (0xbe,0xbf)   a1   b1   c1   d1   a1   d1               a1,b1,c1,d1

    // (*) removed combinations of flags div,m32,sa,sb did allow combinations div, m32, sa, sb
    // (*2) sext affects to 32 bits result (bus), but in divisions a is used as result
    // see 5 previous constraints.
    // =0 means forced to zero by previous constraints

    // bus result     primary  secondary
    // ----------------------------------
    // mul (mulh)           c       d
    // div (remu)           a       d

    col witness bus_a_low;
    bus_a_low === div * (c[0] + c[1] * CHUNK_SIZE) + (1 - div) * (a[0] + a[1] * CHUNK_SIZE);

    col witness bus_a_high;
    bus_a_high === div * (c[2] + c[3] * CHUNK_SIZE) + (1 - div) * (a[2] + a[3] * CHUNK_SIZE);

    m32 * (1 - bus_a_high) === 0;

    const expr bus_b_low = b[0] + CHUNK_SIZE * b[1];
    const expr bus_b_high = b[2] + CHUNK_SIZE * b[3];

    m32 * (1 - b[2]) === 0;
    m32 * (1 - b[3]) === 0;

    const expr res2_low  = d[0] + CHUNK_SIZE * d[1];
    const expr res2_high = d[2] + CHUNK_SIZE * d[3];

    col witness res_low;
    res_low === secondary_res * res2_low + (1 - secondary_res)  * (a[0] + c[0] + CHUNK_SIZE * (a[1] + c[1]) - bus_a_low);

    col witness res_high;
    res_high === (1 - m32) * (secondary_res * res2_high + (1 - secondary_res)  * (a[2] + c[2] + CHUNK_SIZE * (a[3] + c[3]) - bus_a_high))
                   + sext * 0xFFFFFFFF;

    col witness multiplicity;

    lookup_proves(operation_bus_id, [debug_main_step,
                                     op + secondary_res,
                                     bus_a_low, bus_a_high,
                                     bus_b_low, bus_b_high,
                                     res_low, res_high,
                                     0], mul: multiplicity);


    // TODO: review
    lookup_assumes(operation_bus_id, [debug_main_step, OP_LT, res2_low, res2_high, bus_b_low, bus_b_high, 0, 1, 1], sel: div);

    for (int index = 0; index < length(carry); ++index) {
         range_check(colu: carry[index], min:-2**20, max: 2**20-1);     // TODO: review carry range
    }

    // mul  a * b = c + d * 2^64
    // div  a * b + d = c   (a <=> c)

    // range_ab / range_cd
    //
    //     a3 a1 b3 b1
    // rid c3 c1 d3 d1 range 2^16 2^15 notes
    // --- -- -- -- -- ----- ---- ---- -------------------------
    //   0  F  F  F  F ab cd    4    0
    //   1  F  F  +  F    cd    3    1 b3 sign => a3 sign
    //   2  F  F  -  F    cd    3    1 b3 sign => a3 sign
    //   3  +  F  F  F ab       3    1 c3 sign => d3 sign
    //   4  +  F  +  F ab cd    2    2
    //   5  +  F  -  F ab cd    2    2
    //   6  -  F  F  F ab       3    1 c3 sign => d3 sign
    //   7  -  F  +  F ab cd    2    2
    //   8  -  F  -  F ab cd    2    2
    //   9  F  F  F  +    cd           a1 sign <=> b1 sign / d1 sign => c1 sign
    //  10  F  F  F  -    cd           a1 sign <=> b1 sign / d1 sign => c1 sign
    //  11  F  +  F  F ab cd    3    1 *a1 for sext/divu
    //  12  F  +  F  + ab cd    2    2
    //  13  F  +  F  - ab cd    2    2
    //  14  F  -  F  F ab cd    3    1 *a1 for sext/divu
    //  15  F  -  F  + ab cd    2    2
    //  16  F  -  F  - ab cd    2    2
    //                       ---- ----
    //                         38   22 = 60
    //
    // F: [0..2^16-1]   +:[0..2^15-1]   -:[2^15..2^16-1]
    //
    // 22 * 2^15 + 38 * 2^16 = (11+38) * 2^16 = 49 * 2^16 < 2^6 * 2^16 ==> 22 bits

    col witness range_ab;
    col witness range_cd;

    arith_table_assumes(op, m32, div, na, nb, np, nr, sext, secondary_res, range_ab, range_cd);

    // 0 - a1/c1
    // 1 - b1/d1
    // 2 - a3/c3
    // 3 - b3/d3

    arith_range_table_assumes(range_ab, 0, a[1]);
    arith_range_table_assumes(range_ab, 1, b[1]);
    arith_range_table_assumes(range_cd, 0, c[1]);
    arith_range_table_assumes(range_cd, 1, d[1]);
    arith_range_table_assumes(range_ab, 2, a[3]);
    arith_range_table_assumes(range_ab, 3, b[3]);
    arith_range_table_assumes(range_cd, 2, c[3]);
    arith_range_table_assumes(range_cd, 3, d[3]);

    // loop for range checks index 0, 2
    for (int index = 0; index < 2; ++index) {
        arith_range_table_assumes(0, 0, a[2 * index]);
        arith_range_table_assumes(0, 0, b[2 * index]);
        arith_range_table_assumes(0, 0, c[2 * index]);
        arith_range_table_assumes(0, 0, d[2 * index]);
    }

}
