require "std_lookup.pil"
require "std_range_check.pil"
require "operations.pil"
require "arith_table.pil"
require "arith_range_table.pil"

//          full   mul_64  full_32  mul_32
// TOTAL      88       77       57      44

airtemplate Arith(int N = 2**18, const int operation_bus_id, const int dual_result = 0) {
    // TODO: const int enable_div = 1, const int enable_32_bits = 1, const int enable_64_bits = 1

    // NOTE:
    // Divisions and remainders by 0 are done by QuickOps

    const int CHUNK_SIZE = 2**16;
    const int CHUNKS_INPUT = 4;
    const int CHUNKS_OP = CHUNKS_INPUT * 2;

    col witness carry[CHUNKS_OP - 1];
    col witness a[CHUNKS_INPUT];
    col witness b[CHUNKS_INPUT];
    col witness c[CHUNKS_INPUT];
    col witness d[CHUNKS_INPUT];

    col witness na;     // a is negative
    col witness nb;     // b is negative
    col witness nr;     // rem is negative
    col witness np;     // prod is negative
    col witness sext;   // sign extend for 32 bits result

    col witness m32;    // 32 bits operation
    col witness div;    // division operation (div,rem)

    col witness fab;    // fab, to decrease degree of intermediate products a * b
                        // fab = 1  if sign of a,b are the same
                        // fab = -1 if sign of a,b are different

    col witness debug_main_step; // only for debug

    col witness secondary_res;       // op_index: 0 => first result, 1 => second result;
    secondary_res * (secondary_res - 1) === 0;

    // factor ab â‚¬ {-1, 1}
    fab === 1 - 2 * na - 2 * nb + 4 * na * nb;

    const expr eq[CHUNKS_OP];

    // NOTE: Equations with m32 for multiplication not exists, because mul m32 it's an unsigned operation.
    //       In internal equations, it's same than unsigned mul 64 where high part of a and b are zero

    eq[0] = fab * a[0] * b[0]   // 3 degree
            - c[0]
            + 2 * np * c[0]
            + div * d[0]
            - 2 * nr * d[0];

    eq[1] = fab * a[1] * b[0]    // 3 degree
            + fab * a[0] * b[1]  // 3 degree
            - c[1]
            + 2 * np * c[1]
            + div * d[1]
            - 2 * nr * d[1];

    eq[2] = fab * a[2] * b[0]    // 3 degree
            + fab * a[1] * b[1]  // 3 degree
            + fab * a[0] * b[2]  // 3 degree
            - c[2]
            + 2 * np * c[2]
            + div * d[2]
            - 2 * nr * d[2]
            - np * div * m32     // 3 degree
            + nr * div * m32;    // 3 degree

    eq[3] = fab * a[3] * b[0]    // 3 degree
            + fab * a[2] * b[1]  // 3 degree
            + fab * a[1] * b[2]  // 3 degree
            + fab * a[0] * b[3]  // 3 degree
            - c[3]
            + 2 * np * c[3]
            + div * d[3]
            - 2 * nr * d[3];

    eq[4] = fab * a[3] * b[1]    // 3 degree
            + fab * a[2] * b[2]  // 3 degree
            + fab * a[1] * b[3]  // 3 degree
            + na * b[0] * (1 - 2 * nb) // 3 degree
            + nb * a[0] * (1 - 2 * na) // 3 degree
            - np * div                 //            |
            + np * div * m32           // 3 degree   | np * (div ^ m32)
            - 2 * div * m32 * np       // 3 degree   |
            // + nr * (1 - m32) * div     // 3 degree
            - d[0] * (1 - div)
            + 2 * np * d[0] * (1 - div); // 3 degree

    eq[5] = fab * a[3] * b[2]       // 3 degree
            + fab * a[2] * b[3]     // 3 degree
            + nb * a[1] * (1 - 2 * na)
            + na * b[1] * (1 - 2 * nb)
            - d[1] * (1 - div)
            + 2 * np * d[1] * (1 - div);

    eq[6] = fab * a[3] * b[3]            // 3 degree
            + nb * a[2] * (1 - 2 * na)   // 3 degree
            + na * b[2] * (1 - 2 * nb)   // 3 degree
            - d[2] * (1 - div)
            + 2 * np * d[2] * (1 - div); // 3 degree

    eq[7] = CHUNK_SIZE * na * nb
            + na * b[3] * (1 - 2 * nb)   // 3 degree
            + nb * a[3] * (1 - 2 * na)   // 3 degree
            // - CHUNK_SIZE * np * (1 - div) * (1 - m32) // 3 degree
            - CHUNK_SIZE * np * (1 - div)
            - d[3] * (1 - div)
            + 2 * np * d[3] * (1 - div); // 3 degree

    eq[0] - carry[0] * CHUNK_SIZE === 0;
    for (int index = 1; index < (CHUNKS_OP - 1); ++index) {
        eq[index] + carry[index-1] - carry[index] * CHUNK_SIZE === 0;
    }
    eq[CHUNKS_OP-1] + carry[CHUNKS_OP-2] === 0;

    // binary contraint
    div * (1 - div) === 0;
    m32 * (1 - m32) === 0;
    na * (1 - na) === 0;
    nb * (1 - nb) === 0;
    nr * (1 - nr) === 0;
    np * (1 - np) === 0;
    sext * (1 - sext) === 0;

    col witness op;

    // div m32 sa  sb  primary  secondary  opcodes       na   nb   np   nr    sext
    // -----------------------------------------------------------------------------
    //  0   0   0   0  mulu     muluh      (0xb0,0xb1)   =0   =0   =0   =0   =0   =0
    //  0   0   1   0  *n/a*    mulsuh     (0xb2,0xb3)   a3   =0   d3   =0   =0   =0  a3,      d3
    //  0   0   1   1  mul      mulh       (0xb4,0xb5)   a3   b3   d3   =0   =0   =0  a3,b3,   d3
    //  0   1   0   0  mul_w    *n/a*      (0xb6,0xb7)   =0   =0   =0   =0   c1   =0               a1,b1,c1
    //  1   0   0   0  divu     remu       (0xb8,0xb9)   =0   =0   =0   =0   =0   =0
    //  1   0   1   1  div      rem        (0xba,0xbb)   a3   b3   c3   d3   =0   =0  a3,b3,c3,d3
    //  1   1   0   0  divu_w   remu_w     (0xbc,0xbd)   =0   =0   =0   =0   c1   d1                     c1,d1
    //  1   1   1   1  div_w    rem_w      (0xbe,0xbf)   a1   b1   c1   d1   c1   d1               a1,b1,c1,d1

    // (*) removed combinations of flags div,m32,sa,sb did allow combinations div, m32, sa, sb
    // see 5 previous constraints.
    // =0 means forced to zero by previous constraints

    // bus result     mul     div
    // --------------------------------
    // primary         c       a
    // secondary       d       d

    col witness bus_a_low;
    bus_a_low === div * (c[0] + c[1] * CHUNK_SIZE) + (1 - div) * (a[0] + a[1] * CHUNK_SIZE);

    col witness bus_a_high;
    bus_a_high === div * (c[2] + c[2] * CHUNK_SIZE) + (1 - div) * (a[2] + a[3] * CHUNK_SIZE);

    m32 * (1 - bus_a_high) === 0;

    const expr bus_b_low = b[0] + CHUNK_SIZE * b[1];
    const expr bus_b_high = b[2] + CHUNK_SIZE * b[3];

    m32 * (1 - b[2]) === 0;
    m32 * (1 - b[3]) === 0;

    const expr res2_low  = d[0] + CHUNK_SIZE * d[1];
    const expr res2_high = d[2] + CHUNK_SIZE * d[3];

    col witness res_low;
    res_low === secondary_res * res2_low + (1 - secondary_res)  * (a[0] + c[0] + CHUNK_SIZE * (a[1] + c[1]) - bus_a_low);

    col witness res_high;
    res_high === (1 - m32) * (secondary_res * res2_high + (1 - secondary_res)  * (a[2] + c[2] + CHUNK_SIZE * (a[3] + c[3]) - bus_a_high))
                   + sext * 0xFFFFFFFF;

    col witness multiplicity;

    lookup_proves(operation_bus_id, [debug_main_step,
                                     op + secondary_res,
                                     bus_a_low, bus_a_high,
                                     bus_b_low, bus_b_high,
                                     res_low, res_high,
                                     0], mul: multiplicity);


    // TODO: review
    lookup_assumes(operation_bus_id, [debug_main_step, OP_LT, res2_low, res2_high, bus_b_low, bus_b_high, 0, 1, 1], sel: div);

    for (int index = 0; index < length(carry); ++index) {
         range_check(colu: carry[index], min:-2**20, max: 2**20-1);     // TODO: review carry range
    }

    // mul  a * b = c + d * 2^64
    // div  a * b + d = c   (a <=> c)

    // range_ab / range_cd
    //
    //     a3 a1 b3 b1
    // rid c3 c1 d3 d1 range 2^16 2^15 notes
    // --- -- -- -- -- ----- ---- ---- -------------------------
    //   0  F  F  F  F ab cd    4    0
    //   1  F  F  +  F    cd    3    1 b3 sign => a3 sign
    //   2  F  F  -  F    cd    3    1 b3 sign => a3 sign
    //   3  +  F  F  F ab       3    1 c3 sign => d3 sign
    //   4  +  F  +  F ab cd    2    2
    //   5  +  F  -  F ab cd    2    2
    //   6  -  F  F  F ab       3    1 c3 sign => d3 sign
    //   7  -  F  +  F ab cd    2    2
    //   8  -  F  -  F ab cd    2    2
    //   9  F  F  F  +    cd           a1 sign <=> b1 sign / d1 sign => c1 sign
    //  10  F  F  F  -    cd           a1 sign <=> b1 sign / d1 sign => c1 sign
    //  11  F  +  F  F    cd    3    1 a1 sign <=> b1 sign
    //  12  F  +  F  + ab cd    2    2
    //  13  F  +  F  - ab cd    2    2
    //  14  F  -  F  F    cd    3    1 a1 sign <=> b1 sign
    //  15  F  -  F  + ab cd    2    2
    //  16  F  -  F  - ab cd    2    2
    //                       ---- ----
    //                         38   22 = 60
    //
    // F: [0..2^16-1]   +:[0..2^15-1]   -:[2^15..2^16-1]
    //
    // 22 * 2^15 + 38 * 2^16 = (11+38) * 2^16 = 49 * 2^16 < 2^6 * 2^16 ==> 22 bits

    col witness range_ab;
    col witness range_cd;

    arith_table_assumes(op, m32, div, na, nb, np, nr, sext, range_ab, range_cd);

    // 0 - a1/c1
    // 1 - b1/d1
    // 2 - a3/c3
    // 3 - b3/d3

    arith_range_table_assumes(range_ab, 0, a[1]);
    arith_range_table_assumes(range_ab, 1, b[1]);
    arith_range_table_assumes(range_cd, 0, c[1]);
    arith_range_table_assumes(range_cd, 1, d[1]);
    arith_range_table_assumes(range_ab, 2, a[3]);
    arith_range_table_assumes(range_ab, 3, b[3]);
    arith_range_table_assumes(range_cd, 2, c[3]);
    arith_range_table_assumes(range_cd, 3, d[3]);

    // loop for range checks index 0, 2
    for (int index = 0; index < 2; ++index) {
        arith_range_table_assumes(0, 0, a[2 * index]);
        arith_range_table_assumes(0, 0, b[2 * index]);
        arith_range_table_assumes(0, 0, c[2 * index]);
        arith_range_table_assumes(0, 0, d[2 * index]);
    }

}
