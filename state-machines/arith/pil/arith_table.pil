require "std_lookup.pil"

const int ARITH_TABLE_ID = 331;

airtemplate ArithTable(int N = 2**8, int generate_table = 1) {

    // TABLE
    // op,m32|div|na|nb|np|nr|sext,range_ab,range_cd

    // div m32 sa  sb  primary  secondary  opcodes       na   nb   np   nr   sext(c)
    // -----------------------------------------------------------------------------
    //  0   0   0   0  mulu     muluh      (0xb0,0xb1)   =0   =0   =0   =0   =0   =0
    //  0   0   1   0  *n/a*    mulsuh     (0xb2,0xb3)   a3   =0   d3   =0   =0   =0  a3,      d3
    //  0   0   1   1  mul      mulh       (0xb4,0xb5)   a3   b3   d3   =0   =0   =0  a3,b3,   d3
    //  0   1   0   0  mul_w    *n/a*      (0xb6,0xb7)   =0   =0   =0   =0   c1   =0

    // div m32 sa  sb  primary  secondary  opcodes       na   nb   np   nr   sext(a,d)(*2)
    // ------------------------------------------------------------------------------
    //  1   0   0   0  divu     remu       (0xb8,0xb9)   =0   =0   =0   =0   =0   =0
    //  1   0   1   1  div      rem        (0xba,0xbb)   a3   b3   c3   d3   =0   =0  a3,b3,c3,d3
    //  1   1   0   0  divu_w   remu_w     (0xbc,0xbd)   =0   =0   =0   =0   a1   d1               a1      ,d1
    //  1   1   1   1  div_w    rem_w      (0xbe,0xbf)   a1   b1   c1   d1   a1   d1               a1,b1,c1,d1

    const int OPS[14] = [0xb0, 0xb1, 0xb3, 0xb4, 0xb5, 0xb6, 0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe, 0xbf];

    col fixed OP;
    col fixed FLAGS;
    col fixed RANGE_AB;
    col fixed RANGE_CD;

    int index = 0;
    int aborted = 0;

    if (generate_table) {
        int air.op2row[512];
        for (int i = 0; i < 512; ++i) {
            op2row[i] = -1;
        }
    }

    for (int opcode = 0xb0; opcode <= 0xbf; ++opcode) {
        if (opcode == 0xb2 || opcode == 0xb7) {
            continue;
        }
        int m32 = 0;    // 32 bits operation
        int div = 0;    // division operation (div,rem)
        int sa = 0;
        int sb = 0;
        int secondary = 0;
        string opname = "";
        switch (opcode) {
            case 0xb0:
                opname = "mulu";
            case 0xb1:
                opname = "mulh";
                secondary = 1;
            case 0xb3:
                opname = "mulsuh";
                sa = 1;
            case 0xb4:
                opname = "mul";
                sa = 1;
                sb = 1;
            case 0xb5:
                opname = "mulh";
                sa = 1;
                sb = 1;
                secondary = 1;
            case 0xb6:
                opname = "mul_w";
                m32 = 1;
                sa = 1;
                sb = 1;
            case 0xb8:
                opname = "divu";
                div = 1;
            case 0xb9:
                opname = "remu";
                div = 1;
                secondary = 1;
            case 0xba:
                opname = "div";
                sa = 1;
                sb = 1;
                div = 1;
            case 0xbb:
                opname = "rem";
                sa = 1;
                sb = 1;
                div = 1;
                secondary = 1;
            case 0xbc:
                opname = "divu_w";
                div = 1;
                m32 = 1;
            case 0xbd:
                opname = "remu_w";
                div = 1;
                m32 = 1;
                secondary = 1;
            case 0xbe:
                opname = "div_w";
                sa = 1;
                sb = 1;
                div = 1;
                m32 = 1;
            case 0xbf:
                opname = "rem_w";
                sa = 1;
                sb = 1;
                div = 1;
                m32 = 1;
                secondary = 1;
        }

        for (int icase = 0; icase < 32; ++icase) {
            int na = 0x01 & icase ? 1 : 0;
            int nb = 0x02 & icase ? 1 : 0;
            int np = 0x04 & icase ? 1 : 0;
            int nr = 0x08 & icase ? 1 : 0;
            int sext = 0x10 & icase ? 1 : 0;

            if (sext && !m32) continue;
            if (nr && !div) continue;
            if (na && !sa) continue;
            if (nb && !sb) continue;
            if (np && !sa && !sb) continue;
            if (nr && !sa && !sb) continue;
            if (np && !na && !nb && !div) continue;
            if (np && na && nb) continue;
            if (!np & nr) continue;

            int range_a1 = m32 * sa ? 1 + na : 0;
            int range_b1 = m32 * sb ? 1 + nb : 0;

            int range_c1 = 0;
            if (m32) {
                if (div) {
                    // range_c1 = np || na32 ? 2 : 1;
                } else {
                    // range_c1 = 1 + na32;
                }
            }
            int range_d1 = m32 * div ? (((np * sa) || sext) ? 1:2) : 0;

            int range_a3 = (1 - m32) * sa ? 1 + na : 0;
            int range_b3 = (1 - m32) * sb ? 1 + na : 0;
            int range_c3 = div * (1 - m32) * sa ? 1 + np : 0;
            int range_d3 = div * (1 - m32) * sa ? 1 + np : 0;

            if (generate_table) {
                op2row[(opcode - 0xb0) * 32 + icase] = index;
            }
            println(`==> #${index} op:${opname} [${opcode}] na:${na} nb:${nb} np:${np} nr:${nr} sext:${sext} sa:${sa} sb:${sb} secondary:${secondary}`);
            ++index;
        }
    }
/*
        int cases = 1 + 2 * sa + 2 * sb + sa * sb;
        for (int sext = 0; sext < (1 + m32); ++sext) {
            for (int icase = 0; icase < cases; ++icase) {

                int na = 0;         // a is negative
                int nb = 0;         // b is negative
                int a_is_zero = 0;  // a is zero
                int b_is_zero = 0;  // b is zero
                int np = 0;         // prod is negative
                int nr = 0;         // rem is negative
                int abort_case = 0; // if abort copy values of row 0
                switch (icase) {
                    // case 0: [a >= 0, b >= 0]
                    case 1:
                        // [a < 0, b > 0]
                        na = 1;
                    case 2:
                        // [a < 0, b = 0]
                        na = 1;
                        b_is_zero = 1;
                    case 3:
                        //  [a > 0, b < 0]
                        nb = 1;
                    case 4:
                        // [a = 0, b < 0]
                        nb = 1;
                        a_is_zero = 1;
                    case 5:
                        // [a < 0, b < 0]
                        na = 1;
                        nb = 1;
                }
                if ((div && b_is_zero) || (sext && (a_is_zero || b_is_zero))) {
                    abort_case = 1;
                }
                np = na + nb - na * nb;
                if (np && (a_is_zero || b_is_zero)) {
                    // - * 0 = 0 (no negative)
                    np = 0;
                }
                nr = div ? na : 0;

                int range_a1 = m32 * sa ? 1 + na : 0;
                int range_b1 = m32 * sb ? 1 + nb : 0;

                int range_c1 = 0;
                if (m32) {
                    if (div) {
                        // range_c1 = np || na32 ? 2 : 1;
                    } else {
                        // range_c1 = 1 + na32;
                    }
                }
                int range_d1 = m32 * div ? (((np * sa) || sext) ? 1:2) : 0;

                int range_a3 = (1 - m32) * sa ? 1 + na : 0;
                int range_b3 = (1 - m32) * sb ? 1 + na : 0;
                int range_c3 = div * (1 - m32) * sa ? 1 + np : 0;
                int range_d3 = div * (1 - m32) * sa ? 1 + np : 0;


                if (abort_case) {
                    println(`ABORT op:${opcode} sa:${sa} sb:${sb} a_is_zero:${a_is_zero} b_is_zero:${b_is_zero} na:${na} nb:${nb} np:${np} nr:${nr} sext:${sext} secondary:${secondary}`);
                    OP[index] = OP[0];
                    FLAGS[index] = FLAGS[0];
                    RANGE_AB[index] = RANGE_AB[0];
                    RANGE_CD[index] = RANGE_CD[0];
                    ++aborted;
                } else {
                    println(`ADD op:${opcode} sa:${sa} sb:${sb} a_is_zero:${a_is_zero} b_is_zero:${b_is_zero} na:${na} nb:${nb} np:${np} nr:${nr} sext:${sext} secondary:${secondary}`);
                    OP[index] = opcode;
                    FLAGS[index] = m32 + 2 * div + 4 * na + 8 * nb + 16 * np + 32 * nr + 64 * sext + 128 * secondary;
                    RANGE_AB[index] = 0;
                    RANGE_CD[index] = 0;
                }

                index = index + 1;
            }
        }
    }*/
    const int size = index;

    println("ARITH_TABLE SIZE: ", size);
    println("ARITH_TABLE ABORTED: ", aborted);
    println("ARITH_FLAGS: ", FLAGS);
    if (generate_table) {
        println("let arith_table_rows: [i16; 512] = [", op2row, "];");
    }
    return;
    for (index = 0; index < size; ++index) {
        println(FLAGS[index]);
    }

    // padding repeat first row

    const int padding_op = OP[0];
    const int padding_flags = FLAGS[0];
    const int padding_range_ab = RANGE_AB[0];
    const int padding_range_cd = RANGE_CD[0];

    for (index = size; index < N; ++index) {
        OP[index] = padding_op;
        FLAGS[index] = padding_flags;
        RANGE_AB[index] = padding_range_ab;
        RANGE_CD[index] = padding_range_cd;
    }
    col witness multiplicity;

    // TODO:
    lookup_proves(ARITH_TABLE_ID, mul: multiplicity, cols: [OP, FLAGS, RANGE_AB, RANGE_CD]);
}

function arith_table_assumes( const expr op, const expr flag_m32, const expr flag_div, const expr flag_na,
                              const expr flag_nb, const expr flag_np, const expr flag_nr, const expr flag_sext,
                              const expr flag_secondary_res, const expr range_ab, const expr range_cd) {

    // TODO: #pragma binary flag_m32 => check any constraint on compilation time
    // TODO: define rule for empty rows
    lookup_assumes(ARITH_TABLE_ID, cols: [ op, flag_m32 + 2 * flag_div + 4 * flag_na + 8 * flag_nb +
                                           16 * flag_np + 32 * flag_nr + 64 * flag_sext +
                                           128 * flag_secondary_res, range_ab, range_cd]);
}
