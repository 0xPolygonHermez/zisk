require "std_lookup.pil"

const int ARITH_TABLE_ID = 331;

airtemplate ArithTable(int N = 2**7, int generate_table = 1) {

    // TABLE
    // op,m32|div|na|nb|np|nr|sext,range_ab,range_cd

    // div m32 sa  sb  primary  secondary  opcodes       na   nb   np   nr   sext(c)
    // -----------------------------------------------------------------------------
    //  0   0   0   0  mulu     muluh      (0xb0,0xb1)   =0   =0   =0   =0   =0   =0
    //  0   0   1   0  *n/a*    mulsuh     (0xb2,0xb3)   a3   =0   d3   =0   =0   =0  a3,      d3
    //  0   0   1   1  mul      mulh       (0xb4,0xb5)   a3   b3   d3   =0   =0   =0  a3,b3,   d3
    //  0   1   0   0  mul_w    *n/a*      (0xb6,0xb7)   =0   =0   =0   =0   c1   =0

    // div m32 sa  sb  primary  secondary  opcodes       na   nb   np   nr   sext(a,d)(*2)
    // ------------------------------------------------------------------------------
    //  1   0   0   0  divu     remu       (0xb8,0xb9)   =0   =0   =0   =0   =0   =0
    //  1   0   1   1  div      rem        (0xba,0xbb)   a3   b3   c3   d3   =0   =0  a3,b3,c3,d3
    //  1   1   0   0  divu_w   remu_w     (0xbc,0xbd)   =0   =0   =0   =0   a1   d1               a1      ,d1
    //  1   1   1   1  div_w    rem_w      (0xbe,0xbf)   a1   b1   c1   d1   a1   d1               a1,b1,c1,d1

    const int OPS[14] = [0xb0, 0xb1, 0xb3, 0xb4, 0xb5, 0xb6, 0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe, 0xbf];

    col fixed OP;
    col fixed FLAGS;
    col fixed RANGE_AB;
    col fixed RANGE_CD;

    int index = 0;
    int aborted = 0;

    if (generate_table) {
        int air.op2row[512];
        for (int i = 0; i < 512; ++i) {
            op2row[i] = -1;
        }
    }

    for (int opcode = 0xb0; opcode <= 0xbf; ++opcode) {
        if (opcode == 0xb2 || opcode == 0xb7) {
            continue;
        }
        int m32 = 0;    // 32 bits operation
        int div = 0;    // division operation (div,rem)
        int sa = 0;
        int sb = 0;
        int main_mul = 0;
        int main_div = 0;
        string opname = "";
        switch (opcode) {
            case 0xb0:
                opname = "mulu";
                main_mul = 1;
            case 0xb1:
                opname = "mulh";
            case 0xb3:
                opname = "mulsuh";
                sa = 1;
            case 0xb4:
                opname = "mul";
                sa = 1;
                sb = 1;
                main_mul = 1;
            case 0xb5:
                opname = "mulh";
                sa = 1;
                sb = 1;
            case 0xb6:
                opname = "mul_w";
                m32 = 1;
                main_mul = 1;
            case 0xb8:
                opname = "divu";
                div = 1;
                main_div = 1;
            case 0xb9:
                opname = "remu";
                div = 1;
            case 0xba:
                opname = "div";
                sa = 1;
                sb = 1;
                div = 1;
                main_div = 1;
            case 0xbb:
                opname = "rem";
                sa = 1;
                sb = 1;
                div = 1;
            case 0xbc:
                opname = "divu_w";
                div = 1;
                m32 = 1;
                main_div = 1;
            case 0xbd:
                opname = "remu_w";
                div = 1;
                m32 = 1;
            case 0xbe:
                opname = "div_w";
                sa = 1;
                sb = 1;
                div = 1;
                m32 = 1;
                main_div = 1;
            case 0xbf:
                opname = "rem_w";
                sa = 1;
                sb = 1;
                div = 1;
                m32 = 1;
        }

        for (int icase = 0; icase < 32; ++icase) {
            int na = 0;
            int nb = 0;
            int nr = 0;
            int np = 0;
            int sext = 0;

            if (0x01 & icase) na = 1;
            if (0x02 & icase) nb = 1;
            if (0x04 & icase) np = 1;
            if (0x08 & icase) nr = 1;
            if (0x10 & icase) sext = 1;

            if (sext && !m32) continue;
            if (nr && !div) continue;
            if (na && !sa) continue;
            if (nb && !sb) continue;
            if (np && !sa && !sb) continue;
            if (nr && !sa && !sb) continue;
            if (np && !na && !nb && !div) continue;
            if (np && na && nb) continue;
            if (!np & nr) continue;

            int range_a1 = 0;
            int range_b1 = 0;
            int range_c1 = 0;
            int range_d1 = 0;
            int range_a3 = 0;
            int range_b3 = 0;
            int range_c3 = 0;
            int range_d3 = 0;

            if (m32) {
                if (sa) {
                    range_a1 = na ? 2 : 1;
                } else if (main_div) {
                    range_a1 = sext ? 2 : 1;
                }
                if (sb) {
                    range_b1 = nb ? 2 : 1;
                }
                if (!div) {
                    range_c1 = sext ? 2 : 1;
                } else if (sa) {
                    range_c1 = np ? 2 : 1;
                }
                if (div && !main_div) {
                    range_d1 = sext ? 2 : 1;
                } else if (sa) {
                    range_d1 = nr ? 2 : 1;
                }
            } else {
                if (sa) {
                    range_a3 = na ? 2 : 1;
                    if (div) {
                        range_c3 = np ? 2 : 1;
                        range_d3 = nr ? 2 : 1;
                    } else {
                        range_d3 = np ? 2 : 1;
                    }
                }
                if (sb) {
                    range_b3 = nb ? 2 : 1;
                }
            }
            int signed = sa * sb - sa * sb;
            const int flags = m32 + 2 * div + 4 * na + 8 * nb + 16 * np + 32 * nr + 64 * sext +
                           128 * main_mul + 256 * main_div + 512 * signed;
            int range_ab = (range_a3 + range_a1) * 3 + range_b3 + range_b1;
            if ((range_a1 + range_b1) > 0) {
                range_ab = range_ab + 8;
            }
            int range_cd = (range_c3 + range_c1) * 3 + range_d3 + range_d1;
            if ((range_c1 + range_d1) > 0) {
                range_cd = range_cd + 8;
            }
            // const int range_cd = range_c3 * 3 + range_d3 + m32 * 8 + range_c1 * 3 + range_d1;

            OP[index] = opcode;
            FLAGS[index] = flags;
            RANGE_AB[index] = range_ab;
            RANGE_CD[index] = range_cd;

            if (generate_table) {
                op2row[(opcode - 0xb0) * 32 + icase] = index;
                println(`range_a1:${range_a1} range_b1:${range_b1} range_c1:${range_c1} range_d1:${range_d1}`);
                println(`range_a3:${range_a3} range_b3:${range_b3} range_c3:${range_c3} range_d3:${range_d3}`);
                println(`TABLE row:${index} OP:${opcode} FLAGS:${flags} RANGE_AB:${range_ab} RANGE_CD:${range_cd}`);
            }
            ++index;
        }
    }
    const int size = index;

    println("ARITH_TABLE SIZE: ", size);
    if (generate_table) {
        println("static ARITH_TABLE_ROWS: [i16; 512] = [", op2row, "];");
    }

    // padding repeat first row

    const int padding_op = OP[0];
    const int padding_flags = FLAGS[0];
    const int padding_range_ab = RANGE_AB[0];
    const int padding_range_cd = RANGE_CD[0];

    for (index = size; index < N; ++index) {
        OP[index] = padding_op;
        FLAGS[index] = padding_flags;
        RANGE_AB[index] = padding_range_ab;
        RANGE_CD[index] = padding_range_cd;
    }
    col witness multiplicity;

    lookup_proves(ARITH_TABLE_ID, mul: multiplicity, cols: [OP, FLAGS, RANGE_AB, RANGE_CD]);
}

function arith_table_assumes( const expr op, const expr flag_m32, const expr flag_div, const expr flag_na,
                              const expr flag_nb, const expr flag_np, const expr flag_nr, const expr flag_sext,
                              const expr flag_main_mul, const expr flag_main_div, const expr flag_signed,
                              const expr range_ab, const expr range_cd) {

    lookup_assumes(ARITH_TABLE_ID, cols: [ op, flag_m32 + 2 * flag_div + 4 * flag_na + 8 * flag_nb +
                                           16 * flag_np + 32 * flag_nr + 64 * flag_sext +
                                           128 * flag_main_mul + 256 * flag_main_div + 512 * flag_signed,
                                           range_ab, range_cd]);
}
