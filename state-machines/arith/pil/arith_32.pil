require "std_lookup.pil"
require "std_range_check.pil"
require "operations.pil"
require "arith_table.pil"

airtemplate Arith32(int N = 2**10, const int dual_result = 0) {

    // NOTE:
    // Divisions and remainders by 0 are done by QuickOps

    col witness carry[3];
    col witness a[2];
    col witness b[2];
    col witness c[2];
    col witness d[2];

    col witness na;     // a is negative
    col witness nb;     // b is negative
    col witness nr;     // rem is negative
    col witness np;     // prod is negative
    col witness na32;   // a is 32-bit negative, 31th bit is 1.
    col witness nd32;   // d is 32-bit negative, 31th bit is 1.

    col witness div;    // division operation (div,rem)

    col witness fab;    // fab, to decrease degree of intermediate products a * b 
                        // fab = 1  if sign of a,b are the same
                        // fab = -1 if sign of a,b are different

    if (!dual_result) {
        col witness air.secondary_res;       // op_index: 0 => first result, 1 => second result;
        secondary_res * (secondary_res - 1) === 0;        
    } else {
        const expr air.secondary_res = 0;
    }

    fab === 1 - 2 * na - 2 * nb + 4 * na * nb;

    const expr eq[8]; 

    eq[0] = fab * a[0] * b[0] 
            - c[0]
            + 2 * np * c[0]
            + div * d[0] 
            - 2 * nr * d[0];

    eq[1] = fab * a[1] * b[0] 
            + fab * a[0] * b[1]
            - c[1] 
            + 2 * np * c[1]
            + div * d[1] 
            - 2 * nr * d[1];

    eq[2] = fab * a[1] * b[1] 
            - np * div
            + nr;
        
    // TODO: review !!!!!                    
    eq[3] = 2**16 * na * nb;

    eq[0] - carry[0] * 2**16 === 0;
    eq[1] + carry[0] - carry[1] * 2**16 === 0;
    eq[2] + carry[1] - carry[2] * 2**16 === 0;
    eq[3] + carry[2] === 0;

    // binary contraint
    div * (1 - div) === 0;
    na * (1 - na) === 0;
    nb * (1 - nb) === 0;
    nr * (1 - nr) === 0;
    np * (1 - np) === 0;
    na32 * (1 - na32) === 0;
    nd32 * (1 - nd32) === 0;

    col witness op;    

    // div sa  sb  comm primary  secondary  opcodes       na   nb   nr   np na32 nd32 
    // ------------------------------------------------------------------------------
    //  0   1   1    x  mul_w    *n/a*      (0xb6,0xb7)   a1   b1    0   d3   c1    0           d3, a1,b1,c1
    //  1   1   1       div_w    rem_w      (0xbe,0xbf)   a1   b1   d1   c1   c1   d1               a1,b1,c1,d1

    // (*) removed combinations of flags div,sa,sb did allow combinations div, sa, sb 
    // comm = commutative (trivial: commutative operations)

    col witness bus_a_low; 
    bus_a_low === div * (c[0] - a[0]) 
                  + a[0] 
                  + 2**16 * div * (c[1] - a[1]) 
                  + 2**16 * a[1];

    const expr bus_a_high = 0;


    const expr bus_b_low = b[0] + 2**16 * b[1];

    // TODO: na32 and nd32 only valid on 32 bit operations
    // TODO: m32 === 0 ==> b[2],a[2],b[3],a[3] === 0 avoid two witness
    const expr bus_b_high = 0;

    const expr res2_low  = d[0] + 2**16 * d[1]; 
    const expr res2_high = nd32 * 0xFFFFFFFF;

    if (dual_result) {
        // theorical cost: 4 columns
        col witness multiplicity_2;
        lookup_proves(OPERATION_BUS_ID, [op+1, bus_a_low, bus_a_high, bus_b_low, bus_b_high, res2_low, res2_high, 0], mul: multiplicity_2);
    }

    if (dual_result) {
        const expr air.res1_low = a[0] + c[0] + 2**16 * a[1] + 2**16 * c[1] - bus_a_low;
        col witness air.res1_high;
        res1_high === div * na32 * 0xFFFFFFFF + (1 - div) * nd32 * 0xFFFFFFFF;
    } else {
        col witness air.res1_low;
        res1_low === secondary_res * res2_low - (1 - secondary_res)  * (a[0] + c[0] + 2**16 * a[1] + 2**16 * c[1] - bus_a_low);
        
        col witness air.res1_high;
        res1_high === secondary_res * res2_high + (1 - secondary_res) * (div * na32 * 0xFFFFFFFF + (1 - div) * nd32 * 0xFFFFFFFF);
    }
    

    col witness multiplicity;

    lookup_proves(OPERATION_BUS_ID, [op + secondary_res,
                                     bus_a_low, bus_a_high, 
                                     bus_b_low, bus_b_high, 
                                     res1_low, res1_high,
                                     0], mul: multiplicity);


    // TODO: review
    lookup_assumes(OPERATION_BUS_ID, [OP_LT, res2_low, res2_high, bus_b_low, bus_b_high, 0, 1, 1], sel: div);

    for (int index = 0; index < length(carry); ++index) {
         range_check(colu: carry[index], min:-2**20, max: 2**20-1);     // TODO: review range
    }

    range_check(colu: a[0], min:0, max: 2**16-1);
    range_check(colu: b[0], min:0, max: 2**16-1);
    range_check(colu: c[0], min:0, max: 2**16-1);
    range_check(colu: d[0], min:0, max: 2**16-1);

    col witness range_a1;
    col witness range_b1;
    col witness range_c1;
    col witness range_d1;

    lookup_assumes(ARITH_TABLE_ID, cols: [ op, 1 + 2 * div + 4 * na + 8 * nb + 16 * nr + 32 * np + 64 * na32 + 128 * nd32 +
                                           2**8 * range_a1 + 2**10 * range_b1 + 2**12 * range_c1 + 2**14 * range_d1]);
    
    range_a1 * (1 - range_a1) * (2 - range_a1) === 0;
    range_b1 * (1 - range_b1) * (2 - range_b1) === 0;
    range_c1 * (1 - range_c1) * (2 - range_c1) === 0;
    range_d1 * (1 - range_d1) * (2 - range_d1) === 0;

    lookup_assumes(QUICK_RANGE_TABLE_ID, [range_a1, a[1]]);
    lookup_assumes(QUICK_RANGE_TABLE_ID, [range_b1, b[1]]);
    lookup_assumes(QUICK_RANGE_TABLE_ID, [range_c1, c[1]]);
    lookup_assumes(QUICK_RANGE_TABLE_ID, [range_d1, d[1]]);
}