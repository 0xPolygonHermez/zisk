require "std_constants.pil"
require "std_lookup.pil"
require "std_connection.pil"

// Precompile in charge of performing the Keccak-f[1600] permutation. For reference: https://keccak.team/files/Keccak-reference-3.0.pdf

const int KECCAKF_SIZE_BITS = 1600;

const int KECCAKF_OP = 0xF1;
const int KECCAKF_CIRCUIT_ID = 0x190;

airtemplate Keccakf(const int N = 2**23, const int RC = 2, const int RB = 32, const int chunks, const int bits, const int bits_reduced, const int operation_bus_id) {
    // Keccak-f circuit size
    const int CIRCUIT_XORS = 116886;
    const int CIRCUIT_ANDPS = 38400;
    const int CIRCUIT_SIZE = CIRCUIT_ANDPS + CIRCUIT_XORS;
    println(`The size of the Keccak-f circuit is ${CIRCUIT_SIZE}`);

    // Ensure that the keccak-f circuit fits
    if (N < CIRCUIT_SIZE) {
        error(`N must be at least ${CIRCUIT_SIZE} to fit the Keccak-f circuit, but received N=${N}`);
    }

    // Ensure that the keccak-f input fit in the prime field
    const int BITS_INPUT = (chunks - 1)*bits + bits_reduced;
    if (BITS_INPUT >= log2(PRIME)) {
        error(`The number of bits ${BITS_INPUT} is too large for the prime ${PRIME}`);
    }

    // Compute some stats
    const int NUM_KECCAKF_PER_SLOT = chunks * bits;
    const int NUM_SLOTS = (N - 1) / CIRCUIT_SIZE;
    const int NUM_KECCAKF = NUM_SLOTS * NUM_KECCAKF_PER_SLOT;
    const int NON_USABLE_ROWS = (N - 1) % CIRCUIT_SIZE;
    println(`The number of Keccak-f per circuit is ${NUM_KECCAKF_PER_SLOT > log2(PRIME) ? log2(PRIME)-1 : NUM_KECCAKF_PER_SLOT}`);
    println(`The number of circuits that fit for the given N is ${NUM_SLOTS} and the total number of Keccak-f is ${NUM_KECCAKF}`);
    println(`The number of non-usable (padding) rows is ${NON_USABLE_ROWS}`);

    const int P2_BITS = 2**bits;
    const int P2_CHUNK_BITS = 2**(bits * chunks);
    const int MASK_CHUNK_BITS = P2_CHUNK_BITS - 1;

    col fixed L1 = [1,0...];

    // Column specifying the circuit gates
    #pragma fixed_external
    col fixed GATE_OP;

    // Columns specifying the circuit connections
    #pragma fixed_external
    col fixed CONN_A;
    #pragma fixed_external
    col fixed CONN_B;
    #pragma fixed_external
    col fixed CONN_C;

    col witness free_in_a[chunks], free_in_b[chunks], free_in_c[chunks];

    // --> Circuit gates constraints
    if (bits != bits_reduced) {
        for (int i = 0; i < chunks; i++) {
            lookup_assumes(KECCAKF_TABLE_ID, [i == chunks - 1 ? 1 : 0, GATE_OP, free_in_a[i], free_in_b[i], free_in_c[i]]);
        }
    } else {
        for (int i = 0; i < chunks; i++) {
            lookup_assumes(KECCAKF_TABLE_ID, [GATE_OP, free_in_a[i], free_in_b[i], free_in_c[i]]);
        }
    }

    // --> Circuit connections constraints
    // Start by reconstructing the input from the chunks
    expr a = 0;
    expr b = 0;
    expr c = 0;
    for (int i = 0; i < chunks; i++) {
        const int shift = P2_BITS**i;
        a += free_in_a[i] * shift;
        b += free_in_b[i] * shift;
        c += free_in_c[i] * shift;
    }

    // Enforce constants 0b00..000 and 0b11..111 at the first row for direct access
    // This reduces the circuit connections
    L1 * a === 0;
    L1 * (b - MASK_CHUNK_BITS) === 0;

    connection(opid: KECCAKF_CIRCUIT_ID, cols: [a, b, c], CONN: [CONN_A, CONN_B, CONN_C]);

    // --> Constraints to make sure that this coprocessor is called from the main processor
    col witness step_input;
    col witness addr_input;
    col witness multiplicity;
    lookup_proves(OPERATION_BUS_ID, [KECCAKF_OP, step_input, 0, addr_input, 0, 0, 0, 0], multiplicity);

    // --> Constraints to read inputs from memory and write outputs to memory
    col witness bit[RC];
    col witness val[RC];

    if (NUM_KECCAKF_PER_SLOT == 1) {
        const int air.latch_num_keccakf = 1;
        const int air.factor_num_keccakf = 1;
    } else {
        col fixed air.latch_num_keccakf = [1,0:(NUM_KECCAKF_PER_SLOT-1)]...;
        col fixed air.factor_num_keccakf = [1,2..*..2**(NUM_KECCAKF_PER_SLOT-1)]...;
    }

    // `bit` is a bit
    for (int i = 0; i < RC; i++) {
        bit[i] * (1 - bit[i]) === 0;
    }

    // `val` accumulates bits. After NUM_KECCAKF_PER_SLOT*i clocks, `val` has accumulated the i-th bit of the keccakf's 
    for (int i = 0; i < RC; i++) {
        val[i] === 'val[i] * (1 - latch_num_keccakf) + bit[i] * factor_num_keccakf;
    }

    // TODO: Use connections to check that the values of val1 and val2 are the same as the values set in the gates
    // Every NUM_KECCAKF_PER_SLOT*i clocks, `val` has to be the coincide with the 'a'-th gate entry
    // latch_num_keccakf * (val - a) === 0;

    const int CHUNKS_TO_PROCESS = KECCAKF_SIZE_BITS / RB;

    // `state` accumulates RB bits of the j-th keccakf state each clock
    // After NUM_KECCAKF_PER_SLOT clocks, `state` has accumulated RB bits of the NUM_KECCAKF_PER_SLOT keccakf's
    // After CHUNKS_TO_PROCESS * NUM_KECCAKF_PER_SLOT clocks, `state` has accumulated all the bits
    expr state[RC];
    for (int i = 0; i < RC; i++) {
        state[i] = 0;
        for (int j = 0; j < RB; j++) {
            state[i] += bit[i]'(NUM_KECCAKF_PER_SLOT*j) * 2**j;
        }
    }

    const int CLOCKS = CHUNKS_TO_PROCESS * NUM_KECCAKF_PER_SLOT;
    col fixed is_input  = [[1:CLOCKS,0:CLOCKS,0:(CIRCUIT_SIZE - 2*CLOCKS)]:NUM_SLOTS,0...];
    col fixed is_output = [[0:CLOCKS,1:CLOCKS,0:(CIRCUIT_SIZE - 2*CLOCKS)]:NUM_SLOTS,0...];

    // step and addr should be the same every NUM_KECCAKF_PER_SLOT clock
    (is_input + is_output)*(step'(NUM_KECCAKF_PER_SLOT) - step) === 0;
    (is_input + is_output)*(addr'(NUM_KECCAKF_PER_SLOT) - addr) === 0;

    precompiled_mem_load(
             sel: is_input,
             main_step: step,
             addr: addr,
             value: state
            );

    precompiled_mem_store(
              sel: is_output,
              main_step: step,
              addr: addr,
              value: state
            );
}