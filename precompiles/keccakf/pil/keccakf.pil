require "std_constants.pil"
require "std_lookup.pil"
require "std_connection.pil"

// Precompile in charge of performing the Keccak-f[1600] permutation. For reference: https://keccak.team/files/Keccak-reference-3.0.pdf

const int KECCAKF_SIZE_BITS = 1600;

const int KECCAKF_OP = 0xF1;
const int KECCAKF_CIRCUIT_ID = 0x190;

airtemplate Keccakf(const int N = 2**23, const int RC = 2, const int RB = 32, const int chunks, const int bits, const int bits_reduced, const int operation_bus_id) {
    // Keccak-f circuit size
    const int CIRCUIT_XORS = 116886;
    const int CIRCUIT_ANDPS = 38400;
    const int CIRCUIT_SIZE = CIRCUIT_ANDPS + CIRCUIT_XORS;
    println(`The size of the Keccak-f circuit is ${CIRCUIT_SIZE}`);

    // Ensure that the keccak-f circuit fits
    if (N < CIRCUIT_SIZE) {
        error(`N must be at least ${CIRCUIT_SIZE} to fit the Keccak-f circuit, but received N=${N}`);
    }

    // Ensure that the keccak-f input fit in the prime field
    const int BITS_INPUT = (chunks - 1)*bits + bits_reduced;
    if (BITS_INPUT >= log2(PRIME)) {
        error(`The number of bits ${BITS_INPUT} is too large for the prime ${PRIME}`);
    }

    // Compute some stats
    const int NUM_KECCAKF_PER_SLOT = chunks * bits;
    const int NUM_SLOTS = (N - 1) / CIRCUIT_SIZE;
    const int NUM_KECCAKF = NUM_SLOTS * NUM_KECCAKF_PER_SLOT;
    const int NON_USABLE_ROWS = (N - 1) % CIRCUIT_SIZE;
    println(`The number of Keccak-f per circuit is ${NUM_KECCAKF_PER_SLOT > log2(PRIME) ? log2(PRIME)-1 : NUM_KECCAKF_PER_SLOT}`);
    println(`The number of circuits that fit for the given N is ${NUM_SLOTS} and the total number of Keccak-f is ${NUM_KECCAKF}`);
    println(`The number of non-usable (padding) rows is ${NON_USABLE_ROWS}`);

    const int P2_BITS = 2**bits;
    const int P2_CHUNK_BITS = 2**(bits * chunks);
    const int MASK_CHUNK_BITS = P2_CHUNK_BITS - 1;

    col fixed L1 = [1,0...];

    // Column specifying the circuit gates
    #pragma fixed_external
    col fixed GATE_OP;

    // Columns specifying the circuit connections
    #pragma fixed_external
    col fixed CONN_A;
    #pragma fixed_external
    col fixed CONN_B;
    #pragma fixed_external
    col fixed CONN_C;

    col witness free_in_a[chunks], free_in_b[chunks], free_in_c[chunks];

    // --> Circuit gates constraints
    if (bits != bits_reduced) {
        for (int i = 0; i < chunks; i++) {
            lookup_assumes(KECCAKF_TABLE_ID, [i == chunks - 1 ? 1 : 0, GATE_OP, free_in_a[i], free_in_b[i], free_in_c[i]]);
        }
    } else {
        for (int i = 0; i < chunks; i++) {
            lookup_assumes(KECCAKF_TABLE_ID, [GATE_OP, free_in_a[i], free_in_b[i], free_in_c[i]]);
        }
    }

    // --> Circuit connections constraints
    // Start by reconstructing the input from the chunks
    expr a = 0;
    expr b = 0;
    expr c = 0;
    for (int i = 0; i < chunks; i++) {
        const int shift = P2_BITS**i;
        a += free_in_a[i] * shift;
        b += free_in_b[i] * shift;
        c += free_in_c[i] * shift;
    }

    // Enforce constants 0b00..000 and 0b11..111 at the first row for direct access
    // This reduces the circuit connections
    L1 * a === 0;
    L1 * (b - MASK_CHUNK_BITS) === 0;

    connection(opid: KECCAKF_CIRCUIT_ID, cols: [a, b, c], CONN: [CONN_A, CONN_B, CONN_C]);

    // --> Constraints to make sure that this coprocessor is called from the main processor
    col witness step;
    col witness addr;
    col witness multiplicity;
    lookup_proves(OPERATION_BUS_ID, [KECCAKF_OP, step, 0, addr, 0, 0, 0, 0], multiplicity);

    // --> Constraints to read inputs from memory and write outputs to memory
    col witness bit1;
    col witness bit2;
    col witness val1;
    col witness val2;
    // Note: We process two bits in parallel

    const int STATE_SIZE = NUM_KECCAKF_PER_SLOT * KECCAKF_SIZE_BITS;
    if (NUM_KECCAKF_PER_SLOT == 1) {
        // TODO: Fix this edge case
        // const int air.latch_num_keccakf = 1;
        // const int air.factor_num_keccakf = 1;
    } else {
        // Instructions to add a latch:
        //  - When there are slots.
        //  - Every NUM_KECCAKF_PER_SLOT clocks (including the first one).
        //  - When there are still bits to process (i.e., we repeat the previous instruction KECCAKF_SIZE_BITS times).
        col fixed air.latch_num_keccakf  = [0,[[0:NUM_KECCAKF_PER_SLOT,1],[0:(NUM_KECCAKF_PER_SLOT-1),1]:(KECCAKF_SIZE_BITS-1), 
                                                0:(CIRCUIT_SIZE - (STATE_SIZE+1))]:NUM_SLOTS,
                                            0...];
        // Instructions to add the factor:
        //  - When there are slots.
        //  - Every clock, for the clock in the slot, we add the factor 1 << clk
        //  - When there are still bits to process (i.e., we repeat the previous instruction KECCAKF_SIZE_BITS times).
        col fixed air.factor_num_keccakf = [0,[[1,2..*..2**(NUM_KECCAKF_PER_SLOT-1)]:KECCAKF_SIZE_BITS, 
                                                0:(CIRCUIT_SIZE - STATE_SIZE)]:NUM_SLOTS,
                                            0...];
    }

    // `bit` is a bit
    bit1 * (1 - bit1) === 0;
    bit2 * (1 - bit2) === 0;

    // `val` accumulates bits. After NUM_KECCAKF_PER_SLOT*i clocks, `val` has accumulated the i-th bit of the keccakf's 
    val1' === val1 * (1 - latch_num_keccakf) + bit1 * factor_num_keccakf;
    val2' === val2 * (1 - latch_num_keccakf) + bit2 * factor_num_keccakf;

    // Every NUM_KECCAKF_PER_SLOT*i clocks, `val` has to be the coincide with the 'a'-th gate entry
    latch_num_keccakf * (val1 - a) === 0;
    latch_num_keccakf * (val2 - a') === 0;

    const int CHUNKS_TO_PROCESS = KECCAKF_SIZE_BITS / RB;

    // `state` accumulates RB bits of the j-th keccakf state each clock
    // After NUM_KECCAKF_PER_SLOT clocks, `state` has accumulated RB bits of the NUM_KECCAKF_PER_SLOT keccakf's
    // After CHUNKS_TO_PROCESS * NUM_KECCAKF_PER_SLOT clocks, `state` has accumulated all the bits
    expr state1 = 0;
    expr state2 = 0;
    for (int j = 0; j < RB; j++) {
        const expr next_bit1 = (j % 2 == 0) ? bit1'(NUM_KECCAKF_PER_SLOT*j/2) : bit2'(NUM_KECCAKF_PER_SLOT*(j-1)/2);
        const expr next_bit2 = (j % 2 == 0) ? bit1'(NUM_KECCAKF_PER_SLOT*(RB/2 + j/2)) : bit2'(NUM_KECCAKF_PER_SLOT*(RB/2 + (j-1)/2));
        state1 += next_bit1 * 2**j;
        state2 += next_bit2 * 2**j;
    }

    col witness is_val;
    is_val * (1 - is_val) === 0;

    // if multiplicity is not zero, then is_val should be 1
    multiplicity * (is_val - 1) === 0;

    // Then, if is_val = 1, it should be 1 64*50 consecutive times (input and ouput), separated by NUM_KECCAKF_PER_SLOT
    col fixed latch_in_out = [0,[1:(NUM_KECCAKF_PER_SLOT*(KECCAKF_SIZE_BITS-1)),0:NUM_KECCAKF_PER_SLOT,
                                 0:(CIRCUIT_SIZE - STATE_SIZE)]:NUM_SLOTS,
                              0...];
    latch_in_out * (is_val'(NUM_KECCAKF_PER_SLOT) - is_val) === 0;

    // step and addr should be the same every NUM_KECCAKF_PER_SLOT clock
    is_val * (step'(NUM_KECCAKF_PER_SLOT) - step) === 0;
    is_val * (addr'(NUM_KECCAKF_PER_SLOT) - addr) === 0;

    const int CLOCKS = NUM_KECCAKF_PER_SLOT * RB;
    col fixed latch_input  = [0,[[1,0:(CLOCKS-1)]:(CHUNKS_TO_PROCESS/2), [0:CLOCKS]:(CHUNKS_TO_PROCESS/2),
                                  0:(CIRCUIT_SIZE - STATE_SIZE)]:NUM_SLOTS,
                              0...];
    col fixed latch_output = [0,[[0:CLOCKS]:(CHUNKS_TO_PROCESS/2), [1,0:(CLOCKS-1)]:(CHUNKS_TO_PROCESS/2),
                                  0:(CIRCUIT_SIZE - STATE_SIZE)]:NUM_SLOTS,
                              0...];

    precompiled_mem_load(
             sel: is_val * latch_input,
             main_step: step,
             addr: addr,
             value: [state1, state2]
            );

    precompiled_mem_store(
              sel: is_val * latch_output,
              main_step: step,
              addr: addr,
              value: [state1, state2]
            );
}