require "std_constants.pil"
require "std_lookup.pil"
require "std_connection.pil"

const int KECCAKF_OP = 0xF1;

// Precompile in charge of performing the Keccak-f[1600] permutation. For reference: https://keccak.team/files/Keccak-reference-3.0.pdf

airtemplate Keccakf(const int N = 2**21, int RC = 2, const int chunks = 6, const int bits = 11, const int operation_bus_id) {
    // The keccak-f circuit is defined over a prime field,
    // so we need to ensure that the chosen gate input size fits
    const int NUM_KECCAKF_PER_SLOT = chunks * bits;
    println(`The number of Keccak-f per slot is ${NUM_KECCAKF_PER_SLOT}`);
    if (NUM_KECCAKF_PER_SLOT >= log2(PRIME)) {
        error(`The number of Keccak-f per slot is too large for the prime field}`);
    }

    // Keccak-f circuit size
    const int CIRCUIT_XORS = 116886;
    const int CIRCUIT_ANDPS = 38400;
    const int CIRCUIT_SIZE = CIRCUIT_ANDPS + CIRCUIT_XORS; // Slot size

    // Ensure that the keccak-f circuit fits
    if (N < CIRCUIT_SIZE) {
        error(`N must be at least ${CIRCUIT_SIZE} to fit the Keccak-f circuit, but received N=${N}`);
    }

    const int NUM_SLOTS = (N - 1) / CIRCUIT_SIZE;
    const int NUM_KECCAKF = NUM_SLOTS * NUM_KECCAKF_PER_SLOT;
    println(`The total number of Keccak-f with N=2**${log2(N)} is ${NUM_KECCAKF}`);

    const int P2_BITS = 2**bits;
    const int P2_CHUNK_BITS = 2**(bits * chunks);
    const int MASK_CHUNK_BITS = P2_CHUNK_BITS - 1;

    col fixed L1 = [1,0...];

    // Column specifying the circuit gates
    #pragma fixed_external
    col fixed GATE_OP;

    // Columns specifying the circuit connections
    #pragma fixed_external
    col fixed CONN_A;
    #pragma fixed_external
    col fixed CONN_B;
    #pragma fixed_external
    col fixed CONN_C;

    col witness free_in_a[chunks], free_in_b[chunks], free_in_c[chunks];

    // --> Circuit gates constraints
    for (int i = 0; i < chunks; i++) {
        lookup_assumes(KECCAKF_TABLE_ID, [GATE_OP, free_in_a[i], free_in_b[i], free_in_c[i]]);
    }

    // --> Circuit connections constraints
    // Start by reconstructing the input from the chunks
    expr a = 0;
    expr b = 0;
    expr c = 0;
    expr a_mem[RC],b_mem[RC],c_mem[RC];
    int rs = 0;
    expr _accum_a = 0;
    expr _accum_b = 0;
    expr _accum_c = 0;
    int _i = 0;
    for (int i = 0; i < chunks; i++) {
        const int shift = P2_BITS**i;
        const int _shift = P2_BITS**_i;

        if (_shift * P2_BITS >= P2_32) {
            a_mem[rs] = _accum_a;
            b_mem[rs] = _accum_b;
            c_mem[rs] = _accum_c;

            _accum_a = 0;
            _accum_b = 0;
            _accum_c = 0;
            _i = 0;
            rs++;
        }

        a += free_in_a[i] * shift;
        b += free_in_b[i] * shift;
        c += free_in_c[i] * shift;

        _accum_a += free_in_a[i] * _shift;
        _accum_b += free_in_b[i] * _shift;
        _accum_c += free_in_c[i] * _shift;
        _i++;
    }

    // Store the remaining accumulated values
    if (_accum_a != 0) {
        a_mem[rs] = _accum_a;
        b_mem[rs] = _accum_b;
        c_mem[rs] = _accum_c;
    }

    // Enforce constants 0b00..000 and 0b11..111 at the first row for direct access
    // This reduces the circuit connections
    L1 * a === 0;
    L1 * (b - MASK_CHUNK_BITS) === 0;

    connection(opid: 400, cols: [a, b, c], CONN: [CONN_A, CONN_B, CONN_C]);

    // --> Constraints to make sure that this coprocessor is called from the main processor
    col witness debug_main_step;
    col witness step_input;
    col witness addr_input;
    col witness multiplicity;
    lookup_proves(OPERATION_BUS_ID, [debug_main_step, KECCAKF_OP, step_input, 0, addr_input, 0, 0, 0, 0], multiplicity);

    // --> Constraints to read inputs from memory and write outputs to memory
    col witness a_src_mem;
    col witness mem_step;
    mem_load(sel: a_src_mem,
             step: mem_step,
             addr: addr_input,
             value: a_mem);

    expr addr_output = addr_input;
    col witness c_src_mem;
    mem_store(sel: c_src_mem,
              step: mem_step,
              step_offset: 1, //??
              addr: addr_output,
              value: c_mem);
}