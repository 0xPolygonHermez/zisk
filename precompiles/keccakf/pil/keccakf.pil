require "std_lookup.pil";
require "operations.pil";
require "opids.pil";
require "keccakf_table.pil";

// Precompile in charge of performing the Keccak-f[1600] permutation.
// For reference: https://keccak.team/files/Keccak-reference-3.0.pdf

airtemplate Keccakf(const int N = 2**17, const int operation_bus_id = OPERATION_BUS_ID, const int split_state_by = 1, const int mem_ops_in_parallel = 25) {
    // Validate individual inputs
    const int WIDTH = 1600;
    const int STATE_SIZE = WIDTH / split_state_by;
    if (split_state_by < 1) {
        error(`Input split_state_by must be at least 1 to fit the Keccak-f arithmetization, but received split_state_by=${split_state_by}`);
    } else if (STATE_SIZE % 64 != 0) {
        error(`Input split_state_by must be in {1, 5, 25} to fit the Keccak-f arithmetization, but received split_state_by=${split_state_by}`);
    }

    const int BITS_PER_LIMB = 32;
    const int U64_LIMBS = 64 / BITS_PER_LIMB;
    const int BITS_PER_CLOCK = BITS_PER_LIMB * U64_LIMBS;
    const int MEM_OPS = WIDTH / BITS_PER_CLOCK;
    if (mem_ops_in_parallel < 1) {
        error(`Input mem_ops_in_parallel must be at least 1 to fit the Keccak-f arithmetization, but received mem_ops_in_parallel=${mem_ops_in_parallel}`);
    } else if (MEM_OPS % mem_ops_in_parallel != 0) {
        error(`Input mem_ops_in_parallel must divide ${MEM_OPS} to fit the Keccak-f arithmetization, but received mem_ops_in_parallel=${mem_ops_in_parallel}`);
    }

    // Input consistency
    if (STATE_SIZE < mem_ops_in_parallel*BITS_PER_CLOCK) {
        error(`Input mem_ops_in_parallel=${mem_ops_in_parallel} is too large for the chosen split_state_by=${split_state_by} in the Keccak-f arithmetization`);
    }

    // For simplicity, let's assume for now that we always have full 64-bit lanes
    assert(split_state_by == 1 || split_state_by == 5 || split_state_by == 25);

    // Compute some stats
    const int ROUNDS = 24;
    const int CLOCKS = 1 + ROUNDS * split_state_by; // 1 for input state

    const int NUM_NON_USABLE_ROWS = N % CLOCKS;
    const int NUM_KECCAKF;
    if (NUM_NON_USABLE_ROWS == 0) {
        // N is perfectly divisible by CLOCKS
        if (N < CLOCKS) {
            error(`N must be at least ${CLOCKS} to fit the Keccak-f[${WIDTH}] arithmetization, but received N=${N}`);
        }

        NUM_KECCAKF = N / CLOCKS;
    } else {
        // N is not divisible by CLOCKS
        if (N < 2*CLOCKS) {
            error(`N must be at least ${2*CLOCKS} to fit the Keccak-f[${WIDTH}] arithmetization, but received N=${N}`);
        }

        // Subtract 1 because we can't fit a complete cycle in the remaining rows
        NUM_KECCAKF = (N - NUM_NON_USABLE_ROWS) / CLOCKS - 1;
    }
    println(`The total number of Keccak-f's is ${NUM_KECCAKF}`);

    col fixed CLK_0 = [[1, 0:(CLOCKS-1)]:NUM_KECCAKF, 0...];

    const expr CLK[CLOCKS];
    for (int i = 0; i < CLOCKS; i++) {
        CLK[i] = (i)'CLK_0;
    }

    // Define the clock selectors
    col witness bits(1) in_use_clk_0; // 1 at the first clock cycle of the Keccak-f operation, 0 otherwise
    col witness bits(1) in_use;       // 1 when the Keccak-f operation is in use, 0 otherwise

    in_use_clk_0 * (1 - in_use_clk_0) === 0;
    in_use * (1 - in_use) === 0;

    in_use_clk_0 - CLK_0 * in_use === 0; // This constraint is two-fold:
                                         //   · in_use_clk_0 can only be active when CLK_0 is active
                                         //   · if in_use is active then so is in_use_clk_0

    const expr in_use_active = clock_set(start: 1, end: CLOCKS);
    in_use_active * (in_use - 'in_use) === 0; // selector latching

    // --> Constraints to assert the Keccak-f[1600] permutation

    // Keccak-f[1600] state represented as a 1D array of 1600 bits
    col witness bits(1) state[STATE_SIZE];
    for (int i = 0; i < STATE_SIZE; i++) {
        state[i] * (1 - state[i]) === 0;
    }

    // Reconstruct the complete state from the split representation
    const expr complete_state[WIDTH];
    for (int i = 0; i < WIDTH; i++) {
        const int bit_in_row = i % STATE_SIZE;
        const int row_in_state = i / STATE_SIZE;
        complete_state[i] = state[bit_in_row]'(row_in_state);
    }


    // Round constants for Keccak-f[1600]
    const int RC[ROUNDS] = [
        0x0000000000000001, 0x0000000000008082, 0x800000000000808A, 0x8000000080008000, 0x000000000000808B, 0x0000000080000001,
        0x8000000080008081, 0x8000000000008009, 0x000000000000008A, 0x0000000000000088, 0x0000000080008009, 0x000000008000000A,
        0x000000008000808B, 0x800000000000008B, 0x8000000000008089, 0x8000000000008003, 0x8000000000008002, 0x8000000000000080,
        0x000000000000800A, 0x800000008000000A, 0x8000000080008081, 0x8000000000008080, 0x0000000080000001, 0x8000000080008008
    ];

    // Compute the keccakf round function over the state
    const expr keccakf[WIDTH] = iota_and_clock_set(chi(pi(rho(theta(complete_state)))), RC);

    // Perform lookups for reset expressions
    const int remaining_bits = (WIDTH % KECCAKF_LOOKUP_CHUNK_SIZE);
    const int num_chunks = (WIDTH - remaining_bits) / KECCAKF_LOOKUP_CHUNK_SIZE;

    // The lookup is active in all clock cycles except the last split_state_by cycles
    expr lookup_active = in_use;
    for (int i = 0; i < split_state_by; i++) {
        lookup_active -= (CLOCKS - 1 - i)'in_use_clk_0;
    }

    // Process full chunks
    col witness bits(22) chunk_acc[num_chunks];
    for (int i = 0; i < num_chunks; i++) {
        process_lookup_chunk(chunk: i, num_bits: KECCAKF_LOOKUP_CHUNK_SIZE, expr_acc: chunk_acc[i], expr_val: keccakf, sel: lookup_active);
    }

    // Handle remaining bits if any
    if (remaining_bits > 0) {
        col witness bits(8) rem_acc;
        process_lookup_chunk(chunk: num_chunks, num_bits: remaining_bits, expr_acc: rem_acc, expr_val: keccakf, sel: lookup_active);
    }

    // --> Constraints to read inputs from memory and write outputs to memory
    /*
        MEMORY ACCESS MAP
        ===============================================================================================================
          0 | STEP_MAIN     | R | ADDR_STATE       |  input_state[0] 
          1 | STEP_MAIN     | R | ADDR_STATE + 8   |  input_state[1]  
          2 | STEP_MAIN     | R | ADDR_STATE + 16  |  input_state[2]      
          3 | STEP_MAIN     | R | ADDR_STATE + 24  |  input_state[3] 
          . |    ...        | . |    ...           |     ...   
         24 | STEP_MAIN     | R | ADDR_STATE + 192 |  input_state[24]
         25 | STEP_MAIN + 1 | W | ADDR_STATE       |  output_state[0]  
         26 | STEP_MAIN + 1 | W | ADDR_STATE + 8   |  output_state[1]  
         27 | STEP_MAIN + 1 | W | ADDR_STATE + 16  |  output_state[2]  
         28 | STEP_MAIN + 1 | W | ADDR_STATE + 24  |  output_state[3]  
          . |    ...        | . |    ...           |     ...    
         49 | STEP_MAIN + 1 | W | ADDR_STATE + 192 |  output_state[24] 
        ===============================================================================================================
    */
    col witness bits(40) step_addr; 

    const int STEP_MAIN = 0;
    const int ADDR_STATE = STEP_MAIN + 1;

    const int CLOCKS_WITH_MEM_OPS = MEM_OPS / mem_ops_in_parallel;

    const expr mem_sel = clock_set(in_use, start: 0, end: CLOCKS_WITH_MEM_OPS) + 
                         clock_set(in_use, start: CLOCKS - CLOCKS_WITH_MEM_OPS, end: CLOCKS);

    const expr mem_is_write = clock_set(start: CLOCKS - CLOCKS_WITH_MEM_OPS, end: CLOCKS);

    const expr main_step = clock_shift(step_addr, STEP_MAIN, start: 0, end: CLOCKS_WITH_MEM_OPS) + 
                           clock_shift(step_addr, STEP_MAIN, start: CLOCKS - CLOCKS_WITH_MEM_OPS, end: CLOCKS);

    for (int i = 0; i < mem_ops_in_parallel; i++) {
        const expr mem_addr = clock_shift(step_addr, ADDR_STATE, start: 0, end: CLOCKS_WITH_MEM_OPS, offset: 8*i) + 
                              clock_shift(step_addr, ADDR_STATE, start: CLOCKS - CLOCKS_WITH_MEM_OPS, end: CLOCKS, offset: 8*i);

        expr mem_value[2];
        mem_value[0] = 0; // CLK_0*(     state[0] +      state[1]*2 + ... +     state[31]*2^31) + 
                          //                                 ...                                +
                          // CLK_0*(   state[256] +    state[257]*2 + ... +    state[287]*2^31) +
                          //                                 ...                                +
                          // CLK_4*(4'state[1280] + 4'state[1281]*2 + ... + 4'state[1311]*2^31) +
                          //                                 ...                                +
                          // CLK_4*(4'state[1536] + 4'state[1537]*2 + ... + 4'state[1567]*2^31)

        mem_value[1] = 0; // CLK_0*(    state[32] +     state[33]*2 + ... +     state[63]*2^31) +
                          //                                 ...                                +
                          // CLK_0*(   state[288] +    state[289]*2 + ... +    state[319]*2^31) +
                          //                                 ...                                +
                          // CLK_4*(4'state[1312] + 4'state[1313]*2 + ... + 4'state[1343]*2^31) +
                          //                                 ...                                +
                          // CLK_4*(4'state[1568] + 4'state[1569]*2 + ... + 4'state[1599]*2^31)

        // Note: STATE_SIZE is a multiple of 64
        const int bit_offset = i * BITS_PER_CLOCK;
        for (int j = 0; j < CLOCKS_WITH_MEM_OPS; j++) {
            const int inner_bit_offset = bit_offset + j * (BITS_PER_CLOCK * mem_ops_in_parallel);
            const int bit_in_row = inner_bit_offset % STATE_SIZE;
            const int row_in_state = inner_bit_offset / STATE_SIZE;

            expr value_0 = 0;
            expr value_1 = 0;
            for (int k = 0; k < BITS_PER_LIMB; k++) {
                const int factor = 2**k;
                value_0 += factor * state[bit_in_row + k];
                value_1 += factor * state[bit_in_row + BITS_PER_LIMB + k];
            }
            mem_value[0] += (CLK[j] + CLK[CLOCKS - CLOCKS_WITH_MEM_OPS + j]) * (j - row_in_state)'value_0;
            mem_value[1] += (CLK[j] + CLK[CLOCKS - CLOCKS_WITH_MEM_OPS + j]) * (j - row_in_state)'value_1;
        }

        precompiled_mem_op(
            sel: mem_sel,
            is_write: mem_is_write,
            main_step: main_step,
            addr: mem_addr,
            value: mem_value
        );
    }

    // --> Constraints to make sure that this coprocessor is called from the main processor
    lookup_proves(operation_bus_id, [OP_KECCAKF, step_addr'(STEP_MAIN), 0, step_addr'(ADDR_STATE), 0, 0, 0, 0], mul: in_use_clk_0);

    function add(const expr b[]): const expr {
        const int len = length(b);
        expr result = 0;
        for (int i = 0; i < len; i++) {
            result += b[i];
        }
        return result;
    }

    function xor(const expr b1, const expr b2): const expr {
        return add([b1, b2]);
    }

    function xor5(const expr b1, const expr b2, const expr b3, const expr b4, const expr b5): const expr {
        return add([b1, b2, b3, b4, b5]);
    }

    function nand(const expr b1, const expr b2): const expr {
        return (1 + b1) * b2;
    }

    function theta(const expr a[]): const expr[] {
        const expr result[air.WIDTH];

        // For all pairs (x, z) such that 0 ≤ x < 5 and 0 ≤ z < 64, compute:
        //      c[x, z] = a[x, 0, z] ^ a[x, 1, z] ^ a[x, 2, z] ^ a[x, 3, z] ^ a[x, 4, z]
        const expr c[5][64];
        for (int x = 0; x < 5; x++) {
            for (int z = 0; z < 64; z++) {
                c[x][z] = xor5(
                    a[bit_pos(x, 0, z)], 
                    a[bit_pos(x, 1, z)], 
                    a[bit_pos(x, 2, z)], 
                    a[bit_pos(x, 3, z)], 
                    a[bit_pos(x, 4, z)]
                );
            }
        }

        // For all pairs (x, z) such that 0 ≤ x < 5 and 0 ≤ z < 64, compute:
        //      d[x, z] = c[(x - 1) mod 5, z] ^ c[(x + 1) mod 5, (z - 1) mod 64]
        const expr d[5][64];
        for (int x = 0; x < 5; x++) {
            for (int z = 0; z < 64; z++) {
                d[x][z] = xor(c[(x + 4) % 5][z], c[(x + 1) % 5][(z + 63) % 64]);
            }
        }

        // For all triples (x, y, z) such that 0 ≤ x,y < 5 and 0 ≤ z < 64, compute:
        //      result[x, y, z] = a[x, y, z] ^ d[x, z]
        for (int x = 0; x < 5; x++) {
            for (int y = 0; y < 5; y++) {
                for (int z = 0; z < 64; z++) {
                    const int pos = bit_pos(x, y, z);
                    result[bit_pos(x, y, z)] = xor(a[bit_pos(x, y, z)], d[x][z]);
                }
            }
        }

        return result;
    }

    function rho(const expr a[]): const expr[] {
        const expr result[air.WIDTH];

        // For all z such that 0 ≤ z < 64, let result[0, 0, z] = a[0, 0, z]
        for (int z = 0; z < 64; z++) {
            const int pos = bit_pos(0, 0, z);
            result[pos] = a[pos];
        }

        // Let (x, y) = (1, 0)
        // For t from 0 to 23:  
        //      1. For all z such that 0 ≤ z < 64, let result[x, y, z] = a[x, y, (z – (t + 1)(t + 2)/2) mod 64]  
        //      2. Let (x, y) = (y, (2x + 3y) mod 5)
        int x = 1;
        int y = 0;
        for (int t = 0; t < 24; t++) {
            const int offset = ((t + 1) * (t + 2)) / 2;

            for (int z = 0; z < 64; z++) {
                const int src_z = (z + 64 - (offset % 64)) % 64;
                const int src_pos = bit_pos(x, y, src_z);
                const int dst_pos = bit_pos(x, y, z);

                result[dst_pos] = a[src_pos];
            }

            const int aux = y;
            y = (2 * x + 3 * y) % 5;
            x = aux;
        }

        return result;
    }

    function pi(const expr a[]): const expr[] {
        const expr result[air.WIDTH];

        // For all triples (x, y, z) such that 0 ≤ x,y < 5, and 0 ≤ z < 64, let:  
        //      result[x, y, z] = a[(x + 3y) mod 5, x, z].
        for (int x = 0; x < 5; x++) {
            for (int y = 0; y < 5; y++) {
                for (int z = 0; z < 64; z++) {
                    const int src_x = (x + 3 * y) % 5;
                    const int src_pos = bit_pos(src_x, x, z);
                    const int dst_pos = bit_pos(x, y, z);
                    
                    result[dst_pos] = a[src_pos];
                }
            }
        }

        return result;
    }

    function chi(const expr a[]): const expr[] {
        const expr result[air.WIDTH];

        // For all triples (x, y, z) such that 0 ≤ x,y < 5 and 0 ≤ z < 64 compute:
        //      result[x, y, z] = a[x, y, z] ^ ((¬a[(x + 1) mod 5, y, z]) & a[(x + 2) mod 5, y, z])
        for (int x = 0; x < 5; x++) {
            const int x1 = (x + 1) % 5;
            const int x2 = (x + 2) % 5;

            for (int y = 0; y < 5; y++) {
                for (int z = 0; z < 64; z++) {
                    const int src_pos0 = bit_pos(x, y, z);
                    const int src_pos1 = bit_pos(x1, y, z);
                    const int src_pos2 = bit_pos(x2, y, z);
                    const int dst_pos = src_pos0;

                    result[dst_pos] = xor(a[src_pos0], nand(a[src_pos1], a[src_pos2]));
                }
            }
        }

        return result;
    }

    function iota_and_clock_set(const expr a[], const int rc[]): const expr {
        // Get the number of rounds
        const int rounds = length(rc);

        // Precompute all rc bits
        const int rc_bits[rounds][64];
        for (int r = 0; r < rounds; r++) {
            rc_bits[r] = unpack64(rc[r]);
        }

        // Precompute clock weights
        expr clk_sum = 0;
        for (int r = 0; r < rounds; r++) {
            clk_sum += air.CLK[r];
        }

        const expr result[air.WIDTH];

        // For all triples (x, y, z) such that 0 ≤ x,y < 5 and 0 ≤ z < 64 compute:
        //      result[0, 0, z] = a[0, 0, z] ^ rc[z], if (x, y) == (0, 0)
        //      result[x, y, z] = a[x, y, z],         if (x, y) != (0, 0)
        for (int z = 0; z < 64; z++) {
            expr result0 = 0;
            expr result1 = 0;
            for (int r = 0; r < rounds; r++) {
                if (rc_bits[r][z] == 0) {
                    result0 += air.CLK[r];
                } else {
                    result1 += air.CLK[r];
                }
            }
            const int pos = bit_pos(0, 0, z);
            result[pos] = result0 * a[pos] + result1 * xor(a[pos], 1);
        }

        for (int x = 0; x < 5; x++) {
            for (int y = 0; y < 5; y++) {
                if (x == 0 && y == 0) continue;

                for (int z = 0; z < 64; z++) {
                    const int pos = bit_pos(x, y, z);
                    result[pos] = clk_sum * a[pos];
                }
            }
        }

        return result;
    }

    function unpack64(int packed): int[] {
        const int unpacked[64];
        for (int i = 0; i < 64; i++) {
            unpacked[i] = packed & 1;
            packed = packed >> 1;
        }
        return unpacked;
    }

    function process_lookup_chunk(const int chunk, const int num_bits, const expr expr_acc, const expr expr_val[], const expr sel) {
        // Calculate accumulated value for this chunk using base encoding
        const int bit_offset = chunk * KECCAKF_LOOKUP_CHUNK_SIZE;
        expr acc_val = 0;
        for (int j = 0; j < num_bits; j++) {
            acc_val += expr_val[bit_offset + j] * (KECCAKF_BASE ** j);
        }
        expr_acc === acc_val;

        const expr table_lookup_values[KECCAKF_LOOKUP_CHUNK_SIZE + 1];
        table_lookup_values[0] = expr_acc;
        
        // Add the actual state bit values
        for (int j = 0; j < num_bits; j++) {
            const int bit_index = bit_offset + j;
            const int bit_in_row = bit_index % air.STATE_SIZE;
            const int row_in_state = bit_index / air.STATE_SIZE;

            table_lookup_values[j + 1] = air.state[bit_in_row]'(air.split_state_by + row_in_state);
        }
        
        // Pad with zeros if this is a partial chunk
        for (int j = num_bits + 1; j < KECCAKF_LOOKUP_CHUNK_SIZE + 1; j++) {
            table_lookup_values[j] = 0;
        }
        
        lookup_assumes(KECCAKF_TABLE_ID, table_lookup_values, sel: sel);
    }

    function bit_pos(const int x, const int y, const int z): int {
        assert(0 <= x && x < 5);
        assert(0 <= y && y < 5);
        assert(0 <= z && z < 64);

        return 64 * x + 320 * y + z;
    }

    function clock_set(const expr mvcol = 1, const int start = 0, int end = -1): const expr {
        expr result = 0;
        if (end == -1) {
            end = start;
        }
        for (int i = start; i < end; i++) {
            result += air.CLK[i];
        }
        return result * mvcol;
    }

    function clock_shift(const expr mvcol, const int pos, const int start = 0, int end = -1, int offset = 0,  const int delta = 0): const expr {
        expr result = 0;
        if (end == -1) {
            end = start + 1;
        }
        for (int i = start; i < end; i++) {
            const int iclock = (pos - i) % air.CLOCKS;
            if (offset != 0) {
                result += air.CLK[i] * (mvcol'(iclock) + offset);
            } else {
                result += air.CLK[i] * mvcol'(iclock);
            }
            offset += delta;
        }
        return result;
    }
}