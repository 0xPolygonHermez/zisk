require "std_lookup.pil"
require "std_range_check.pil"

airtemplate Arith256 (int N = 2**18) {

    // TODO: introduction, map
    // TODO: explain concept of q
    // TODO: explain overload of last chunk

    // EQ0: x1 * y1 + x2 - x3 - y3 * p2_256                 arith 256     ARITH_256          y3|x3 = x1*y1+x2
    // EQ1: x1 * y1 + x2 - x3 - q1 * y2 * p2_256 - q0 * y2  modular arith ARITH_256_MOD      x3 = mod(x1*y1+x2, y2)
    // EQ2: s * x2 - s * x1 - y2 + y1 + (q0 * p1)           lambda - ADD  EC_ADD_SECP256K1
    // EQ3: 2 * s * y1 - 3 * x1 * x1 + (q0 * p1)            lambda - DBL  EC_DBL_SECP256K1
    // EQ4: s * s - x1 - x2 - x3 + (q1 * p1)                x3            EC_ADD_SECP256K1, EC_DBL_SECP256K1
    // EQ5: s * x1 - s * x3 - y1 - y3 + (q2 * p1)           y3            EC_ADD_SECP256K1, EC_DBL_SECP256K1

    const int CLOCKS = 16;
    col fixed CLK_0 = [1, 0:(CLOCKS-1)]...;
    const expr LAST_CLK = (CLOCKS - 1)'CLK_0;

    const int CHUNKS = CLOCKS;
    const int CBC = 2;
    const int EQ_CHUNKS = CHUNKS * 2;
    const int CHUNK_BITS = 16;
    const int CHUNK_SIZE = 2**CHUNK_BITS;
    const int CHUNK_MAX = CHUNK_SIZE - 1;
    col fixed CHUNK_ID = [0..(CHUNKS-1)]...;

    const expr CLK[CLOCKS];
    for (int i = 0; i < CLOCKS; ++i) {
        CLK[i] = (i)'CLK_0;
    }

    const int Q_HSC_MIN = -(2**22 - 1);
    const int Q_HSC_MAX = 2**22;

    const int CARRY_MIN = -(2**22 - 1);
    const int CARRY_MAX = 2**22;

    const int EQS = 6;
    const int QS = 3;

    col witness x1, y1, x2, y2, x3, y3, q0, q1, q2, s;
    col witness sel_eq[EQS];
    col witness in_use;

    col witness sel_arith256;
    col witness sel_arith256_mod;
    col witness sel_secp256k1_add;
    col witness sel_secp256k1_dbl;

    // selectors are booleans
    sel_arith256 * (1 - sel_arith256) === 0;
    sel_arith256_mod * (1 - sel_arith256_mod) === 0;
    sel_secp256k1_add * (1 - sel_secp256k1_add) === 0;
    sel_secp256k1_dbl * (1 - sel_secp256k1_dbl) === 0;

    // latch of selectors during all cycle
    (1 - CLK_0) * (sel_arith256 + 'sel_arith256) === 0;
    (1 - CLK_0) * (sel_arith256_mod + 'sel_arith256_mod) === 0;
    (1 - CLK_0) * (sel_secp256k1_add + 'sel_secp256k1_add) === 0;
    (1 - CLK_0) * (sel_secp256k1_dbl + 'sel_secp256k1_dbl) === 0;

    // only one selector could be enabled
    const expr sel_any = sel_arith256 + sel_arith256_mod + sel_secp256k1_add + sel_secp256k1_dbl;
    sel_any * (1 - sel_any) === 1;

    // groups of selectors
    const expr sel_secp256k1 = sel_secp256k1_add + sel_secp256k1_dbl;
    const expr sel_any_arith256 = sel_arith256 + sel_arith256_mod;
    const expr sel_check_diff = sel_secp256k1_add;
    const expr sel_check_lt_prime = sel_secp256k1 + sel_arith256_mod;

    // constraint to set (x1,y1) = (x2,y2) in secp256k1_dbl
    sel_secp256k1_dbl * (x1 - x2) === 0;
    sel_secp256k1_dbl * (y1 - y2) === 0;

    const int eq2carry[EQS] = [0,0,0,0,1,2];

    const expr coordinates[6]= [x1, y1, x2, y2, x3, y3];
    const expr qs[QS] = [q0, q1, q2];

    // TODO: explain concept of row_offset with x1, y1, x2, y2, x3, y3

    include "eq_arith256.pil"
    include "eq_arith256_mod.pil"
    include "eq_secp256k1_add.pil"
    include "eq_secp256k1_dbl.pil"
    include "eq_secp256k1_x3.pil"
    include "eq_secp256k1_y3.pil"

    col witness eq_arith256[CBC];
    col witness eq_arith256_mod[CBC];
    col witness eq_secp256k1_add[CBC];
    col witness eq_secp256k1_dbl[CBC];
    col witness eq_secp256k1_x3[CBC];
    col witness eq_secp256k1_y3[CBC];

    for (int i = 0; i < CBC; ++i) {
        eq_arith256[i] === expr_group_by_cbc(eq_arith256_chunks, i);
        eq_arith256_mod[i] === expr_group_by_cbc(eq_arith256_mod_chunks, i);
        eq_secp256k1_add[i] === expr_group_by_cbc(eq_secp256k1_add_chunks, i);
        eq_secp256k1_dbl[i] === expr_group_by_cbc(eq_secp256k1_dbl_chunks, i);
        eq_secp256k1_x3[i] === expr_group_by_cbc(eq_secp256k1_x3_chunks, i);
        eq_secp256k1_y3[i] === expr_group_by_cbc(eq_secp256k1_y3_chunks, i);
    }

    for (int i = 0; i < length(coordinates); ++i) {
        range_check(min: 0, max: CHUNK_MAX, expression: coordinates[i]);
        if (i < length(qs)) {
            multi_range_check(min1: 0, max1: CHUNK_MAX, min2: Q_HSC_MIN, max2: Q_HSC_MAX,
                              range_sel: 'CLK_0, expression: qs[i]);
        }
        if (i < length(sel_eq)) {
            sel_eq[i] * (1 - sel_eq[i]) === 0;
        }
    }
    in_use * (1 - in_use) === 0;


    // FEATURE
    // Verify that the x1,x2 are different when adding different elliptic curve points.

    // PRE
    // x1,x2,y1,y2 are alias free for elliptic curve operations

    // STRATEGY
    // If x1,x2 are different means at least in one chunk x2-x1 ≠ 0. To verify it we define
    // x_delta_chunk and his inverse, x_delta_chunk_inv. We only need in one chunk calculate
    // inverse to demostrate that x1 and x2 are different.

    const expr x_delta_chunk = x2 - x1;
    col witness x_delta_chunk_inv;

    // x_chunk_different as binary value, only when x_delta_chunk_inv == inv(x_delta_chunk),
    // its value is 1.
    //
    // x_chunk_different: 1 ==> x1[i] != x2[i]
    //                    0 does not imply anything, x1[i] ≠ x2[i] or x1[i] == x2[i].

    const expr x_chunk_different = x_delta_chunk * x_delta_chunk_inv;
    x_chunk_different * (1 - x_chunk_different) === 0;

    // x_delta_chunk  x_delta_chunk_inv  x_chunk_different
    // -------------  -----------------  ------------------
    //        0             any          0 * any = 0            OK (1)
    //    x (≠ 0)            0           x * 0 = 0              OK (2)
    //    x (≠ 0)          inv(x)        x * inv(x) = 1         OK (3)
    //    x (≠ 0)       j ≠ {inv(x),0}   x * j = k (≠ 0,1)      FAILS (4)
    //
    // (1) and (3) are the standard cases, but (2) was introduced to avoid calculate the inverse
    // when it is not necessary. x_chunk_different is well calculed because it's 1 only when x ≠ 0
    // and  inverse it's calculated.

    // x_are_different is used to indicate that in current clock we knows that x1 and x2 are different

    col witness x_are_different;
    x_are_different * (1 - x_are_different) === 0;

    // x_are_different in first clock that x_are_different == 1, after that x_are_different must be 0.

    x_are_different === 'x_are_different * (1 - CLK_0) + x_chunk_different;

    // 'x_are_different  CLK  x_chunk_different  x_are_different
    // ----------------  ---  -----------------  --------------
    //          0         0          0            0 OK
    //          0         0          1            1 OK
    //          0         1          0            1 OK
    //          0         1          1            1 OK
    //          1         0          0            1 OK
    //          1         0          1            2 FAILS, x_are_different ≠ 0,1 (1)
    //          1         1          0            1 OK
    //          1         1          1            1 OK

    // (1) forbidden, executor must control this situation, because expending an
    // unnecessary inverse. In last clock of cycle we check that x_are_different == 0 if
    // we need to verify this condition.

    (x_are_different - sel_check_diff) * LAST_CLK === 0;

    // FEATURE:
    //
    // Verify that the result of finite field operations are free alias, i.e. that x3,y3 ∊ [0, p-1]
    // Here, p refers to field prime number, in case of the elliptic curves is the base field.
    //
    // Limitations: Chunks are ordered from least significant to most significant.
    //
    // Strategy: Define a lt flag, and use a table to validate the transition of this flag. The table
    // has other columns as as the position (0..CHUNKS-1), the prime_id and the value of the chunk.
    // For an specific chunk of specific prime we has:
    //
    // LT_P = less than prime chunk
    // EQ_P = equal to prime chunk
    // GT_P = greater than prime chunk
    //
    // 'lt   lt   valid values
    // ---   ---  ------------
    //  0 ->  0   EQ_P, GT_P
    //  0 ->  1   LT_P
    //  1 ->  0   GT_P
    //  1 ->  1   EQ_P, LT_P
    //
    // For first clock of cycle, 'lt must be 0, we could do it we need use 'lt * (1 - CLK) on 'lt
    // column, but it increases degree. It's better use a different table for first chunk, basically
    // a table that ignores 'lt value. It's easy because we has a table by chunk and prime number.
    //
    // 'lt   lt   valid values
    // ---   ---  ------------
    //  0 ->  0   EQ_P, GT_P
    //  0 ->  1   LT_P
    //  1 ->  0   EQ_P, GT_P
    //  1 ->  1   LT_P
    //
    // This tables for chunk and prime number has size of 2 * CHUNK_SIZE rows, 2^17 for 256-bit prime
    // numbers, full table are 2^17 * 2^4 = 2^21 rows.

    // FEATURE:
    //
    // Verify that the result of modular operation, y3 = mod(x1*y1+x2, y2) are free alias, i.e.
    // that y3 ∊ [0, y2-1]
    //
    // Limitations: Chunks are ordered from least significant to most significant.
    //
    // Strategy: Simulate as substract, chunk by chunk. For readibility, we use x as result and
    // z as module (X≡y3, Z≡y2), MAX = CHUNK_SIZE - 1;
    //
    // case    X - Z           borrow
    // -----  ---------------  ------
    // X = Z  0 = ZERO           0
    // X > Z  [1, MAX] = POS     0
    // X < Z  [-1, -MAX] = NEG   1
    //
    // At end of substraction, if and only if borrow is 1, X < Z.
    // A continuation, borrow transtion table
    //
    // Xi = Zi  borrow = 'borrow
    // Xi > Zi  borrow = 0
    // Xi < Zi  borrow = 1
    //
    // Following the transtion table:
    //
    // 'borrow  borrow  valid values
    // -------  ------  ------------
    //     0  ->  0     ZERO, POS
    //     0  ->  1     NEG
    //     1  ->  0     POS
    //     1  ->  1     ZERO, NEG
    //
    // As we made for prime tables, for first clock of cycle, 'borrow must be 0, we could do it
    // using a different table for first chunk, basically a table that ignores 'borrow value.
    //
    // 'borrow  borrow  valid values
    // -------  ------  ------------
    //     0  ->  0     ZERO, POS
    //     0  ->  1     NEG
    //     1  ->  0     ZERO, POS
    //     1  ->  1     NEG
    //
    // These tables are bigger than previous prime table.
    // They has size of 2 * (2 * CHUNK_SIZE - 1) ≈ 2^18 rows, to avoid increment the degree or add
    // extra column, we replicate this table for all chunks, total size is 2^18 * 2^4 = 2^22 rows.
    // An extra column here is "pay" for each instance, but in a table is paid once.

    col witness lt_borrow;
    col witness lt;

    lt_borrow * (1 - lt_borrow) === 0;
    lt * (1 - lt) === 0;

    col witness carry[3][CBC];

    for (int i = 0; i < CBC; ++i) {
        for (int j = 0; j < 3; ++j) {
            carry[j][i] * CLK_0 === 0;
            range_check(min:CARRY_MIN, max: CARRY_MAX, expression: carry[j][i]);
        }
        sel_arith256 * (eq_arith256[i] + carry[0][i]) === sel_arith256 * carry[0][i]' * CHUNK_SIZE;
        sel_arith256_mod * (eq_arith256_mod[i] + carry[0][i]) === sel_arith256_mod * carry[0][i]' * CHUNK_SIZE;
        sel_secp256k1_add * (eq_secp256k1_add[i] + carry[0][i]) === sel_secp256k1_add * carry[0][i]' * CHUNK_SIZE;
        sel_secp256k1_dbl * (eq_secp256k1_dbl[i] + carry[0][i]) === sel_secp256k1_dbl * carry[0][i]' * CHUNK_SIZE;
        sel_secp256k1 * (eq_secp256k1_x3[i] + carry[1][i]) === sel_secp256k1 * carry[1][i]' * CHUNK_SIZE;
        sel_secp256k1 * (eq_secp256k1_y3[i] + carry[2][i]) === sel_secp256k1 * carry[2][i]' * CHUNK_SIZE;
    }

    // There are some values that no change during all cycle, normally we define a constraint
    // like latch to guarantee that these values are the same in all clocks. In this case, we
    // define that for some of these type of values, only "use" one clock inside the cycle and
    // use only one column for different values.

    // In this case, step_addr is the column, in first clock of cycle, mem_step is step_addr, but
    // in clock 1 is 'step_addr, in clock 2 is 2'step_addr, and so on. In case of addr, in clock 0
    // is step_addr', in clock 1 is step_addr, in clock 2 is 'step_addr, and so on.

    // With this technique we could save some columns, but it isn't free, because if we would build
    // a expression to read a value for any clock, we need to define a sequence of sums with multiplication
    // of clock selector and step_addr. This expression has degree 2. In some situations it could be
    // useful to save columns.

    col witness step_addr;

    const int MEM_STEP = 0;

    // 4 reads    256 bits  = 4 * 4 = 16 reads 64 bits
    // 2 writes   256 bits  = 2 * 4 =  8 writes 64 bits
    // 6 indirect  64 bits  = 6 * 1 =  6 reads 64 bits
    //                     TOTAL    = 30 memory accesses

    //                 READ           WRITE      INDIRECT
    // secp256k1_add   x1,y1,x2,y2    x3,y3      (x1,y1)(x2,y2)
    // secp256k1_dbl   x1,y2          x3,y3      (x1,y1)
    // arith256        x1,y1,x2       x3,y3      x1,y1,x2,x3,y3
    // arith256_mod    x1,y1,x2,y2    x3         x1,y1,x2,y2,x3

    const int ADDR_OP = MEM_STEP + 1;
    const int ADDR_X1 = ADDR_OP + 1;
    const int ADDR_Y1 = ADDR_X1 + 1;
    const int ADDR_X2 = ADDR_X1 + 2;
    const int ADDR_Y2 = ADDR_X1 + 3;
    const int ADDR_X3 = ADDR_X1 + 4;
    const int ADDR_Y3 = ADDR_X1 + 5;

    const int ADDR_IND_0 = ADDR_Y3 + 1;
    const int ADDR_IND_1 = ADDR_IND_0 + 1;
    const int ADDR_IND_2 = ADDR_IND_0 + 2;
    const int ADDR_IND_3 = ADDR_IND_0 + 3;
    const int ADDR_IND_4 = ADDR_IND_0 + 4;
    const int ADDR_IND_5 = ADDR_IND_0 + 5;

    // MEMORY ACCESS MAP
    //
    //  0  STEP     | R | ADDR_X1       x1[0..3]    1         | ADDR_Y1       y1[0..3]    1
    //  1  STEP     | R | ADDR_X1 + 8   x1[4..7]    1         | ADDR_Y1 + 8   y1[4..7]    1
    //  2  STEP     | R | ADDR_X1 + 16  x1[8..11]   1         | ADDR_Y1 + 16  y1[8..11]   1
    //  3  STEP     | R | ADDR_X1 + 24  x1[12..15]  1         | ADDR_Y1 + 24  y1[12..15]  1
    //  4  STEP     | R | ADDR_X2       x2[0..3]    1         | ADDR_Y2       y2[0..3]    use_y2
    //  5  STEP     | R | ADDR_X2 + 8   x2[4..7]    1         | ADDR_Y2 + 8   y2[4..7]    use_y2
    //  6  STEP     | R | ADDR_X2 + 16  x2[8..11]   1         | ADDR_Y2 + 16  y2[8..11]   use_y2
    //  7  STEP     | R | ADDR_X2 + 24  x2[12..15]  1         | ADDR_Y2 + 24  y2[12..15]  use_y2
    //  8  STEP + 1 | W | ADDR_X3       x3[0..3]    1         | ADDR_Y3       y3[0..3]    use_y3
    //  9  STEP + 1 | W | ADDR_X3 + 8   x3[4..7]    1         | ADDR_Y3 + 8   y3[4..7]    use_y3
    // 10  STEP + 1 | W | ADDR_X3 + 16  x3[8..11]   1         | ADDR_Y3 + 16  y3[8..11]   use_y3
    // 11  STEP + 1 | W | ADDR_X3 + 24  x3[12..15]  1         | ADDR_Y3 + 24  y3[12..15]  use_y3
    // 12  STEP     | R | ADDR_OP + 1   ADDR_IND_0  use_ind_0 | ADDR_OP + 1   ADDR_IND_1  use_ind_1
    // 13  STEP     | R | ADDR_OP + 3   ADDR_IND_2  use_ind_2 | ADDR_OP + 3   ADDR_IND_3  use_ind_3
    // 14  STEP     | R | ADDR_OP + 5   ADDR_IND_4  use_ind_4 | ADDR_OP + 5   ADDR_IND_5  use_ind_5
    // 15  ---       ----------     -------                 ----------      ---------

    const expr use_y2 = sel_arith256_mod + sel_secp256k1_add + sel_secp256k1_dbl;
    const expr use_y3 = sel_arith256 + sel_secp256k1_add + sel_secp256k1_dbl;

    // [secp256k1_dbl] ADDR_X1 === ADDR_OP,
    //                 ADDR_Y1 === ADDR_OP + 32
    //
    // [secp256k1_add] ADDR_X1 === ADDR_IND_0,
    //                 ADDR_Y1 === ADDR_IND_0 + 32
    //
    // [secp256k1]     ADDR_X3 === ADDR_X1, ADDR_Y3 === ADDR_Y1
    //
    // [any_arith256]  ADDR_X1 === ADDR_IND_0

    const expr use_ind_0 = sel_any_arith256 + sel_secp256k1_add;

    sel_secp256k1_dbl * clock_eq(step_addr, ADDR_X1, ADDR_OP) === 0;
    sel_secp256k1_dbl * clock_eq(step_addr, ADDR_Y1, ADDR_OP, 32) === 0;

    sel_secp256k1_add * clock_eq(step_addr, ADDR_X1, ADDR_IND_0) === 0;
    sel_secp256k1_add * clock_eq(step_addr, ADDR_Y1, ADDR_IND_0, 32) === 0;

    sel_secp256k1 * clock_eq(step_addr, ADDR_X1, ADDR_X3) === 0;
    sel_secp256k1 * clock_eq(step_addr, ADDR_Y1, ADDR_Y3) === 0;

    sel_any_arith256 * clock_eq(step_addr, ADDR_X1, ADDR_OP) === 0;

    // [secp256k1_add] ADDR_X2 === ADDR_IND_1
    //                 ADDR_Y2 === ADDR_IND_1 + 32
    //
    // [any_arith256]  ADDR_Y1 === ADDR_IND_1

    const expr use_ind_1 = sel_any_arith256 + sel_secp256k1_add;

    sel_secp256k1_add * clock_eq(step_addr, ADDR_X2, ADDR_IND_1) === 0;
    sel_secp256k1_add * clock_eq(step_addr, ADDR_Y2, ADDR_IND_1, 32) === 0;

    sel_any_arith256 * clock_eq(step_addr, ADDR_Y1, ADDR_IND_1) === 0;

    // [any_arith256]  ADDR_X2 === ADDR_IND_2

    const expr use_ind_2 = sel_any_arith256;

    sel_any_arith256 * clock_eq(step_addr, ADDR_X2, ADDR_IND_2) === 0;

    // [arith256]      ADDR_X3 === ADDR_IND_3
    //
    // [arith256_mod]  ADDR_Y2 === ADDR_IND_3

    const expr use_ind_3 = sel_any_arith256;

    sel_arith256 * clock_eq(step_addr, ADDR_X3, ADDR_IND_3) === 0;
    sel_arith256_mod * clock_eq(step_addr, ADDR_Y2, ADDR_IND_3) === 0;

    // [arith256]      ADDR_Y3 === ADDR_IND_4
    //
    // [arith256_mod]  ADDR_X3 === ADDR_IND_4

    const expr use_ind_4 = sel_any_arith256;

    sel_arith256 * clock_eq(step_addr, ADDR_Y3, ADDR_IND_4) === 0;
    sel_arith256_mod * clock_eq(step_addr, ADDR_X3, ADDR_IND_4) === 0;

    const expr use_ind_5 = 0;

    const expr mem_addr[2];
    mem_addr[0] = clock_map(step_addr, ADDR_X1, start: 0, end: 3, delta: 8) +
                  clock_map(step_addr, ADDR_X2, start: 4, end: 7, delta: 8) +
                  clock_map(step_addr, ADDR_X3, start: 8, end: 11, delta: 8) +
                  clock_map(step_addr, ADDR_OP, start: 12, end: 14, delta: 2);

    mem_addr[1] = clock_map(step_addr, ADDR_Y3, start: 0, end: 3, delta: 8) +
                  clock_map(step_addr, ADDR_Y3, start: 4, end: 7, delta: 8) +
                  clock_map(step_addr, ADDR_Y3, start: 8, end: 11, delta: 8) +
                  clock_map(step_addr, ADDR_OP, start: 12, end: 14, delta: 2, offset: 1);

    const expr mem_step = clock_map(step_addr, MEM_STEP, start: 0, end: 7) +
                          clock_map(step_addr, MEM_STEP, start: 8, end: 11, offset: 1) +
                          clock_map(step_addr, MEM_STEP, start: 12, end: 14);

    const expr mem_op = clock_map(step_addr, MEMORY_LOAD_OP, start: 0, end: 7) +
                        clock_map(step_addr, MEMORY_STORE_OP, start: 8, end: 11) +
                        clock_map(step_addr, MEMORY_LOAD_OP, start: 12, end: 14);

    const expr mem_value[2][2];

    mem_value[0][0] =   map_chunks_to_m32(x1, start: 0, end: 3) +
                        map_chunks_to_m32(x2, start: 4, end: 7) +
                        map_chunks_to_m32(x3, start: 8, end: 11) +
                        clock_map(step_addr, ADDR_IND_0, 12) +
                        clock_map(step_addr, ADDR_IND_2, 13) +
                        clock_map(step_addr, ADDR_IND_4, 14);

    mem_value[0][1] =   map_chunks_to_m32(x1, index: 2, start:0, end: 3) +
                        map_chunks_to_m32(x2, index: 2, start:4, end: 7) +
                        map_chunks_to_m32(x3, index: 2, start:8, end: 11);

    mem_value[1][0] =   map_chunks_to_m32(y1, start: 0, end: 3) +
                        map_chunks_to_m32(y2, start: 4, end: 7) +
                        map_chunks_to_m32(y3, start: 8, end: 11) +
                        clock_map(step_addr, ADDR_IND_1, 12) +
                        clock_map(step_addr, ADDR_IND_3, 13) +
                        clock_map(step_addr, ADDR_IND_5, 14);

    mem_value[1][1] =   map_chunks_to_m32(y1, index: 2, start:0, end: 3) +
                        map_chunks_to_m32(y2, index: 2, start:4, end: 7) +
                        map_chunks_to_m32(y3, index: 2, start:8, end: 11);

    const expr mem_sel[2];

    mem_sel[0] = clock_set(1, start:0, end: 11) +
                 clock_set(use_ind_0, 12) +
                 clock_set(use_ind_2, 13) +
                 clock_set(use_ind_4, 14);

    mem_sel[1] = clock_set(1, start:0, end: 3) +
                 clock_set(use_y2, start:4, end: 7) +
                 clock_set(use_y3, start:8, end: 11) +
                 clock_set(use_ind_1, 12) +
                 clock_set(use_ind_3, 13) +
                 clock_set(use_ind_5, 14);


    function expr_group_by_cbc(const expr chunks[], const int index ): const expr {
        expr res = 0;
        int iclock = 0;
        for (int i = 0; i < length(chunks); ++i) {
            if (i % air.CBC == index) {
                res += (iclock)'air.CLK_0 * chunks[i];
                ++iclock;
            }
        }
        return res;
    }

    function map_chunks_to_m32(const expr cl, int index = 0, int start = 0, int end = 0, int delta_index = 4 ): const expr {
        expr res = 0;
        for (int iclock = start; iclock <= end; ++iclock) {
            res += air.CLK[iclock]*(index_on_clock(cl, index, iclock) + air.CHUNK_SIZE * index_on_clock(cl, index + 1, iclock));
            index += delta_index;
        }
        return res;
    }

    function chunk_to_m32_on_clock(const expr cl, int index, int current_clock): const expr {
        return air.CLK[cl]*(index_on_clock(cl, index, current_clock) + index_on_clock(cl, index + 1, current_clock));
    }

    function index_on_clock(const expr cl, int index, int current_clock): const expr {
        return cl'(index - current_clock);
    }

    function clock_map(const expr mvcol, int pos, int start = 0, int end = -1, int offset = 0, int delta = 0): const expr {
        expr res = 0;
        if (end == -1) {
            end = start;
        }
        for (int index = start; index <= end; ++index) {
            int iclock = (pos - index ) % air.CLOCKS;
            if (offset != 0) {
                res += air.CLK[index] * (mvcol'(iclock) + offset);
            } else {
                res += air.CLK[index] * mvcol'(iclock);
            }
            offset += delta;
        }
        return res;
    }

    function clock_set(const expr cl, int start = 0, int end = -1, int offset = 0, int delta = 0): const expr {
        expr res = 0;
        if (end == -1) {
            end = start;
        }
        for (int index = start; index <= end; ++index) {
            if (offset != 0) {
                res += air.CLK[index] * (cl + offset);
            } else {
                res += air.CLK[index] * cl;
            }
            offset += delta;
        }
        return res;
    }

    function clock_eq(const expr mvcol, int pos1, int pos2, int pos2_offset = 0): const expr {
        return air.CLK_0 * (mvcol'(pos1) - mvcol'(pos2) - pos2_offset);
    }
}