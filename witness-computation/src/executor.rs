use p3_field::PrimeField;
use pil_std_lib::Std;
use proofman::WitnessManager;
use proofman_common::{ExecutionCtx, ProofCtx, SetupCtx};
use proofman_util::{timer_start_debug, timer_stop_and_log_debug};

use rayon::prelude::*;

use sm_arith::ArithSM;
use sm_binary::BinarySM;
use sm_common::create_prover_buffer;
use sm_main::{InstanceExtensionCtx, MainSM};
use sm_mem::MemProxy;
use sm_rom::RomSM;
use std::{
    fs,
    path::{Path, PathBuf},
    sync::Arc,
    thread,
};
use zisk_core::{Riscv2zisk, ZiskOperationType, ZiskRom, ZISK_OPERATION_TYPE_VARIANTS};
use zisk_pil::{
    ARITH_AIR_IDS, BINARY_AIR_IDS, BINARY_EXTENSION_AIR_IDS, MAIN_AIR_IDS, ROM_AIR_IDS,
    ZISK_AIRGROUP_ID,
};
use ziskemu::{EmuOptions, ZiskEmulator};

pub struct ZiskExecutor<F: PrimeField> {
    /// ZisK ROM, a binary file that contains the ZisK program to be executed
    pub zisk_rom: Arc<ZiskRom>,

    /// Main State Machine
    pub main_sm: Arc<MainSM<F>>,

    /// ROM State Machine
    pub rom_sm: Arc<RomSM<F>>,

    /// Memory State Machine
    pub mem_proxy_sm: Arc<MemProxy<F>>,

    /// Binary State Machine
    pub binary_sm: Arc<BinarySM<F>>,

    /// Arithmetic State Machine
    pub arith_sm: Arc<ArithSM<F>>,
}

impl<F: PrimeField> ZiskExecutor<F> {
    const NUM_THREADS: usize = 8;

    pub fn new(wcm: Arc<WitnessManager<F>>, rom_path: PathBuf) -> Self {
        let std = Std::new(wcm.clone());

        let rom_sm = RomSM::new(wcm.clone());
        let mem_proxy_sm = MemProxy::new(wcm.clone(), std.clone());
        let binary_sm = BinarySM::new(wcm.clone(), std.clone());
        let arith_sm = ArithSM::new(wcm.clone());

        // If rom_path has an .elf extension it must be converted to a ZisK ROM
        let zisk_rom = if rom_path.extension().unwrap() == "elf" {
            // Create an instance of the RISCV -> ZisK program converter
            let rv2zk = Riscv2zisk::new(
                rom_path.display().to_string(),
                String::new(),
                String::new(),
                String::new(),
            );

            // Convert program to rom
            match rv2zk.run() {
                Ok(rom) => rom,
                Err(e) => {
                    panic!("Application error: {}", e);
                }
            }
        } else {
            // TODO - Remove this when the ZisK ROM is able to be loaded from a file
            panic!("ROM file must be an ELF file");
        };

        let zisk_rom = Arc::new(zisk_rom);

        // TODO - Compute MAX_ACCUMULATED having the num_rows of the Main AIR
        // TODO - If there is more than one Main AIR available, the MAX_ACCUMULATED will be the one
        // with the highest num_rows. It has to be a power of 2.

        let main_sm =
            MainSM::new(wcm.clone(), mem_proxy_sm.clone(), arith_sm.clone(), binary_sm.clone());

        Self { zisk_rom, main_sm, rom_sm, mem_proxy_sm, binary_sm, arith_sm }
    }

    /// Executes the MainSM state machine and processes the inputs in batches when the maximum
    /// number of accumulated inputs is reached. The MainSM state machine uses the emulator to
    /// execute the a program and using a callback the main state machine receives batches of
    /// inputs generated by the emulator. The inputs are processed in batches when the maximum
    /// number of accumulated inputs is reached
    /// # Arguments
    /// * `pctx` - Proof context to interact with the proof system
    /// * `ectx` - Execution context to interact with the execution environment
    pub fn execute(
        &self,
        rom_path: &Path,
        public_inputs_path: &Path,
        pctx: Arc<ProofCtx<F>>,
        ectx: Arc<ExecutionCtx<F>>,
        sctx: Arc<SetupCtx<F>>,
    ) {
        let air_main = pctx.pilout.get_air(ZISK_AIRGROUP_ID, MAIN_AIR_IDS[0]);

        // Prepare the settings for the emulator
        let emu_options = EmuOptions {
            elf: Some(rom_path.to_path_buf().display().to_string()),
            inputs: Some(public_inputs_path.display().to_string()),
            trace_steps: Some(air_main.num_rows() as u64 - 1),
            ..EmuOptions::default()
        };

        // Call emulate with these options
        let public_inputs = {
            // Read inputs data from the provided inputs path
            let path = PathBuf::from(public_inputs_path.display().to_string());
            fs::read(path).expect("Could not read inputs file")
        };
        let public_inputs = Arc::new(public_inputs);

        // During ROM processing, we gather execution data necessary for creating the AIR instances.
        // This data is collected by the emulator and includes the minimal execution trace,
        // along with essential state information of the processor. This ensures that the execution
        // can be reproduced from specific points in the trace to generate the inputs for each state
        // machine. We aim to track the starting point of execution for every N instructions
        // across different operation types. Currently, we are only collecting data for
        // Binary and BinaryE operations.
        let air_arith = pctx.pilout.get_air(ZISK_AIRGROUP_ID, ARITH_AIR_IDS[0]);
        let air_binary = pctx.pilout.get_air(ZISK_AIRGROUP_ID, BINARY_AIR_IDS[0]);
        let air_binary_e = pctx.pilout.get_air(ZISK_AIRGROUP_ID, BINARY_EXTENSION_AIR_IDS[0]);

        let mut op_sizes = [0u64; ZISK_OPERATION_TYPE_VARIANTS];
        // The starting points for the Main is allocated using None operation
        op_sizes[ZiskOperationType::None as usize] = air_main.num_rows() as u64;
        op_sizes[ZiskOperationType::Arith as usize] = air_arith.num_rows() as u64;
        op_sizes[ZiskOperationType::Binary as usize] = air_binary.num_rows() as u64;
        op_sizes[ZiskOperationType::BinaryE as usize] = air_binary_e.num_rows() as u64;

        // STEP 1. Generate all inputs
        // ==============================================

        // Memory State Machine
        // ----------------------------------------------
        let mem_thread = thread::spawn({
            let zisk_rom = self.zisk_rom.clone();
            let public_inputs = public_inputs.clone();
            move || {
                ZiskEmulator::par_process_rom_memory::<F>(&zisk_rom, &public_inputs)
                    .expect("Failed in ZiskEmulator::par_process_rom_memory")
            }
        });

        // ROM State Machine
        // ----------------------------------------------
        // Run the ROM to compute the ROM witness
        let rom_thread = thread::spawn({
            let zisk_rom = self.zisk_rom.clone();
            let public_inputs = public_inputs.clone();
            let emu_options_cloned = emu_options.clone();
            move || {
                ZiskEmulator::process_rom_pc_histogram(
                    &zisk_rom,
                    &public_inputs,
                    &emu_options_cloned,
                )
                .expect("MainSM::execute() failed calling ZiskEmulator::process_rom_pc_histogram()")
            }
        });

        // Main, Binary and Arith State Machines
        // ----------------------------------------------
        // Run the emulator in parallel n times to collect execution traces
        // and record the execution starting points for each AIR instance
        timer_start_debug!(PAR_PROCESS_ROM);
        let (emu_traces, mut emu_slices) = ZiskEmulator::par_process_rom::<F>(
            &self.zisk_rom,
            &public_inputs,
            &emu_options,
            Self::NUM_THREADS,
            op_sizes,
        )
        .expect("Error during emulator execution");
        timer_stop_and_log_debug!(PAR_PROCESS_ROM);

        // STEP 2. Wait until all inputs are generated
        // ==============================================
        // Join all the threads to synchronize the execution
        let mut mem_required = mem_thread.join().expect("Error during Memory witness computation");
        let rom_required = rom_thread.join().expect("Error during ROM witness computation");

        // STEP 3. Generate AIRs and Prove
        // ==============================================

        // Memory State Machine
        // ----------------------------------------------
        let mem_thread = thread::spawn({
            let mem_proxy_sm = self.mem_proxy_sm.clone();
            move || {
                mem_proxy_sm
                    .prove(&mut mem_required)
                    .expect("Error during Memory witness computation")
            }
        });

        // ROM State Machine
        // ----------------------------------------------
        let (rom_is_mine, rom_instance_gid) =
            ectx.dctx.write().unwrap().add_instance(ZISK_AIRGROUP_ID, ROM_AIR_IDS[0], 1);

        let rom_thread = if rom_is_mine {
            let rom_sm = self.rom_sm.clone();
            let zisk_rom = self.zisk_rom.clone();

            Some(thread::spawn(move || rom_sm.prove(&zisk_rom, rom_required, rom_instance_gid)))
        } else {
            None
        };

        // Main, Binary and Arith State Machines
        // ----------------------------------------------
        emu_slices.points.sort_by(|a, b| a.op_type.partial_cmp(&b.op_type).unwrap());

        // FIXME: Move InstanceExtensionCtx form main SM to another place
        let mut instances_extension_ctx: Vec<InstanceExtensionCtx<F>> =
            Vec::with_capacity(emu_slices.points.len());

        let mut dctx = ectx.dctx.write().unwrap();
        let mut main_segnent_id = 0;
        for emu_slice in emu_slices.points.iter() {
            let (airgroup_id, air_id) = match emu_slice.op_type {
                ZiskOperationType::None => (ZISK_AIRGROUP_ID, MAIN_AIR_IDS[0]),
                ZiskOperationType::Arith => (ZISK_AIRGROUP_ID, ARITH_AIR_IDS[0]),
                ZiskOperationType::Binary => (ZISK_AIRGROUP_ID, BINARY_AIR_IDS[0]),
                ZiskOperationType::BinaryE => (ZISK_AIRGROUP_ID, BINARY_EXTENSION_AIR_IDS[0]),
                _ => panic!("Invalid operation type"),
            };
            let segment_id = match emu_slice.op_type {
                ZiskOperationType::None => {
                    main_segnent_id += 1;
                    Some(main_segnent_id - 1)
                }
                _ => None,
            };

            if let (true, global_idx) = dctx.add_instance(airgroup_id, air_id, 1) {
                let (buffer, offset) = create_prover_buffer::<F>(&ectx, &sctx, airgroup_id, air_id);
                instances_extension_ctx.push(InstanceExtensionCtx::new(
                    buffer,
                    offset,
                    emu_slice.op_type,
                    emu_slice.emu_trace_start.clone(),
                    segment_id,
                    global_idx,
                    None,
                ));
            }
        }
        drop(dctx);

        instances_extension_ctx.par_iter_mut().for_each(|iectx| match iectx.op_type {
            ZiskOperationType::None => {
                self.main_sm.prove_main(&self.zisk_rom, &emu_traces, iectx, &pctx);
            }
            ZiskOperationType::Arith => {
                self.main_sm.prove_arith(&self.zisk_rom, &emu_traces, iectx, &pctx);
            }
            ZiskOperationType::Binary => {
                self.main_sm.prove_binary(&self.zisk_rom, &emu_traces, iectx, &pctx);
            }
            ZiskOperationType::BinaryE => {
                self.main_sm.prove_binary_extension(&self.zisk_rom, &emu_traces, iectx, &pctx);
            }
            _ => panic!("Invalid operation type"),
        });
        // Drop the emulator traces concurrently
        std::thread::spawn(move || {
            drop(emu_traces);
        });

        timer_start_debug!(ADD_INSTANCES_TO_THE_REPO);
        for iectx in instances_extension_ctx {
            if let Some(air_instance) = iectx.air_instance {
                pctx.air_instance_repo
                    .add_air_instance(air_instance, Some(iectx.instance_global_idx));
            }
        }
        timer_stop_and_log_debug!(ADD_INSTANCES_TO_THE_REPO);

        mem_thread.join().expect("Error during Memory witness computation");

        // match mem_thread.join() {
        //     Ok(_) => println!("El thread ha finalitzat correctament."),
        //     Err(e) => {
        //         println!("El thread ha fet panic!");
        //
        //         // Converteix l'error en una cadena llegible (opcional)
        //         if let Some(missatge) = e.downcast_ref::<&str>() {
        //             println!("Missatge d'error: {}", missatge);
        //         } else if let Some(missatge) = e.downcast_ref::<String>() {
        //             println!("Missatge d'error: {}", missatge);
        //         } else {
        //             println!("No es pot determinar el tipus d'error.");
        //         }
        //     }
        // }
        if let Some(thread) = rom_thread {
            let _ = thread.join().expect("Error during ROM witness computation");
        }

        self.mem_proxy_sm.unregister_predecessor();
        self.binary_sm.unregister_predecessor();
        self.arith_sm.unregister_predecessor();
    }
}
