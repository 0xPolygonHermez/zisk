use std::{path::PathBuf, sync::Arc};

use p3_field::PrimeField;
use pil_std_lib::Std;
use proofman::WitnessManager;
use proofman_common::{ExecutionCtx, ProofCtx, SetupCtx};
use sm_arith::ArithSM;
use sm_binary::BinarySM;
use sm_main::MainSM;
use sm_mem::MemSM;
use sm_rom::RomSM;

pub struct ZiskExecutor<F: PrimeField> {
    // State machines
    pub main_sm: Arc<MainSM<F>>,
}

impl<F: PrimeField> ZiskExecutor<F> {
    pub fn new(wcm: Arc<WitnessManager<F>>, rom_path: PathBuf) -> Self {
        let std = Std::new(wcm.clone());

        let rom_sm = RomSM::new(wcm.clone());
        let mem_sm = MemSM::new(wcm.clone());
        let binary_sm = BinarySM::new(wcm.clone(), std.clone());
        let arith_sm = ArithSM::new(wcm.clone());

        let main_sm = MainSM::new(rom_path, wcm.clone(), rom_sm, mem_sm, binary_sm, arith_sm);

        Self { main_sm }
    }

    pub fn execute(
        &self,
        public_inputs_path: PathBuf,
        pctx: Arc<ProofCtx<F>>,
        ectx: Arc<ExecutionCtx>,
        sctx: Arc<SetupCtx>,
    ) {
        self.main_sm.execute(&public_inputs_path, pctx, ectx, sctx);
    }

    // /// Executes the MainSM state machine and processes the inputs in batches when the maximum
    // /// number of accumulated inputs is reached. The MainSM state machine uses the emulator to
    // /// execute the a program and using a callback the main state machine receives batches of
    // /// inputs generated by the emulator. The inputs are processed in batches when the maximum
    // /// number of accumulated inputs is reached
    // /// # Arguments
    // /// * `pctx` - Proof context to interact with the proof system
    // /// * `ectx` - Execution context to interact with the execution environment
    // pub fn execute2(
    //     &self,
    //     public_inputs_path: &PathBuf,
    //     pctx: Arc<ProofCtx<F>>,
    //     ectx: Arc<ExecutionCtx>,
    //     sctx: Arc<SetupCtx>,
    // ) {
    // // Create a thread pool to manage the execution of all the state machines related to the
    // // execution process
    // let pool = ThreadPoolBuilder::new().build().unwrap();

    // // Prepare the settings for the emulator
    // let emu_options = EmuOptions {
    //     elf: Some(self.zisk_rom_path.clone().display().to_string()),
    //     inputs: Some(public_inputs_path.display().to_string()),
    //     trace_steps: Some(Self::BLOCK_SIZE as u64),
    //     ..EmuOptions::default()
    // };

    // // Call emulate with these options
    // let public_inputs = {
    //     // Read inputs data from the provided inputs path
    //     let path = PathBuf::from(public_inputs_path.display().to_string());
    //     fs::read(path).expect("Could not read inputs file")
    // };

    // // During ROM processing, we gather execution data necessary for creating the AIR instances.
    // // This data is collected by the emulator and includes the minimal execution trace,
    // // along with essential state information of the processor. This ensures that the execution
    // // can be reproduced from specific points in the trace to generate the inputs for each state
    // // machine. We aim to track the starting point of execution for every N instructions
    // // across different operation types. Currently, we are only collecting data for
    // // Binary and BinaryE operations.
    // let air_main = pctx.pilout.get_air(MAIN_AIRGROUP_ID, MAIN_AIR_IDS[0]);
    // let air_binary = pctx.pilout.get_air(BINARY_AIRGROUP_ID, BINARY_AIR_IDS[0]);
    // let air_binary_e =
    //     pctx.pilout.get_air(BINARY_EXTENSION_AIRGROUP_ID, BINARY_EXTENSION_AIR_IDS[0]);

    // let mut op_sizes = [0u64; ZISK_OPERATION_TYPE_VARIANTS];
    // // The starting points for the Main is allocated using None operation
    // op_sizes[ZiskOperationType::None as usize] = air_main.num_rows() as u64;
    // op_sizes[ZiskOperationType::Binary as usize] = air_binary.num_rows() as u64;
    // op_sizes[ZiskOperationType::BinaryE as usize] = air_binary_e.num_rows() as u64;

    // pool.scope(|scope| {
    //     // FIXME: This is a temporary solution to run the emulator in parallel with the ROM SM
    //     // Spawn the ROM thread
    //     let rom_sm = self.rom_sm.clone();
    //     let zisk_rom = self.zisk_rom.clone();
    //     let pc_histogram = ZiskEmulator::process_rom_pc_histogram(
    //         &self.zisk_rom,
    //         &public_inputs,
    //         &emu_options,
    //     )
    //     .expect("MainSM::execute() failed calling ZiskEmulator::process_rom_pc_histogram()");
    //     let handle_rom = std::thread::spawn(move || rom_sm.prove(&zisk_rom, pc_histogram));

    //     // Run the emulator in parallel n times to collect execution traces
    //     // and record the execution starting points for each AIR instance
    //     timer_start_debug!(PAR_PROCESS_ROM);
    //     let (emu_traces, mut emu_slices) = ZiskEmulator::par_process_rom::<F>(
    //         &self.zisk_rom,
    //         &public_inputs,
    //         &emu_options,
    //         Self::NUM_THREADS,
    //         op_sizes,
    //     )
    //     .expect("Error during emulator execution");
    //     timer_stop_and_log_debug!(PAR_PROCESS_ROM);

    //     emu_slices.points.sort_by(|a, b| a.op_type.partial_cmp(&b.op_type).unwrap());

    //     // FIXME: This is a temporary solution to run the emulator in parallel with the ROM SM
    //     handle_rom.join().unwrap().expect("Error during ROM witness computation");

    //     let mut instances_ctx: Vec<InstanceExtensionCtx<F>> =
    //         Vec::with_capacity(emu_slices.points.len());

    //     let mut dctx = ectx.dctx.write().unwrap();
    //     for (idx, emu_slice) in emu_slices.points.iter().enumerate() {
    //         let (airgroup_id, air_id) = match emu_slice.op_type {
    //             ZiskOperationType::None => (MAIN_AIRGROUP_ID, MAIN_AIR_IDS[0]),
    //             ZiskOperationType::Binary => (BINARY_AIRGROUP_ID, BINARY_AIR_IDS[0]),
    //             ZiskOperationType::BinaryE => {
    //                 (BINARY_EXTENSION_AIRGROUP_ID, BINARY_EXTENSION_AIR_IDS[0])
    //             }
    //             _ => panic!("Invalid operation type"),
    //         };
    //         dctx.add_instance(airgroup_id, air_id, idx, 1);

    //         if dctx.is_my_instance(idx) {
    //             let (buffer, offset) =
    //                 create_prover_buffer::<F>(&ectx, &sctx, airgroup_id, air_id);
    //             instances_ctx.push(InstanceExtensionCtx::new(
    //                 buffer,
    //                 offset,
    //                 emu_slice.op_type,
    //                 emu_slice.emu_trace_start.clone(),
    //                 None,
    //             ));
    //         }
    //     }
    //     drop(dctx);

    //     instances_ctx.par_iter_mut().enumerate().for_each(|(idx, iectx)| match iectx.op_type {
    //         ZiskOperationType::None => {
    //             self.prove_main(&emu_traces, idx, iectx, &pctx);
    //         }
    //         ZiskOperationType::Binary => {
    //             self.prove_binary(&emu_traces, idx, iectx, &pctx, scope);
    //         }
    //         ZiskOperationType::BinaryE => {
    //             self.prove_binary_extension(&emu_traces, idx, iectx, &pctx, scope);
    //         }
    //         _ => panic!("Invalid operation type"),
    //     });

    //     timer_start_debug!(ADD_INSTANCES_TO_THE_REPO);
    //     for iectx in instances_ctx {
    //         if let Some(air_instance) = iectx.air_instance {
    //             pctx.air_instance_repo.add_air_instance(air_instance);
    //         }
    //     }
    //     timer_stop_and_log_debug!(ADD_INSTANCES_TO_THE_REPO);

    //     std::thread::spawn(move || {
    //         drop(emu_traces);
    //     });

    //     // self.mem_sm.unregister_predecessor(scope);
    //     self.binary_sm.unregister_predecessor(scope);
    //     // self.arith_sm.register_predecessor(scope);
    // });
    // }
}
