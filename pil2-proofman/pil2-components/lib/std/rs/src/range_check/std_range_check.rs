use core::panic;
use std::{
    fmt::Debug,
    sync::{Arc, Mutex},
};

use num_bigint::BigInt;
use p3_field::PrimeField;

use witness::WitnessComponent;
use proofman_common::{ProofCtx, SetupCtx, ModeName};
use proofman_hints::{
    get_hint_field_gc_constant_a, get_hint_field_constant, get_hint_ids_by_name, HintFieldOptions, HintFieldValue,
};

use crate::{
    extract_field_element_as_usize, get_global_hint_field_constant_as, get_hint_field_constant_as_field, AirComponent,
    Range, SpecifiedRanges, U16Air, U8Air,
};

#[derive(Debug, Eq, Hash, PartialEq, Clone)]
pub enum RangeCheckAir {
    U8Air,
    U16Air,
    SpecifiedRanges,
}

#[derive(Clone, Debug, PartialEq, Eq, Hash)]
pub enum StdRangeCheckType {
    Valid(RangeCheckAir),
    U8AirDouble,
    U16AirDouble,
}

#[derive(Clone, Debug)]
pub struct StdRangeItem<F: PrimeField> {
    rc_type: StdRangeCheckType,
    range: Range<F>,
}

pub struct StdRangeCheck<F: PrimeField> {
    pctx: Arc<ProofCtx<F>>,
    ranges: Mutex<Vec<StdRangeItem<F>>>,
    pub u8air: Option<Arc<U8Air<F>>>,
    pub u16air: Option<Arc<U16Air<F>>>,
    pub specified_ranges: Option<Arc<SpecifiedRanges<F>>>,
}

impl<F: PrimeField> StdRangeCheck<F> {
    const _MY_NAME: &'static str = "STD Range Check";

    pub fn new(pctx: Arc<ProofCtx<F>>, sctx: Arc<SetupCtx>) -> Arc<Self> {
        // Find which range check related AIRs need to be instantiated
        let u8air_hint = get_hint_ids_by_name(sctx.get_global_bin(), "u8air");
        let u16air_hint = get_hint_ids_by_name(sctx.get_global_bin(), "u16air");
        let specified_ranges_hint = get_hint_ids_by_name(sctx.get_global_bin(), "specified_ranges");

        // Instantiate the AIRs
        let u8air = create_air::<U8Air<F>, F>(pctx.clone(), sctx.clone(), &u8air_hint);
        let u16air = create_air::<U16Air<F>, F>(pctx.clone(), sctx.clone(), &u16air_hint);
        let specified_ranges = create_air::<SpecifiedRanges<F>, F>(pctx.clone(), sctx.clone(), &specified_ranges_hint);

        let std_range_check =
            Arc::new(Self { pctx: pctx.clone(), ranges: Mutex::new(Vec::new()), u8air, u16air, specified_ranges });

        // Process range check users
        if let Some(std_rc_users) = get_hint_ids_by_name(sctx.get_global_bin(), "std_rc_users").first() {
            let num_users = get_global_hint_field_constant_as::<usize, F>(sctx.clone(), *std_rc_users, "num_users");
            let airgroup_ids = get_hint_field_gc_constant_a::<F>(sctx.clone(), *std_rc_users, "airgroup_ids", false);
            let air_ids = get_hint_field_gc_constant_a::<F>(sctx.clone(), *std_rc_users, "air_ids", false);

            for i in 0..num_users {
                let airgroup_id = extract_field_element_as_usize(&airgroup_ids.values[i], "airgroup_id");
                let air_id = extract_field_element_as_usize(&air_ids.values[i], "air_id");

                // Register the ranges generated by the user
                std_range_check.register_ranges(&sctx, airgroup_id, air_id);
            }
        }

        return std_range_check;

        // Helper function to instantiate AIRs
        fn create_air<T, F: PrimeField>(pctx: Arc<ProofCtx<F>>, sctx: Arc<SetupCtx>, hints: &[u64]) -> Option<Arc<T>>
        where
            T: AirComponent<F>,
        {
            if hints.is_empty() {
                return None;
            }
            let airgroup_id = get_global_hint_field_constant_as::<usize, F>(sctx.clone(), hints[0], "airgroup_id");
            let air_id = get_global_hint_field_constant_as::<usize, F>(sctx.clone(), hints[0], "air_id");
            Some(T::new(pctx.clone(), sctx.clone(), Some(airgroup_id), Some(air_id)))
        }
    }

    fn register_ranges(&self, sctx: &SetupCtx, airgroup_id: usize, air_id: usize) {
        let setup = sctx.get_setup(airgroup_id, air_id);

        // Obtain info from the range hints
        let rc_hints = get_hint_ids_by_name(setup.p_setup.p_expressions_bin, "range_def");

        for hint in rc_hints {
            let predefined = get_hint_field_constant_as_field::<F>(
                sctx,
                airgroup_id,
                air_id,
                hint as usize,
                "predefined",
                HintFieldOptions::default(),
            );

            let min = get_hint_field_constant_as_field::<F>(
                sctx,
                airgroup_id,
                air_id,
                hint as usize,
                "min",
                HintFieldOptions::default(),
            );

            let min_neg = get_hint_field_constant_as_field::<F>(
                sctx,
                airgroup_id,
                air_id,
                hint as usize,
                "min_neg",
                HintFieldOptions::default(),
            );

            let max = get_hint_field_constant_as_field::<F>(
                sctx,
                airgroup_id,
                air_id,
                hint as usize,
                "max",
                HintFieldOptions::default(),
            );

            let max_neg = get_hint_field_constant_as_field::<F>(
                sctx,
                airgroup_id,
                air_id,
                hint as usize,
                "max_neg",
                HintFieldOptions::default(),
            );

            let HintFieldValue::String(r#type) = get_hint_field_constant::<F>(
                sctx,
                airgroup_id,
                air_id,
                hint as usize,
                "type",
                HintFieldOptions::default(),
            ) else {
                log::error!("Type hint must be a string");
                panic!();
            };

            let predefined = validate_binary_field(predefined, "Predefined");
            let min_neg = validate_binary_field(min_neg, "Min neg");
            let max_neg = validate_binary_field(max_neg, "Max neg");

            let range = Range(min, max, min_neg, max_neg, predefined);

            // If the range is already defined, skip
            let mut ranges = self.ranges.lock().unwrap();
            if ranges.iter().any(|r| r.range == range) {
                continue;
            }

            let r#type = match r#type.as_str() {
                "U8" => StdRangeCheckType::Valid(RangeCheckAir::U8Air),
                "U8Double" => StdRangeCheckType::U8AirDouble,
                "U16" => StdRangeCheckType::Valid(RangeCheckAir::U16Air),
                "U16Double" => StdRangeCheckType::U16AirDouble,
                "Specified" => StdRangeCheckType::Valid(RangeCheckAir::SpecifiedRanges),
                _ => panic!("Invalid range check type"),
            };

            let range = StdRangeItem { rc_type: r#type, range };

            // Update ranges
            ranges.push(range);
        }

        fn validate_binary_field<F: PrimeField>(value: F, field_name: &str) -> bool {
            if value.is_zero() {
                false
            } else if value.is_one() {
                true
            } else {
                log::error!("{} hint must be either 0 or 1", field_name);
                panic!();
            }
        }
    }

    pub fn get_range(&self, min: BigInt, max: BigInt, predefined: Option<bool>) -> usize {
        // Default predefined value in STD is true
        let predefined = predefined.unwrap_or(true);

        let ranges = self.ranges.lock().unwrap();
        if let Some((id, _)) =
            ranges.iter().enumerate().find(|(_, r)| r.range == (predefined, min.clone(), max.clone()))
        {
            id
        } else {
            // If the range was not computed in the setup phase, error
            let name = if predefined { "Predefined" } else { "Specified" };
            log::error!("{name} range not found: [min,max] = [{},{}]", min, max);
            panic!();
        }
    }

    pub fn assign_values(&self, value: F, multiplicity: F, id: usize) {
        let ranges = self.ranges.lock().unwrap();
        let range_item = ranges.get(id);

        if range_item.is_none() {
            log::error!("Range with id {} not found", id);
            panic!();
        }

        let range_item = range_item.unwrap();
        let range = range_item.range;

        if self.pctx.options.debug_info.std_mode.name == ModeName::Debug && !range.contains(value) {
            log::error!("Value {} is not in the range [min,max] = {}", value, range);
            panic!();
        }

        match range_item.rc_type {
            StdRangeCheckType::Valid(RangeCheckAir::U8Air) => {
                self.u8air.as_ref().unwrap().update_inputs(value, multiplicity);
            }
            StdRangeCheckType::Valid(RangeCheckAir::U16Air) => {
                self.u16air.as_ref().unwrap().update_inputs(value, multiplicity);
            }
            StdRangeCheckType::U8AirDouble => {
                self.u8air.as_ref().unwrap().update_inputs(value - range.0, multiplicity);
                self.u8air.as_ref().unwrap().update_inputs(range.1 - value, multiplicity);
            }
            StdRangeCheckType::U16AirDouble => {
                self.u16air.as_ref().unwrap().update_inputs(value - range.0, multiplicity);
                self.u16air.as_ref().unwrap().update_inputs(range.1 - value, multiplicity);
            }
            StdRangeCheckType::Valid(RangeCheckAir::SpecifiedRanges) => {
                self.specified_ranges.as_ref().unwrap().update_inputs(value, range, multiplicity);
            }
        }
    }

    pub fn drain_inputs(&self, pctx: Arc<ProofCtx<F>>, sctx: Arc<SetupCtx>) {
        if let Some(u8air) = self.u8air.as_ref() {
            u8air.drain_inputs(pctx.clone(), sctx.clone());
        }
        if let Some(u16air) = self.u16air.as_ref() {
            u16air.drain_inputs(pctx.clone(), sctx.clone());
        }
        if let Some(specified_ranges) = self.specified_ranges.as_ref() {
            specified_ranges.drain_inputs(pctx.clone(), sctx.clone());
        }
    }

    pub fn get_ranges(&self) -> Vec<(usize, usize, RangeCheckAir)> {
        let mut ranges = Vec::new();

        if let Some(u8air) = self.u8air.as_ref() {
            ranges.push((u8air.airgroup_id(), u8air.air_id(), RangeCheckAir::U8Air));
        }

        if let Some(u16air) = self.u16air.as_ref() {
            ranges.push((u16air.airgroup_id(), u16air.air_id(), RangeCheckAir::U16Air));
        }

        if let Some(specified_ranges) = self.specified_ranges.as_ref() {
            ranges.push((specified_ranges.airgroup_id(), specified_ranges.air_id(), RangeCheckAir::SpecifiedRanges));
        }

        ranges
    }
}

impl<F: PrimeField> WitnessComponent<F> for StdRangeCheck<F> {}
