require "std_constants.pil";
require "std_lookup.pil";

/*
 * Module for performing selected range checks over expressions of any degree.
 * This module provides three independent user interfaces:
 *
 * 1. **Direct Call**:
 *    Perform a range check directly with specified parameters.
 *    Example:
 *        // Check if values in `expression` fall within the range [0, 255] (U8) using a predefined range.
 *        range_check(expression, 0, 255, sel, true);
 *
 *        // Check if values in `expression` fall within the range [100, 500], without using a predefined range.
 *        range_check(expression, 100, 500, sel, false);
 *
 * 2. **Multi-Range Check**:
 *    Perform a range check across two ranges based on a range selector.
 *    Example:
 *        // Check if values in `expression` fall within [0, 255] when `range_sel = 1`,
 *        // or within [256, 512] when `range_sel = 0`.
 *        multi_range_check(expression, 0, 255, 256, 512, range_sel, sel, false);
 *
 * 3. **Dynamic Range Check**:
 *    First, obtain an ID for the range, then perform the range check using a user-defined range selector.
 *    Example:
 *        // Step 1: Obtain IDs for the desired ranges.
 *        int id_range_24 = range_check_id(0, 2**24-1);  // Range [0, 2^24-1]
 *        int id_range_16 = range_check_id(0, 2**16-1);  // Range [0, 2^16-1]
 *        int id_range_15 = range_check_id(0, 2**15-1);  // Range [0, 2^15-1]
 *
 *        // Step 2: Perform range checks dynamically using a user-defined range selector.
 *        col witness sel_8, sel_16, sel_32;
 *        range_check_dynamic(expression, id_range_24 * sel_8 + id_range_16 * sel_16 + id_range_15 * sel_32);
 *
 * **Parameter Details**:
 * - `predefined`: A flag indicating whether predefined ranges should be used.
 *   The predefined ranges currently supported are:
 *      - U8: [0..255]
 *      - U16: [0..65535]
 *
 * **Implementation Notes**:
 * - All range checks are internally reduced to a lookup check, implemented using the logup protocol.
 *   For more details, refer to: https://eprint.iacr.org/2022/1530.
 * - This protocol is optimized for repeated lookups within the same range rather than across different ranges.
 * - To improve performance, the module attempts to "absorb" custom ranges into predefined ranges whenever possible.
 */

const int MAX_RANGE_LEN = (PRIME - 1) / 2;

const int U8AIR_OPID = 100;
const int U16AIR_OPID = 101;

int last_assigned_opid = 101;
private function next_available_opid(): int {
    last_assigned_opid++;
    return last_assigned_opid;
}

private function get_opid(const int min, const int max, const int predefined): int {
    if (predefined && min >= 0) {
        if (max <= MASK_8) {
            return U8AIR_OPID;
        } else if (max <= MASK_16) {
            return U16AIR_OPID;
        }
    }

    return next_available_opid();
}

airtemplate U8Air(const int N = 2**8) {
    if (N != 2**8) {
        error(`The number of rows N should be 2**8 to use the predefined range U8, got N=${N} instead`);
    }

    // save the airgroup id and air id of the table for latter use
    proof.std.u8.airgroup_id = AIRGROUP_ID;
    proof.std.u8.air_id = AIR_ID;

    col witness mul;

    @u8air{reference: mul};

    col fixed U8 = [0..MASK_8];
    lookup_proves(U8AIR_OPID, [U8], mul, PIOP_NAME_RANGE_CHECK);
}

airtemplate U16Air(const int N = 2**16) {
    if (N != 2**16) {
        error(`The number of rows N should be 2**16 to use the predefined range U16, got N=${N} instead`);
    }

    // save the airgroup id and air id of the table for latter use
    proof.std.u16.airgroup_id = AIRGROUP_ID;
    proof.std.u16.air_id = AIR_ID;

    col witness mul;

    @u16air{reference: mul};

    col fixed U16 = [0..MASK_16];
    lookup_proves(U16AIR_OPID, [U16], mul, PIOP_NAME_RANGE_CHECK);
}

airtemplate SpecifiedRanges(const int N, const int opids[], const int opids_count, const int predefineds[], const int mins[], const int maxs[]) {
    // save the airgroup id and air id of the table for latter use
    proof.std.specified.airgroup_id = AIRGROUP_ID;
    proof.std.specified.air_id = AIR_ID;

    @specified_ranges{num_rows: N};

    col witness mul[opids_count];

    for (int j = 0; j < opids_count; j++) {
        int opid = opids[j];
        int predefined = predefineds[j];
        int min = mins[j];
        int max = maxs[j];

        @specified_ranges{reference: mul[j], predefined: predefined, min: min, max: max, min_neg: min < 0, max_neg: max < 0};

        if (N < max - min + 1) {
            error(`The range [min,max]=[${min},${max}] is too big, the maximum range length is ${N}`);
        }

        col fixed RANGE = [min..max-1,max...];
        lookup_proves(opid, [RANGE], mul[j], PIOP_NAME_RANGE_CHECK);
    }
}

/**
 * Performs a range check on a expression within a specified range.
 *
 * @param expression The expression to be range checked.
 * @param min        The minimum value of the range (inclusive).
 * @param max        The maximum value of the range (inclusive).
 * @param sel        A selector specifying which rows are subject to the range check.
 * @param predefined A flag indicating whether to use predefined ranges.
 *
 * @note If `predefined` is true, the provided range [min, max] may be overridden
 *       by one of the predefined ranges, such as:
 *       - U8: [0, 255]
 *       - U16: [0, 65535]
 */
function range_check(const expr expression, const int min, const int max, const expr sel = 1, const int predefined = 1) {
    range_validator(min, max);

    if (min < 0) {
        println(`The provided min=${min} is negative. Falling back to specified range...`);
    } else if (max > MASK_16) {
        println(`The provided max=${max} is greater than the maximum allowed: ${MASK_16}. Falling back to specified range...`);
    }

    const int opid = opid_process(min, max, predefined);

    // Check if the range can be absorbed into the predefined ranges
    const int absorb = predefined && min >= 0 && max <= MASK_16;

    // Define the assume
    if (absorb) {
        if (min == 0 && (max == MASK_8 || max == MASK_16)) {
            const int is_u8 = max == MASK_8 ? 1 : 0;

            @range_def{predefined: predefined, min: min, max: max, min_neg: min < 0, max_neg: max < 0, type: is_u8 ? "U8" : "U16"}; 

            airgroup.std.rc.u8_used = airgroup.std.rc.u8_used || is_u8;
            airgroup.std.rc.u16_used = airgroup.std.rc.u16_used || 1-is_u8;
            lookup_assumes(opid, [expression], sel, PIOP_NAME_RANGE_CHECK);
        } else {
            // Here, we need to reuse to some of the default ranges depending
            // on the values of min and max
            if (max <= MASK_8) {
                // Here, the range is of the form [a,b], with a >= 0 and b <= MASK_8, except for the range [0,MASK_8]

                @range_def{predefined: predefined, min: min, max: max, min_neg: min < 0, max_neg: max < 0, type: "U8Double"};

                // reuse U8
                airgroup.std.rc.u8_used = 1;

                // expression is in [a,b] iff expression-min is in [0,MASK_8] and max-expression is in [0,MASK_8]
                lookup_assumes(opid, [expression - min], sel, PIOP_NAME_RANGE_CHECK);
                lookup_assumes(opid, [max - expression], sel, PIOP_NAME_RANGE_CHECK);
            } else if (max <= MASK_16) {
                // Here, the range is of the form [a,b], with a >= 0 and MASK_8 < b <= MASK_16, except for the range [0,MASK_16]

                @range_def{predefined: predefined, min: min, max: max, min_neg: min < 0, max_neg: max < 0, type: "U16Double"};

                // reuse U16
                airgroup.std.rc.u16_used = 1;

                // expression is in [a,b] iff expression-min is in [0,MASK_16] and max-expression is in [0,MASK_16]
                lookup_assumes(opid, [expression - min], sel, PIOP_NAME_RANGE_CHECK);
                lookup_assumes(opid, [max - expression], sel, PIOP_NAME_RANGE_CHECK);
            }
        }
    } else {
        @range_def{predefined: predefined, min: min, max: max, min_neg: min < 0, max_neg: max < 0, type: "Specified"};

        lookup_assumes(opid, [expression], sel, PIOP_NAME_RANGE_CHECK);
    }

    // Define the prove
    define_proves(absorb);
}

/**
 * Performs a range check on a group of expressions within a specified range.
 *
 * @param expressions The expressions to be range checked.
 * @param min         The minimum value of the range (inclusive).
 * @param max         The maximum value of the range (inclusive).
 * @param sel         The selectors specifying which rows are subject to the range check for each expression.
 * @param predefined  A flag indicating whether to use predefined ranges.
 *
 * @note If `predefined` is true, the provided range [min, max] may be overridden
 *       by one of the predefined ranges, such as:
 *       - U8: [0, 255]
 *       - U16: [0, 65535]
 */
function range_check_group(const expr expressions[], const int min, const int max, const expr sels[], const int predefined = 1) {
    const int len = length(expressions);
    if (len != length(sels)) {
        error(`The length of expressions (${len}) and sels (${length(sels)}) should be the same`);
    }

    for (int i = 0; i < len; i++) {
        range_check(expressions[i], min, max, sels[i], predefined);
    }
}

/**
 * Performs a range check on an expression within one of two specified ranges, 
 * determined by a range selector.
 *
 * - If `range_sel = 1`, the range [min1, max1] is checked.
 * - Otherwise, the range [min2, max2] is checked.
 *
 * @param expression The expression to be range checked.
 * @param min1       The minimum value of the first range (inclusive).
 * @param max1       The maximum value of the first range (inclusive).
 * @param min2       The minimum value of the second range (inclusive).
 * @param max2       The maximum value of the second range (inclusive).
 * @param range_sel  A selector that determines which range to apply for the check.
 * @param sel        A selector specifying which rows are subject to the range check.
 * @param predefined A flag indicating whether to use predefined ranges.
 *
 * @note If `predefined` is true, the provided range [min, max] may be overridden
 *       by one of the predefined ranges, such as:
 *       - U8: [0, 255]
 *       - U16: [0, 65535]
 */
// TODO: Generalize to more than 2 ranges
function multi_range_check(const expr expression, const int min1, const int max1, const int min2, const int max2, 
                           const expr range_sel = 1, const expr sel = 1, const int predefined = 0): int {
    if (predefined) {
        error(`WIP: Multi range check cannot be predefined`);
    }

    if (min1 == min2 && max1 == max2) {
        error(`The ranges defined in the multi range check are the same: [${min1},${max1}]`);
    }

    range_validator(min1, max1);
    range_validator(min2, max2);

    @range_def{predefined: predefined, min: min1, max: max1, min_neg: min1 < 0, max_neg: max1 < 0, type: "Specified"};
    @range_def{predefined: predefined, min: min2, max: max2, min_neg: min2 < 0, max_neg: max2 < 0, type: "Specified"};

    const int opid1 = opid_process(min1, max1, predefined);
    const int opid2 = opid_process(min2, max2, predefined);

    // Define the assume
    lookup_assumes_dynamic([opid1, opid2], range_sel*(opid1-opid2) + opid2, [expression], sel, PIOP_NAME_RANGE_CHECK);

    // Define the prove
    define_proves(absorb: 0);

    // Note: This solution improves the naive solution:
    //   · range_check(expression, min1, max1, 0, sel*range_sel).
    //   · range_check(expression, min2, max2, 0, sel*(1-range_sel)).
    // by just performing 1 assume and 2 proves instead
    //
    // Q: Can I do it with 1 assume and 1 prove? E.g.:
    // lookup_assumes_dynamic([opid1,opid2], range_sel*(opid1-opid2) - opid2, [expression], sel, PIOP_NAME_RANGE_CHECK);
    // lookup_proves(opid, [min1..max1-1,max1...]U[min2..max2-1,max2...], mul, PIOP_NAME_RANGE_CHECK);
}

/**
 * Obtains an ID for a range, which can be used to perform a dynamic range check.
 *
 * @param min        The minimum value of the range (inclusive).
 * @param max        The maximum value of the range (inclusive).
 * @param predefined A flag indicating whether to use predefined ranges.
 *
 * @return The ID of the range check.
 */
function range_check_id(const int min, const int max, const int predefined = 0): int {
    if (predefined) {
        error(`WIP: Range check id cannot be predefined`);
    }

    range_validator(min, max);

    @range_def{predefined: predefined, min: min, max: max, min_neg: min < 0, max_neg: max < 0, type: "Specified"};

    container air.std.rcid alias rcid {
        int opids_count_id = 0;
        int opids_id[100];
        int called = 0;
    }

    const int opid = opid_process(min, max, predefined);

    // Save the opid for use in the dynamic range check
    rcid.opids_id[rcid.opids_count_id] = opid;
    rcid.opids_count_id++;

    // At the end of the air, check if dynamic range checks were called
    on final air check_dynamic_called();

    return opid;
}

/**
 * Performs a dynamic range check on an expression using a user-defined range selector.
 *
 * @param expression The expression to be range checked.
 * @param range_sel  The range selector that determines which range to apply for the check.
 * @param sel        A selector specifying which rows are subject to the range check.
 */
function range_check_dynamic(const expr expression, const expr range_sel, const expr sel = 1) {
    use air.std.rcid;

    // Mark the dynamic range check as called
    called = 1;

    int opids[opids_count_id];
    for (int i = 0; i < opids_count_id; i++) {
        opids[i] = opids_id[i];
    }

    // Define the assume
    lookup_assumes_dynamic(opids, range_sel, [expression], sel, PIOP_NAME_RANGE_CHECK);

    // Define the prove
    define_proves(absorb: 0);
}

private function check_dynamic_called() {
    use air.std.rcid;
    if (!called) {
        error(`Dynamic range check was not called`);
    }
}

private function range_validator(const int min, const int max) {
    if (min > max) {
        error(`min = ${min} cannot be greater than max = ${max}`);
    } else if (min == max) {
        error(`Min and max are the same, you should use a single value check instead: expression === ${min}`);
    } else if (max - min + 1 < 8) { // The 8 was chosen comparing the cost of logup vs the cost of a multiple value check
        const int diff = max - min + 1;

        string diff_str = `(expression - ${min})`;
        for (int i = 1; i < diff; i++) {
            diff_str = diff_str + `·(expression - ${min + i})`;
        }

        println(`The range [${min}..${max}] is too small, consider using a multiple value check instead: ${diff_str} === 0`);
    } else if (max - min + 1 > MAX_RANGE_LEN) {
        error(`The range [${min}..${max}] is too big, the maximum range length is (PRIME - 1) / 2 = ${MAX_RANGE_LEN}`);
    } else if (max >= PRIME) {
        error(`The maximum value of the range cannot be greater than the field order ${PRIME}`);
    } else if (min <= -PRIME) {
        error(`The minimum value of the range cannot be less than the negative field order ${-PRIME}`);
    }
}

private function opid_process(const int min, const int max, const int predefined): int {
    container proof.std.rc alias rcproof {
        // Number of times U8, U16 and specified ranges air are used
        int num_u8_airgroup = 0;
        int num_u16_airgroup = 0;
        int num_spec_airgroup = 0;

        // Last airgroup id that uses U8, U16 and specified ranges air
        int max_u8_airgroup_id = 0;
        int max_u16_airgroup_id = 0;
        int max_spec_airgroup_id = 0;

        // N to be used in the specified ranges air
        int specified_N = 0;

        // FIX: dynamic arrays not ready
        int opids_count = 0;
        int opids[100];
        int predefineds[100];
        int mins[100];
        int maxs[100];

        // For global hints
        int air_count = 0;
        int airgroup_ids[100];
        int air_ids[100];
    }

    container airgroup.std.rc {
        // To mark if the U8 and U16 airs are used within the airgroup
        int u8_used = 0;
        int u16_used = 0;
    }

    // Store the airgroup and air ids for global hints if it appears the first time
    int found = 0;
    for (int i = 0; i < rcproof.air_count; i++) {
        if (rcproof.airgroup_ids[i] == AIRGROUP_ID && rcproof.air_ids[i] == AIR_ID) {
            found = 1;
            break;
        }
    }

    if (!found) {
        rcproof.airgroup_ids[rcproof.air_count] = AIRGROUP_ID;
        rcproof.air_ids[rcproof.air_count] = AIR_ID;
        rcproof.air_count++;
    }

    // Generate global hints
    on final proof rc_issue_global_hints(); 

    // If the range has already been introduced, we reuse the same opid
    for (int i = 0; i < rcproof.opids_count; i++) {
        if (predefined == rcproof.predefineds[i] && min == rcproof.mins[i] && max == rcproof.maxs[i]) {
            return rcproof.opids[i];
        }
    }

    // Otherwise, we get the corresponding opid
    const int opid = get_opid(min, max, predefined);

    // Exit if the range does not belong to the specified ranges air
    if (opid <= U16AIR_OPID) {
        return opid;
    }

    // Save range data for later use in the specified ranges air
    rcproof.predefineds[rcproof.opids_count] = predefined;
    rcproof.mins[rcproof.opids_count] = min;
    rcproof.maxs[rcproof.opids_count] = max;
    rcproof.opids[rcproof.opids_count] = opid;
    rcproof.opids_count++;

    // if the opid is not predefined and the range is bigger than the current specified_N, we update it
    if (opid > U16AIR_OPID && max - min > rcproof.specified_N) {
        rcproof.specified_N = max - min;
    }

    return opid;
}

private function define_proves(const int absorb) {
    use proof.std.rc;

    if (absorb) {
        // If the U8 was used, update the max airgroup id
        if (airgroup.std.rc.u8_used) {
            if (max_u8_airgroup_id < AIRGROUP_ID) {
                max_u8_airgroup_id = AIRGROUP_ID;
            }
        }

        // If the U16 was used, update the max airgroup id
        if (airgroup.std.rc.u16_used) {
            if (proof.std.rc.max_u16_airgroup_id < AIRGROUP_ID) {
                proof.std.rc.max_u16_airgroup_id = AIRGROUP_ID;
            }
        }

        on final airgroup declarePreRangeAir();
        on final proof createPreMetadata();
    } else {
        // If the specified range is used, update the max airgroup id
        if (max_spec_airgroup_id < AIRGROUP_ID) {
            max_spec_airgroup_id = AIRGROUP_ID;
        }

        on final airgroup declareRangeAir();
        on final proof createMetadata();
    }
}

private function declarePreRangeAir() {
    use proof.std.rc;

    // If the U8 was used in the airgroup, update the number of U8 airgroups
    if (airgroup.std.rc.u8_used) {
        num_u8_airgroup++;
    }

    // If the U16 was used in the airgroup, update the number of U16 airgroups
    if (airgroup.std.rc.u16_used) {
        num_u16_airgroup++;
    }

    // The U8 and U16 airs are only needed once, so we wait for the last airgroup that uses them
    if (AIRGROUP_ID != max_u8_airgroup_id && AIRGROUP_ID != max_u16_airgroup_id) {
        return;
    }

    if (AIRGROUP_ID == max_u8_airgroup_id && num_u8_airgroup > 0) {
        // container used to store the airgroup id and air id of the table
        container proof.std.u8 {
            int airgroup_id = 0;
            int air_id = 0;
        }

        if (num_u8_airgroup == 1){
            // If the U8Air is needed only once, we instantiate it in the (single) callable airgroup
            U8Air();
        } else {
            // If the U8Air is needed more than once, we instantiate it in its own airgroup
            airgroup U8Air {
                U8Air();
            }
        }
    }

    if (AIRGROUP_ID == max_u16_airgroup_id && num_u16_airgroup > 0) {
        container proof.std.u16 {
            int airgroup_id = 0;
            int air_id = 0;
        }

        if (num_u16_airgroup == 1){
            // If the U16Air is needed only once, we instantiate it in the (single) callable airgroup
            U16Air();
        } else {
            // If the U16Air is needed more than once, we instantiate it in its own airgroup
            airgroup U16Air {
                U16Air();
            }
        }
    }
}

private function declareRangeAir() {
    container proof.std.specified {
        int airgroup_id = 0;
        int air_id = 0;
    }

    use proof.std.rc;

    // Update the number of specified ranges airgroups
    num_spec_airgroup++;

    // The specified ranges air is only needed once, so we wait for the last airgroup that uses them
    if (AIRGROUP_ID != max_spec_airgroup_id) {
        return;
    }

    const int next_pow2 = 2**(log2(specified_N));

    if (num_spec_airgroup == 1) {
        // If the SpecifiedRanges is needed only once, we instantiate it in the (single) callable airgroup
        SpecifiedRanges(next_pow2, opids, opids_count, predefineds, mins, maxs);
    } else {
        // If the SpecifiedRanges is needed more than once, we instantiate it in its own airgroup
        airgroup SpecifiedRanges {
            SpecifiedRanges(next_pow2, opids, opids_count, predefineds, mins, maxs);
        }
    }
}

private function createPreMetadata() {
    if (proof.std.rc.num_u8_airgroup > 0) {
        @u8air{airgroup_id: proof.std.u8.airgroup_id, air_id: proof.std.u8.air_id};
    }

    if (proof.std.rc.num_u16_airgroup > 0) {
        @u16air{airgroup_id: proof.std.u16.airgroup_id, air_id: proof.std.u16.air_id};
    }
}

private function createMetadata() {
    @specified_ranges{airgroup_id: proof.std.specified.airgroup_id, air_id: proof.std.specified.air_id};
}

private function rc_issue_global_hints() {
    use proof.std.rc;
    @std_rc_users{num_users: air_count, airgroup_ids: airgroup_ids, air_ids: air_ids};
}