//! Zisk ROM
//!
//! # ROM data
//!
//! The Zisk ROM contains the result of parsing a RISC-V ELF program file data, and then keeping the
//! data that is required to execute any input data against this program using the Zisk processor.
//! This information consists on the following data:
//!
//! ## Zisk instructions
//!
//! * Created by transpiling the RISC-V instructions
//! * Every RISC-V instruction can generate a different number of Zisk instructions: 1 (in most of
//!   the cases), 2, 3 or 4 (e.g. in instruction containing some atomic operations).
//! * For this reason, Zisk instructions addresses are normally spaced 4 units (e.g. 4096, 4100,
//!   4104...) leaving room for up to 3 additional Zisk instructions if needed to fulfill the
//!   original RISC-V instruction they represent.
//! * This way, RISC-V jumps can conveniently be mapped to Zisk jumps by multiplying their relative
//!   offsets by 4.
//! * The Zisk instructions are stored in a map using the pc as the key
//!
//! ## Read-only (RO) data
//!
//! * RISC-V programs can contain some data that is required to execute the program, e.g. constants.
//! * There can be several sections of RO memory-mapped data in the same RISC-V program, so we need
//!   to store a list of them as part of the ROM.
//! * There can be none, one, or several.
//!
//! # Fetching instructions
//!
//! * During the Zisk program execution, the Zisk Emulator must fetch the Zisk instruction
//!   corresponding to the current pc for every execution step.
//! * This fetch can be expensive in terms of computational time if done directly using the map.
//! * For this reason, the original map of instructions is split into 3 different containers that
//!   allow to speed-up the process of finding the Zisk instruction that matches a specific pc
//!   addresss.
//! * The logic of this fetch procedure can be seen in the method `get_instruction()`.  This method
//!   searches for the Zisk instruction in 3 different containers:
//!   * If the address is >= `ROM_ADDR`, there can be 2 cases:
//!     * If the address is alligned to 4 bytes, then get it from the vector `rom_instructions`,
//!       using as index `(pc-ROM_ADDR)/4`
//!     * If the address is not allgined, then get it from the vector `rom_na_instructions`, using
//!       as index `(pc-ROM_ADDR)`
//!   * If the address is < ROM_ADDR, then get it from the vector `rom_entry_instructions`, using as
//!     index `(pc-ROM_ENTRY)/4`
use std::collections::HashMap;

use fields::PrimeField64;
use zisk_pil::MainTraceRow;

use crate::{ZiskInst, ZiskInstBuilder, ROM_ADDR, ROM_ENTRY};

// #[cfg(feature = "sp")]
// use crate::SRC_SP;

/// RO (read-only) data structure.
///
/// This structure contains the data generated by the ELF program compiler and that are part of
/// the program itself, unlike the input data, which can be different for every program execution.
#[derive(Debug, Default, Clone)]
pub struct RoData {
    /// Address of the RO data in the program address space
    pub from: u64,

    /// Size of the RO data
    pub length: usize,

    /// Vector of bytes containing the data
    pub data: Vec<u8>,
}

/// RO data implementation
impl RoData {
    /// Creates a new RoData struct with the provided data
    pub fn new(from: u64, length: usize, data: Vec<u8>) -> RoData {
        RoData { from, length, data }
    }
}

/// ZisK ROM structure, including a map address to ZisK instruction
#[derive(Default, Debug, Clone)]
pub struct ZiskRom {
    /// Address to be used to build the next instruction (and to be increased afterwards)
    pub next_init_inst_addr: u64,

    /// Map of instructions that are part of the ROM; the key is the ROM address (pc)
    /// This map contains the instructions that are part of the program, i.e. address >= ROM_ADDR
    pub insts: HashMap<u64, ZiskInstBuilder>,

    /// List of RO sections as found in the ELF file
    pub ro_data: Vec<RoData>,

    // The following vectors are to store subsets of the ROM instructions in order to improve the
    // program execution performance while fetching the instruction for the current step pc
    // address
    /// Vector of ROM instructions with address < ROM_ADDR
    pub rom_entry_instructions: Vec<ZiskInst>,

    /// ROM instructions with an address that is alligned to 4 bytes
    pub rom_instructions: Vec<ZiskInst>,

    /// Offset of the non-alligned instructions, to be subtracted to the address when accessing the
    /// corresponding vector
    pub offset_rom_na_unstructions: u64,

    /// ROM instructions with an address that is not alligned to 4 bytes
    pub rom_na_instructions: Vec<ZiskInst>,

    /// Maximum rom entry PC
    pub max_bios_pc: u64,

    /// Maximum rom instruction PC
    pub max_program_pc: u64,

    /// List of instruction program counter (address) in incremental order:
    /// 0x1000, 0x1004, ..., 0x80000000, 0x80000004, ...
    pub sorted_pc_list: Vec<u64>,
}

/// ZisK ROM implementation
impl ZiskRom {
    /// Gets the ROM instruction corresponding to the provided pc address.
    /// Depending on the range and allignment of the address, the function searches for it in the
    /// corresponding vector.
    #[inline(always)]
    pub fn get_instruction(&self, pc: u64) -> &ZiskInst {
        // If the address is a program address...
        if pc >= ROM_ADDR {
            // If the address is alligned, take it from the proper vector
            if pc & 0b11 == 0 {
                // pc is aligned to a 4-byte boundary
                let rom_index = ((pc - ROM_ADDR) >> 2) as usize;
                if rom_index >= self.rom_instructions.len() {
                    panic!(
                        "ZiskRom::get_instruction() pc=0x{0:X} ({0}) is out of range rom_instructions (rom_index:{1:} >= {2:})",
                        pc,
                        rom_index,
                        self.rom_instructions.len()
                    );
                }
                &self.rom_instructions[rom_index]
                // Otherwise, take it from the non alligned vector, using the the difference of the pc
                // vs. the offset as the index
            } else {
                // pc is not aligned to a 4-byte boundary
                let rom_index = (pc - self.offset_rom_na_unstructions) as usize;
                if rom_index >= self.rom_na_instructions.len() {
                    panic!(
                        "ZiskRom::get_instruction() pc={} is out of range rom_na_instructions (rom_index:{} >= {})",
                        pc,
                        rom_index,
                        self.rom_na_instructions.len()
                    );
                }
                &self.rom_na_instructions[rom_index]
            }
        } else if pc >= ROM_ENTRY {
            // pc is in the ROM_ENTRY range (always alligned)
            &self.rom_entry_instructions[((pc - ROM_ENTRY) >> 2) as usize]
        } else {
            panic!("ZiskRom::get_instruction() pc={pc} is out of range");
        }
    }

    /// Gets the ROM instruction corresponding to the provided pc address, as a mutable reference.
    /// Depending on the range and allignment of the address, the function searches for it in the
    /// corresponding vector.
    #[inline(always)]
    pub fn get_mut_instruction(&mut self, pc: u64) -> &mut ZiskInst {
        // If the address is a program address...
        if pc >= ROM_ADDR {
            // If the address is alligned, take it from the proper vector
            if pc & 0b11 == 0 {
                // pc is aligned to a 4-byte boundary
                let rom_index = ((pc - ROM_ADDR) >> 2) as usize;
                if rom_index >= self.rom_instructions.len() {
                    panic!(
                        "ZiskRom::get_mut_instruction() pc=0x{0:X} ({0}) is out of range rom_instructions (rom_index:{1:} >= {2:})",
                        pc,
                        rom_index,
                        self.rom_instructions.len()
                    );
                }
                &mut self.rom_instructions[rom_index]
                // Otherwise, take it from the non alligned vector, using the the difference of the pc
                // vs. the offset as the index
            } else {
                // pc is not aligned to a 4-byte boundary
                let rom_index = (pc - self.offset_rom_na_unstructions) as usize;
                if rom_index >= self.rom_na_instructions.len() {
                    panic!(
                        "ZiskRom::get_mut_instruction() pc={} is out of range rom_na_instructions (rom_index:{} >= {})",
                        pc,
                        rom_index,
                        self.rom_na_instructions.len()
                    );
                }
                &mut self.rom_na_instructions[rom_index]
            }
        } else if pc >= ROM_ENTRY {
            // pc is in the ROM_ENTRY range (always alligned)
            &mut self.rom_entry_instructions[((pc - ROM_ENTRY) >> 2) as usize]
        } else {
            panic!("ZiskRom::get_mut_instruction() pc={pc} is out of range");
        }
    }

    /// Saves ZisK rom into an i86-64 assembly data string
    pub fn build_constant_trace<F: PrimeField64>(&self) -> Vec<MainTraceRow<F>> {
        let mut result: Vec<MainTraceRow<F>> = Vec::with_capacity(self.sorted_pc_list.len());
        #[allow(clippy::uninit_vec)]
        unsafe {
            result.set_len(self.sorted_pc_list.len())
        };

        // For all program addresses in the vector
        for (i, pc) in self.sorted_pc_list.iter().enumerate() {
            let instruction = &self.get_instruction(*pc);
            instruction.write_constant_trace(result.get_mut(i).unwrap());
        }
        result
    }
}
