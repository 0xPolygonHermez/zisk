//! Zisk ROM
//!
//! # ROM data
//!
//! The Zisk ROM contains the result of parsing a RISC-V ELF program file data, and then keeping the
//! data that is required to execute any input data against this program using the Zisk processor.  
//! This information consists on the following data:
//!
//! ## Zisk instructions
//!
//! * Created by transpiling the RISC-V instructions
//! * Every RISC-V instruction can generate a different number of Zisk instructions: 1 (in most of
//!   the cases), 2, 3 or 4 (e.g. in instruction containing some atomic operations).
//! * For this reason, Zisk instructions addresses are normally spaced 4 units (e.g. 4096, 4100,
//!   4104...) leaving room for up to 3 additional Zisk instructions if needed to fulfill the
//!   original RISC-V instruction they represent.
//! * This way, RISC-V jumps can conveniently be mapped to Zisk jumps by multiplying their relative
//!   offsets by 4.
//! * The Zisk instructions are stored in a map using the pc as the key
//!
//! ## Read-only (RO) data
//!
//! * RISC-V programs can contain some data that is required to execute the program, e.g. constants.
//! * There can be several sections of RO memory-mapped data in the same RISC-V program, so we need
//!   to store a list of them as part of the ROM.
//! * There can be none, one, or several.
//!
//! # Fetching instructions
//!
//! * During the Zisk program execution, the Zisk Emulator must fetch the Zisk instruction
//!   corresponding to the current pc for every execution step.
//! * This fetch can be expensive in terms of computational time if done directly using the map.
//! * For this reason, the original map of instructions is split into 3 different containers that
//!   allow to speed-up the process of finding the Zisk instruction that matches a specific pc
//!   addresss.
//! * The logic of this fetch procedure can be seen in the method `get_instruction()`.  This method
//!   searches for the Zisk instruction in 3 different containers:
//!   * If the address is >= `ROM_ADDR`, there can be 2 cases:
//!     * If the address is alligned to 4 bytes, then get it from the vector `rom_instructions`,
//!       using as index `(pc-ROM_ADDR)/4`
//!     * If the address is not allgined, then get it from the vector `rom_na_instructions`, using
//!       as index `(pc-ROM_ADDR)`
//!   * If the address is < ROM_ADDR, then get it from the vector `rom_entry_instructions`, using as
//!     index `(pc-ROM_ENTRY)/4`
use std::collections::HashMap;

use crate::{
    zisk_ops::ZiskOp, ZiskInst, ZiskInstBuilder, M64, ROM_ADDR, ROM_ENTRY, SRC_C, SRC_IMM, SRC_IND,
    SRC_MEM, SRC_STEP, STORE_IND, STORE_MEM, STORE_NONE,
};

const REG_A: &str = "rbx";
const REG_A_W: &str = "ebx";
const REG_A_H: &str = "bx";
const REG_A_B: &str = "bl";

const REG_B: &str = "rax";
const REG_B_W: &str = "eax";
const REG_B_H: &str = "ax";
const REG_B_B: &str = "al";

const REG_C: &str = "rcx";
const REG_C_W: &str = "ecx";
const REG_C_H: &str = "cx";
const REG_C_B: &str = "cl";

const REG_FLAG: &str = "rdx";

const REG_STEP: &str = "r11";
const REG_SP: &str = "r10";
const REG_PC: &str = "r9";
const REG_VALUE: &str = "r12";
const REG_ADDRESS: &str = "r13";

// #[cfg(feature = "sp")]
// use crate::SRC_SP;

/// RO (read-only) data structure.  
///    
/// This structure contains the data generated by the ELF program compiler and that are part of
/// the program itself, unlike the input data, which can be different for every program execution.
#[derive(Debug, Default, Clone)]
pub struct RoData {
    /// Address of the RO data in the program address space
    pub from: u64,

    /// Size of the RO data
    pub length: usize,

    /// Vector of bytes containing the data
    pub data: Vec<u8>,
}

/// RO data implementation
impl RoData {
    /// Creates a new RoData struct with the provided data
    pub fn new(from: u64, length: usize, data: Vec<u8>) -> RoData {
        RoData { from, length, data }
    }
}

/// ZisK ROM structure, including a map address to ZisK instruction
#[derive(Default, Debug, Clone)]
pub struct ZiskRom {
    /// Address to be used to build the next instruction (and to be increased afterwards)
    pub next_init_inst_addr: u64,

    /// Map of instructions that are part of the ROM; the key is the ROM address (pc)
    /// This map contains the instructions that are part of the program, i.e. address >= ROM_ADDR
    pub insts: HashMap<u64, ZiskInstBuilder>,

    /// List of RO sections as found in the ELF file
    pub ro_data: Vec<RoData>,

    // The following vectors are to store subsets of the ROM instructions in order to improve the
    // program execution performance while fetching the instruction for the current step pc
    // address
    /// Vector of ROM instructions with address < ROM_ADDR
    pub rom_entry_instructions: Vec<ZiskInst>,

    /// ROM instructions with an address that is alligned to 4 bytes
    pub rom_instructions: Vec<ZiskInst>,

    /// Offset of the non-alligned instructions, to be subtracted to the address when accessing the
    /// corresponding vector
    pub offset_rom_na_unstructions: u64,

    /// ROM instructions with an address that is not alligned to 4 bytes
    pub rom_na_instructions: Vec<ZiskInst>,
}

#[derive(Default, Debug, Clone)]
pub struct ZiskAsmContext {
    pc: u64,
    next_pc: u64,
    flag_is_always_one: bool,
    flag_is_always_zero: bool,
    c_is_always_zero: bool,
    jump_to_dynamic_pc: bool,
    jump_to_static_pc: String,
}

/// ZisK ROM implementation
impl ZiskRom {
    /// Gets the ROM instruction corresponding to the provided pc address.
    /// Depending on the range and allignment of the address, the function searches for it in the
    /// corresponding vector.
    #[inline(always)]
    pub fn get_instruction(&self, pc: u64) -> &ZiskInst {
        // If the address is a program address...
        if pc >= ROM_ADDR {
            // If the address is alligned, take it from the proper vector
            if pc & 0b11 == 0 {
                // pc is aligned to a 4-byte boundary
                &self.rom_instructions[((pc - ROM_ADDR) >> 2) as usize]
            // Otherwise, take it from the non alligned vector, using the the difference of the pc
            // vs. the offset as the index
            } else {
                // pc is not aligned to a 4-byte boundary
                &self.rom_na_instructions[(pc - self.offset_rom_na_unstructions) as usize]
            }
        } else if pc >= ROM_ENTRY {
            // pc is in the ROM_ENTRY range (always alligned)
            &self.rom_entry_instructions[((pc - ROM_ENTRY) >> 2) as usize]
        } else {
            panic!("ZiskRom::get_instruction() pc={} is out of range", pc);
        }
    }

    /// Saves ZisK rom into a JSON object
    pub fn save_to_json(&self, j: &mut json::JsonValue) {
        // Clear output data, just in case
        j.clear();

        // Save next init inst addr
        j["nextInitInstAddr"] = self.next_init_inst_addr.into();

        // Create the insts JSON object
        j["insts"] = json::JsonValue::new_object();

        // Save instructions program addresses into a vector
        let mut keys: Vec<u64> = Vec::new();
        for key in self.insts.keys() {
            keys.push(*key);
        }

        // Sort the vector
        keys.sort();

        // For all program addresses in the vector, create a new JSON object describing the ZisK
        // instruction
        for key in keys {
            let i = &self.insts[&key].i;
            let mut inst_json = json::JsonValue::new_object();
            inst_json["paddr"] = i.paddr.into();
            if i.store_ra {
                inst_json["store_ra"] = i.store_ra.into();
            }
            // #[cfg(feature = "sp")]
            // if i.store_use_sp {
            //     inst_json["store_use_sp"] = i.store_use_sp.into();
            // }
            inst_json["store"] = i.store.into();
            if i.store_offset != 0 {
                inst_json["store_offset"] = i.store_offset.into();
            }
            if i.set_pc {
                inst_json["set_pc"] = i.set_pc.into();
            }
            // #[cfg(feature = "sp")]
            // if i.set_sp {
            //     inst_json["set_sp"] = i.set_sp.into();
            // }
            if i.ind_width != 0 {
                inst_json["ind_width"] = i.ind_width.into();
            }
            // #[cfg(feature = "sp")]
            // if i.inc_sp != 0 {
            //     inst_json["inc_sp"] = i.inc_sp.into();
            // }
            if i.end {
                inst_json["end"] = i.end.into();
            }
            if i.a_src != 0 {
                inst_json["a_src"] = i.a_src.into();
            }
            if i.a_src == SRC_STEP {
                inst_json["a_src_step"] = json::JsonValue::from(1);
            }
            // #[cfg(feature = "sp")]
            // if i.a_src == SRC_SP {
            //     inst_json["a_src_sp"] = json::JsonValue::from(1);
            // }
            // #[cfg(feature = "sp")]
            // if i.a_use_sp_imm1 != 0 {
            //     inst_json["a_use_sp_imm1"] = i.a_use_sp_imm1.into();
            // }
            if i.a_offset_imm0 != 0 {
                inst_json["a_offset_imm0"] = i.a_offset_imm0.into();
            }
            if i.b_src != 0 {
                inst_json["b_src"] = i.b_src.into();
            }
            if i.b_src == SRC_IND {
                inst_json["b_src_ind"] = json::JsonValue::from(1);
            }
            // #[cfg(feature = "sp")]
            // if i.b_use_sp_imm1 != 0 {
            //     inst_json["b_use_sp_imm1"] = i.b_use_sp_imm1.into();
            // }
            if i.b_offset_imm0 != 0 {
                inst_json["b_offset_imm0"] = i.b_offset_imm0.into();
            }
            inst_json["is_external_op"] = i.is_external_op.into();
            inst_json["op"] = i.op.into();
            inst_json["opStr"] = i.op_str.into();
            if i.jmp_offset1 != 0 {
                inst_json["jmp_offset1"] = i.jmp_offset1.into();
            }
            if i.jmp_offset2 != 0 {
                inst_json["jmp_offset2"] = i.jmp_offset2.into();
            }
            if !i.verbose.is_empty() {
                inst_json["verbose"] = i.verbose.clone().into();
            }
            j["insts"][i.paddr.to_string()] = inst_json;
        }

        // Save RO data
        j["roData"] = json::JsonValue::new_array();
        for ro in &self.ro_data {
            let mut ro_json = json::JsonValue::new_object();
            ro_json["start"] = ro.from.into();
            let mut data_json = json::JsonValue::new_object();
            data_json["type"] = "Buffer".into(); // TODO: Ask Jordi
            data_json["data"] = json::JsonValue::new_array();
            for d in 0..ro.data.len() {
                let _ = data_json["data"].push(ro.data[d]);
            }
            ro_json["data"] = data_json;
            let _ = j["roData"].push(ro_json);
        }
    }

    /// Saves ZisK rom into a PIL data string
    pub fn save_to_pil(&self, s: &mut String) {
        // Clear output data, just in case
        s.clear();

        // Save instructions program addresses into a vector
        let mut keys: Vec<u64> = Vec::new();
        for key in self.insts.keys() {
            keys.push(*key);
        }

        // Sort the vector
        keys.sort();

        // For all program addresses in the vector, create a new PIL line describing the ZisK
        // instruction
        for key in &keys {
            let i = &self.insts[key].i;
            let rom_flags = i.get_flags();

            // #[cfg(feature = "sp")]
            // {
            //     *s += &format!(
            //         "romLine({},{},{},{},{},{},{},{},{},{},{}); // {}: {}\n",
            //         key,
            //         rom_flags,
            //         i.op,
            //         i.a_offset_imm0,
            //         i.b_offset_imm0,
            //         i.ind_width,
            //         i.store_offset,
            //         i.jmp_offset1,
            //         i.jmp_offset2,
            //         i.inc_sp,
            //         i.b_use_sp_imm1,
            //         i.op_str,
            //         i.verbose,
            //     );
            // }

            // #[cfg(not(feature = "sp"))]
            {
                *s += &format!(
                    "romLine({},{},{},{},{},{},{},{},{}); // {}: {}\n",
                    key,
                    rom_flags,
                    i.op,
                    i.a_offset_imm0,
                    i.b_offset_imm0,
                    i.ind_width,
                    i.store_offset,
                    i.jmp_offset1,
                    i.jmp_offset2,
                    i.op_str,
                    i.verbose,
                );
            }
        }
        println!(
            "ZiskRom::save_to_pil() {} bytes, {} instructions, {:02} bytes/inst",
            s.len(),
            keys.len(),
            s.len() as f64 / keys.len() as f64,
        )
    }

    /// Saves ZisK rom into a binary data vector
    pub fn save_to_bin(&self, v: &mut Vec<u8>) {
        // Clear output data, just in case
        v.clear();

        // Save instructions program addresses into a vector
        let mut keys: Vec<u64> = Vec::new();
        for key in self.insts.keys() {
            keys.push(*key);
        }

        // Sort the vector
        keys.sort();

        // For all program addresses in the vector, create a new binary slice describing the ZisK
        // instruction
        for key in &keys {
            let mut aux: [u8; 8];
            let i = &self.insts[key].i;
            let rom_flags = i.get_flags();
            aux = key.to_le_bytes();
            v.extend(aux);
            aux = rom_flags.to_le_bytes();
            v.extend(aux);
            v.push(i.op);
            aux = i.a_offset_imm0.to_le_bytes();
            v.extend(aux);
            aux = i.b_offset_imm0.to_le_bytes();
            v.extend(aux);
            aux = i.ind_width.to_le_bytes();
            v.extend(aux);
            aux = i.store_offset.to_le_bytes();
            v.extend(aux);
            aux = i.jmp_offset1.to_le_bytes();
            v.extend(aux);
            aux = i.jmp_offset2.to_le_bytes();
            v.extend(aux);
            // #[cfg(feature = "sp")]
            // {
            //     aux = i.inc_sp.to_le_bytes();
            //     v.extend(aux);
            //     aux = i.b_use_sp_imm1.to_le_bytes();
            //     v.extend(aux);
            // }
        }
        println!(
            "ZiskRom::save_to_bin() {} bytes, {} instructions, {:02} bytes/inst",
            v.len(),
            keys.len(),
            v.len() as f64 / keys.len() as f64,
        )
    }

    /// Saves ZisK rom into a file: first save to a JSON object, then convert it to string, then
    /// save the string to the file
    pub fn save_to_json_file(&self, file_name: &str) {
        let mut j = json::JsonValue::new_object();
        self.save_to_json(&mut j);
        let s = json::stringify_pretty(j, 1);
        let s_len = s.len();
        let path = std::path::PathBuf::from(file_name);
        let result = std::fs::write(path, s);
        if result.is_err() {
            panic!("ZiskRom::save_to_json_file() failed writing to file={}", file_name);
        }
        println!("ZiskRom::save_to_json_file() {} bytes", s_len);
    }

    /// Saves ZisK rom into a PIL file: first save to a string, then
    /// save the string to the file
    pub fn save_to_pil_file(&self, file_name: &str) {
        // Get a string with the PIL data
        let mut s = String::new();
        self.save_to_pil(&mut s);

        // Save to file
        let path = std::path::PathBuf::from(file_name);
        let result = std::fs::write(path, s);
        if result.is_err() {
            panic!("ZiskRom::save_to_pil_file() failed writing to file={}", file_name);
        }
    }

    /// Saves ZisK rom into a binary file: first save to a vector, then
    /// save the vector to the file
    pub fn save_to_bin_file(&self, file_name: &str) {
        // Get a vector with the ROM data
        let mut v: Vec<u8> = Vec::new();
        self.save_to_bin(&mut v);

        // Save to file
        let path = std::path::PathBuf::from(file_name);
        let result = std::fs::write(path, v);
        if result.is_err() {
            panic!("ZiskRom::save_to_bin_file() failed writing to file={}", file_name);
        }
    }

    /// Saves ZisK rom into an i64-64 assembly file: first save to a string, then
    /// save the string to the file
    pub fn save_to_asm_file(&self, file_name: &str) {
        // Get a string with the PIL data
        let mut s = String::new();
        self.save_to_asm(&mut s);

        // Save to file
        let path = std::path::PathBuf::from(file_name);
        let result = std::fs::write(path, s);
        if result.is_err() {
            panic!("ZiskRom::save_to_asm_file() failed writing to file={}", file_name);
        }
    }

    /// Saves ZisK rom into an i86-64 assembly data string
    pub fn save_to_asm(&self, s: &mut String) {
        // Clear output data, just in case
        s.clear();

        let mut ctx = ZiskAsmContext::default();

        *s += "emulator_execute:\n";

        // Save instructions program addresses into a vector
        let mut keys: Vec<u64> = Vec::new();
        for key in self.insts.keys() {
            keys.push(*key);
        }

        // Sort the vector
        keys.sort();

        // For all program addresses in the vector, create an assembly set of instructions with an
        // instruction label
        for k in 0..keys.len() {
            ctx.pc = keys[k];
            ctx.next_pc = if (k + 1) < keys.len() { keys[k + 1] } else { M64 };
            let instruction = &self.insts[&ctx.pc].i;

            // Instruction label
            *s += "\n";
            *s += &format!("pc_{:x}: /*{} */\n", ctx.pc, instruction.to_text().as_str());

            // Set register a content based on instruction a_src
            match instruction.a_src {
                SRC_C => {
                    *s += &format!("\tmov {}, {} /* a=SRC_C: a = c */\n", REG_A, REG_C);
                }
                SRC_MEM => {
                    if instruction.a_use_sp_imm1 == 0 {
                        *s += &format!(
                            "\tmov {}, [0x{:x}] /* a=SRC_MEM: a = mem[i.a_offset_imm0] */\n",
                            REG_A, instruction.a_offset_imm0
                        );
                    } else {
                        *s += &format!(
                            "\tmov {}, 0x{:x} /* a=SRC_MEM: address = i.a_offset_imm0 */\n",
                            REG_ADDRESS, instruction.a_offset_imm0
                        );
                        *s += &format!(
                            "\tadd {}, {} /* a=SRC_MEM: address += sp */\n",
                            REG_ADDRESS, REG_SP
                        );
                        *s += &format!(
                            "\tmov {}, [{}] /* a=SRC_MEM: a = mem[address] */\n",
                            REG_A, REG_ADDRESS
                        );
                    }
                }
                SRC_IMM => {
                    *s += &format!(
                        "\tmov {}, 0x{:x} /* a=SRC_IMM: a = i.a_offset_imm0 | (i.a_use_sp_imm1 << 32) */\n",
                        REG_A,
                        instruction.a_offset_imm0 | (instruction.a_use_sp_imm1 << 32)
                    );
                }
                SRC_STEP => {
                    *s += &format!("\tmov {}, {} /* a=SRC_STEP: a = step */\n", REG_A, REG_STEP);
                }
                _ => {
                    panic!("ZiskRom::source_a() Invalid a_src={} pc={}", instruction.a_src, ctx.pc)
                }
            }

            // Set register b content
            match instruction.b_src {
                SRC_C => {
                    *s += &format!("\tmov {}, {} /* b=SRC_C: b = c */\n", REG_B, REG_C);
                }
                SRC_MEM => {
                    if instruction.b_use_sp_imm1 == 0 {
                        *s += &format!(
                            "\tmov {}, [0x{:x}] /* b=SRC_MEM: b = mem[i.b_offset_imm0] */\n",
                            REG_B, instruction.b_offset_imm0
                        );
                    } else {
                        *s += &format!(
                            "\tmov {}, 0x{:x} /* b=SRC_MEM: address = i.b_offset_imm0 */\n",
                            REG_ADDRESS, instruction.b_offset_imm0
                        );
                        *s += &format!(
                            "\tadd {}, {} /* b=SRC_MEM: address += sp */\n",
                            REG_ADDRESS, REG_SP
                        );
                        *s += &format!(
                            "\tmov {}, [{}] /* b=SRC_MEM: b = mem[address] */\n",
                            REG_B, REG_ADDRESS
                        );
                    }
                }
                SRC_IMM => {
                    *s += &format!(
                        "\tmov {}, 0x{:x} /* b=SRC_IMM: b = i.b_offset_imm0 | (i.b_use_sp_imm1 << 32) */\n",
                        REG_B,
                        instruction.b_offset_imm0 | (instruction.b_use_sp_imm1 << 32)
                    );
                }
                SRC_IND => {
                    *s +=
                        &format!("\tmov {}, {} /* b=SRC_IND: address = a */\n", REG_ADDRESS, REG_A);
                    *s += &format!(
                        "\tadd {}, 0x{:x} /* b=SRC_IND: address += i.b_offset_imm0 */\n",
                        REG_ADDRESS, instruction.b_offset_imm0
                    );
                    if instruction.b_use_sp_imm1 != 0 {
                        *s += &format!(
                            "\tadd {}, {} /* b=SRC_IND: address += sp */\n",
                            REG_ADDRESS, REG_SP
                        );
                    }
                    match instruction.ind_width {
                        1 | 2 | 4 | 8 => {
                            // TODO: implement 1, 2 and 4
                            *s += &format!(
                                "\tmov {}, [{}] /* b=SRC_IND: b = mem[address] */\n",
                                REG_B, REG_ADDRESS
                            );
                        }
                        _ => panic!(
                            "ZiskRom::save_to_asm() Invalid ind_width={} pc={}",
                            instruction.ind_width, ctx.pc
                        ),
                    }
                }
                _ => panic!(
                    "ZiskRom::save_to_asm() Invalid b_src={} pc={}",
                    instruction.b_src, ctx.pc
                ),
            }

            // Execute operation, storing result is registers c and flag
            //*s += &format!("\t/* operation: (c, flag) = op(a, b) */\n");
            *s += Self::operation_to_asm(&mut ctx, instruction.op).as_str();

            // Store register c
            let mut value = REG_VALUE;
            match instruction.store {
                STORE_NONE => {
                    *s += &format!("\t/* STORE_NONE */\n");
                }
                STORE_MEM => {
                    if instruction.store_ra {
                        *s += &format!(
                            "\tmov {}, 0x{:x}/* STORE_MEM: (ra): value = pc + jmp_offset2 */\n",
                            REG_VALUE,
                            ctx.pc as i64 + instruction.jmp_offset2
                        );
                    } else {
                        //*s += &format!("\t/* STORE_MEM: value = c */\n");
                        value = REG_C;
                    }
                    if !instruction.store_use_sp {
                        *s += &format!(
                            "\tmov [0x{:x}], {} /* STORE_MEM: mem[i.store_offset] = value {}*/\n",
                            instruction.store_offset,
                            value,
                            if instruction.store_ra { "" } else { "= c " }
                        );
                    } else {
                        *s += &format!(
                            "\tmov {}, 0x{:x}/* STORE_MEM: address = i.store_offset */\n",
                            REG_ADDRESS, instruction.store_offset
                        );
                        *s += &format!(
                            "\tadd {}, {} /* STORE_MEM: address += sp */\n",
                            REG_ADDRESS, REG_SP
                        );
                        *s += &format!(
                            "\tmov [{}], {} /* STORE_MEM: mem[address] = value {}*/\n",
                            REG_ADDRESS,
                            value,
                            if instruction.store_ra { "" } else { "= c " }
                        );
                    }
                }
                STORE_IND => {
                    if instruction.store_ra {
                        *s += &format!(
                            "\tmov {}, 0x{:x} /* STORE_IND: (ra): value = pc + i.jmp_offset2 */\n",
                            REG_VALUE,
                            ctx.pc as i64 + instruction.jmp_offset2
                        );
                    } else {
                        //*s += &format!("\t/* STORE_IND: value = c */\n");
                        value = REG_C;
                    }
                    *s += &format!(
                        "\tmov {}, {} /* STORE_IND: address = i.store_offset */\n",
                        REG_ADDRESS, instruction.store_offset
                    );
                    if instruction.store_use_sp {
                        *s += &format!(
                            "\tadd {}, {} /* STORE_IND: address += sp */\n",
                            REG_ADDRESS, REG_SP
                        );
                    }
                    *s += &format!(
                        "\tadd {}, {} /* STORE_IND: address += a */\n",
                        REG_ADDRESS, REG_A
                    );

                    match instruction.ind_width {
                        1 | 2 | 4 | 8 => {
                            // TODO: implement 1, 2 and 4
                            *s += &format!(
                                "\tmov [{}], {} /* STORE_IND: mem[address] = value {}*/\n",
                                REG_ADDRESS,
                                value,
                                if instruction.store_ra { "" } else { "= c " }
                            );
                        }
                        _ => panic!(
                            "ZiskRom::save_to_asm() Invalid ind_width={} pc={}",
                            instruction.ind_width, ctx.pc
                        ),
                    }
                }
                _ => panic!(
                    "ZiskRom::save_to_asm() Invalid store={} pc={}",
                    instruction.store, ctx.pc
                ),
            }

            // Set pc
            ctx.jump_to_dynamic_pc = false;
            ctx.jump_to_static_pc = String::new();
            if instruction.set_pc {
                if ctx.c_is_always_zero {
                    *s += &format!(
                        "\tmov {}, 0x{:x} /* set_pc: pc = i.jmp_offset1 */\n",
                        REG_PC, instruction.jmp_offset1
                    );
                    ctx.jump_to_static_pc =
                        format!("\tjmp pc_{:x} /* jump to static pc */", instruction.jmp_offset1);
                } else {
                    *s += &format!("\tmov {}, {} /* set_pc: pc = c */\n", REG_PC, REG_C);
                    *s += &format!(
                        "\tadd {}, 0x{:x} /* set_pc: pc += i.jmp_offset1 */\n",
                        REG_PC, instruction.jmp_offset1
                    );
                    ctx.jump_to_dynamic_pc = true;
                }
            } else {
                if ctx.flag_is_always_zero {
                    if ctx.pc as i64 + instruction.jmp_offset2 != ctx.next_pc as i64 {
                        *s += &format!(
                            "\tadd {}, 0x{:x} /* set_pc: pc += i.jmp_offset2 */\n",
                            REG_PC, instruction.jmp_offset2
                        );
                        ctx.jump_to_dynamic_pc = true;
                    }
                } else if ctx.flag_is_always_one {
                    if ctx.pc as i64 + instruction.jmp_offset1 != ctx.next_pc as i64 {
                        *s += &format!(
                            "\tadd {}, 0x{:x} /* set_pc: pc += i.jmp_offset1 */\n",
                            REG_PC, instruction.jmp_offset1
                        );
                        ctx.jump_to_dynamic_pc = true;
                    }
                } else {
                    // Calculate the new pc
                    *s += &format!("\tcmp {}, 1 /* set_pc: flag == 1 ? */\n", REG_FLAG);
                    *s += &format!("\tjne pc_{:x}_flag_false /* flag == 1 ? */\n", ctx.pc);
                    *s += &format!(
                        "\tadd {}, 0x{:x} /* pc += i.jmp_offset1 */\n",
                        REG_PC, instruction.jmp_offset1
                    );
                    *s += &format!("\tjmp pc_{:x}_flag_done\n", ctx.pc);
                    *s += &format!("pc_{:x}_flag_false:\n", ctx.pc);
                    *s += &format!(
                        "\tadd {}, 0x{:x} /* pc += i.jmp_offset2 */\n",
                        REG_PC, instruction.jmp_offset2
                    );
                    *s += &format!("pc_{:x}_flag_done:\n", ctx.pc);
                    *s += &format!(
                        "\tadd {}, 0x{:x} /* pc += i.jmp_offset2 */\n",
                        REG_PC, instruction.jmp_offset2
                    );
                    ctx.jump_to_dynamic_pc = true;
                }
            }

            // Increment step counter
            *s += &format!("\tinc {} /* increment step */\n", REG_STEP);

            // Jump to new pc, if not the next one
            if instruction.end {
                *s += "\tjmp execute_end /* end */\n";
            } else if !ctx.jump_to_static_pc.is_empty() {
                *s += ctx.jump_to_static_pc.as_str();
            } else if ctx.jump_to_dynamic_pc {
                *s += "\t/* jump to dynamic pc */\n";
                *s += &format!("\tmov {}, 0x80000000 /* is pc a low address? */\n", REG_ADDRESS);
                *s += &format!("\tcmp {}, {}\n", REG_PC, REG_ADDRESS);
                *s += &format!("\tjb pc_{:x}_jump_to_low_address\n", ctx.pc);
                *s += &format!("\tsub {}, {} /* pc -= 0x80000000 */\n", REG_PC, REG_ADDRESS);
                *s += &format!("\tadd {}, map_pc_80000000 /* pc += map_pc_80000000 */\n", REG_PC);
                *s += &format!("\tjmp {} /* jump to pc */\n", REG_PC);
                *s += &format!("pc_{:x}_jump_to_low_address:\n", ctx.pc);
                *s += &format!("\tsub {}, 0x1000 /* pc -= 0x1000 */\n", REG_PC);
                *s += &format!("\tadd {}, map_pc_1000 /* pc += map_pc_1000 */\n", REG_PC);
                *s += &format!("\tjmp {} /* jump to pc */\n", REG_PC);
            }
        }

        *s += "\n";
        *s += "execute_end:\n";
        *s += "\tret\n";

        //*s += "\n";
        //*s += ".rodata\n";
        //for key in &keys {
        // Map fixed-length pc labels to real variable-length instruction labels
        // This is used to implement dynamic jumps, i.e. to jump to an address that is not
        // a constant in the instruction, but dynamically built as part of the emulation
        //*s += &format!("\tlog_{:x}_msg: .string \"pc={:x}\"\n", key, key);
        //break;
        //*s += &format!("log_{:x}_len equ $ -log.{:x}.msg\n", key, key);
        //}

        // For all program addresses in the vector, create an assembly set of instructions with a
        // map label
        *s += "\n";
        for key in &keys {
            // Map fixed-length pc labels to real variable-length instruction labels
            // This is used to implement dynamic jumps, i.e. to jump to an address that is not
            // a constant in the instruction, but dynamically built as part of the emulation
            *s += &format!("map_pc_{:x}: jmp pc_{:x}\n", key, key);
        }

        let mut lines = s.lines();
        let mut empty_lines_counter = 0u64;
        let mut map_label_lines_counter = 0u64;
        let mut pc_label_lines_counter = 0u64;
        let mut comment_lines_counter = 0u64;
        let mut code_lines_counter = 0u64;

        loop {
            let line_option = lines.next();
            if line_option.is_none() {
                break;
            }
            let line = line_option.unwrap();
            if line.is_empty() {
                empty_lines_counter += 1;
                continue;
            }
            if line.starts_with("map_pc_") {
                map_label_lines_counter += 1;
                continue;
            }
            if line.starts_with("pc_") {
                pc_label_lines_counter += 1;
                continue;
            }
            if line.starts_with("\t/*") {
                comment_lines_counter += 1;
                continue;
            }
            code_lines_counter += 1;
        }

        println!(
            "ZiskRom::save_to_asm() {} bytes, {} instructions, {:02} bytes/inst, {} map lines, {} label lines, {} comment lines, {} code lines, {:02} code lines/inst",
            s.len(),
            keys.len(),
            s.len() as f64 / keys.len() as f64,
            map_label_lines_counter,
            pc_label_lines_counter,
            comment_lines_counter,
            code_lines_counter,
            code_lines_counter as f64 / keys.len() as f64,
        )
    }

    fn operation_to_asm(ctx: &mut ZiskAsmContext, opcode: u8) -> String {
        // Set flags to false, by default
        ctx.flag_is_always_one = false;
        ctx.flag_is_always_zero = false;
        ctx.c_is_always_zero = false;

        // Declare a return string
        let mut s = String::new();
        let zisk_op = ZiskOp::try_from_code(opcode).unwrap();
        match zisk_op {
            ZiskOp::Flag => {
                s += &format!("\tmov {}, 0 /* Flag: c = 0 */\n", REG_C);
                ctx.c_is_always_zero = true;
                //s += &format!("\tmov {}, 1\n", REG_FLAG);
                ctx.flag_is_always_one = true;
            }
            ZiskOp::CopyB => {
                s += &format!("\tmov {}, {} /* CopyB: c = b */\n", REG_C, REG_B);
                //s += &format!("\tmov {}, 0\n", REG_FLAG);
                ctx.flag_is_always_zero = true;
            }
            ZiskOp::SignExtendB => {
                //s += &format!("\tmov {}, {}\n", REG_B_B, REG_B);
                //TODO: s += &format!("\tmovsx {}, {}\n", REG_C, REG_B_B);
                //s += &format!("\tmov {}, 0\n", REG_FLAG);
                ctx.flag_is_always_zero = true;
            }
            ZiskOp::SignExtendH => {
                //s += &format!("\tmov {}}, {}\n", REG_B_H, REG_B);
                //TODO: s += &format!("\tmovsx {}, {}\n", REG_C, REG_B_H);
                //s += &format!("\tmov {}, 0\n", REG_FLAG);
                ctx.flag_is_always_zero = true;
            }
            ZiskOp::SignExtendW => {
                //s += &format!("\tmov eax, {}\n", REG_B);
                s += &format!("\tcdqe\n");
                //TODO:s += &format!("\tmovsx {}, {}\n", REG_C, REG_B);
                //s += &format!("\tmov {}, 0\n", REG_FLAG);
                ctx.flag_is_always_zero = true;
            }
            ZiskOp::Add => {
                // call	<core::num::wrapping::Wrapping<u64> as core::ops::arith::Add>::add
                s += &format!("\tmov {}, {} /* Add: c = a */\n", REG_C, REG_A);
                s += &format!("\tadd {}, {} /* Add: c = c + b = a + b */\n", REG_C, REG_B);
                //s += &format!("\tmov {}, 0\n", REG_FLAG);
                ctx.flag_is_always_zero = true;
            }
            ZiskOp::AddW => {
                // call	<core::num::wrapping::Wrapping<i32> as core::ops::arith::Add>::add
                // cdqe
                s += &format!("\tadd {}, {}\n", REG_B, REG_A);
                s += &format!("\tcdqe\n");
                s += &format!("\tmov {}, {}\n", REG_C, REG_B);
                //s += &format!("\tmov {}, 0\n", REG_FLAG);
                ctx.flag_is_always_zero = true;
            }
            ZiskOp::Sub => {
                // call	<core::num::wrapping::Wrapping<u64> as core::ops::arith::Sub>::sub
                s += &format!("\tmov {}, {} /* Sub: c = a */\n", REG_C, REG_A);
                s += &format!("\tsub {}, {} /* Sub: c = c - b = c - a */\n", REG_C, REG_B);
                //s += &format!("\tmov {}, 0\n", REG_FLAG);
                ctx.flag_is_always_zero = true;
            }
            ZiskOp::SubW => {
                // call	<core::num::wrapping::Wrapping<i32> as core::ops::arith::Sub>::sub
                // cdqe
                s += &format!("\tsub {}, {}\n", REG_B, REG_A);
                s += &format!("\tcdqe\n");
                s += &format!("\tmov {}, {}\n", REG_C, REG_B);
                //s += &format!("\tmov {}, 0\n", REG_FLAG);
                ctx.flag_is_always_zero = true;
            }
            ZiskOp::Sll => {
                s += &format!("\tand {}, 63 /* Sll: b = b & 0x3f */\n", REG_B);
                s += &format!("\tmov {}, {} /* Sll: c = a */\n", REG_C, REG_A);
                s += &format!("\tshl {}, {} /* Sll: c = a << b */\n", REG_C, REG_B);
                //s += &format!("\tmov {}, 0\n", REG_FLAG);
                ctx.flag_is_always_zero = true;
            }
            ZiskOp::SllW => {
                // call	<core::num::wrapping::Wrapping<u32> as core::ops::bit::Shl<usize>>::shl
                // cdqe
                s += &format!("\tand {}, 63 /* SllW: b = b & 0x3f */\n", REG_B);
                s += &format!("\tmov {}, {} /* SllW: c = a_w */\n", REG_C_W, REG_A_W);
                s += &format!("\tshl {}, {} /* SllW: c = a_w << b */\n", REG_C, REG_B);
                //s += &format!("\tmov {}, 0\n", REG_FLAG);
                ctx.flag_is_always_zero = true;
            }
            ZiskOp::Sra => {
                // (((a as i64) >> (b & 0x3f)) as u64, false)
                s += &format!("\tand {}, 63 /* Sra: b = b & 0x3f */\n", REG_B);
                s += &format!("\tmov {}, {} /* Sra: c = a */\n", REG_C, REG_A);
                s += &format!("\tsar {}, {} /* Sra: c = a >> b */\n", REG_C, REG_B);
                //s += &format!("\tmov {}, 0\n", REG_FLAG);
                ctx.flag_is_always_zero = true;
            }
            ZiskOp::Srl => {
                s += &format!("\tand {}, 63 /* Srl: b = b & 0x3f */\n", REG_B);
                s += &format!("\tmov {}, {} /* Srl: c = a */\n", REG_C, REG_A);
                s += &format!("\tshr {}, {} /* Srl: c = a >> b */\n", REG_C, REG_B);
                //s += &format!("\tmov {}, 0\n", REG_FLAG);
                ctx.flag_is_always_zero = true;
            }
            ZiskOp::SraW => {
                // ((Wrapping(a as i32) >> (b & 0x3f) as usize).0 as u64, false)
                // call	<core::num::wrapping::Wrapping<i32> as core::ops::bit::Shr<usize>>::shr
                // cdqe
                s += &format!("\tand {}, 63 /* SraW: b = b & 0x3f */\n", REG_B);
                s += &format!("\tmov {}, {} /* SraW: c = a_w */\n", REG_C_W, REG_A_W);
                s += &format!("\tshr {}, {} /* SraW: c = a_w >> b */\n", REG_C, REG_B);
                //s += &format!("\tmov {}, 0\n", REG_FLAG);
                ctx.flag_is_always_zero = true;
            }
            ZiskOp::SrlW => {
                // call	<core::num::wrapping::Wrapping<u32> as core::ops::bit::Shr<usize>>::shr
                // cdqe
                s += &format!("\tand {}, 63 /* SrlW: b = b & 0x3f */\n", REG_B);
                s += &format!("\tmov {}, {} /* SrlW: c = a_w */\n", REG_C_W, REG_A_W);
                s += &format!("\tshr {}, {} /* SrlW: c = a_w >> b */\n", REG_C, REG_B);
                //s += &format!("\tmov {}, 0\n", REG_FLAG);
            }
            ZiskOp::Eq => {
                s += &format!("\tcmp {}, {} /* Eq: a == b ? */\n", REG_A, REG_B);
                s += &format!("\tje pc_{:x}_equal_true\n", ctx.pc);
                s += &format!("\tmov {}, 0 /* c = 0 */\n", REG_C);
                s += &format!("\tmov {}, 0 /* flag = 0 */\n", REG_FLAG);
                s += &format!("\tjmp pc_{:x}_equal_done\n", ctx.pc);
                s += &format!("pc_{:x}_equal_true:\n", ctx.pc);
                s += &format!("\tmov {}, 1 /* c = 1 */\n", REG_C);
                s += &format!("\tmov {}, 1 /* flag = 1 */\n", REG_FLAG);
                s += &format!("pc_{:x}_equal_done:\n", ctx.pc);
            }
            ZiskOp::EqW => {
                s += &format!("\tcmp {}, {} /* EqW: a == b ? */\n", REG_A_W, REG_B_W);
                s += &format!("\tje pc_{:x}_equal_w_true\n", ctx.pc);
                s += &format!("\tmov {}, 0 /* c = 0 */\n", REG_C);
                s += &format!("\tmov {}, 0 /* flag = 0 */\n", REG_FLAG);
                s += &format!("\tjmp pc_{:x}_equal_w_done\n", ctx.pc);
                s += &format!("pc_{:x}_equal_true:\n", ctx.pc);
                s += &format!("\tmov {}, 1 /* c = 1 */\n", REG_C);
                s += &format!("\tmov {}, 1 /* flag = 1 */\n", REG_FLAG);
                s += &format!("pc_{:x}_equal_w_done:\n", ctx.pc);
            }
            ZiskOp::Ltu => {
                s += &format!("\tcmp {}, {} /* Ltu: a == b ? */\n", REG_A, REG_B);
                s += &format!("\tjb pc_{:x}_ltu_true\n", ctx.pc);
                s += &format!("\tmov {}, 0 /* c = 0 */\n", REG_C);
                s += &format!("\tmov {}, 0 /* flag = 0 */\n", REG_FLAG);
                s += &format!("\tjmp pc_{:x}_ltu_done\n", ctx.pc);
                s += &format!("pc_{:x}_ltu_true:\n", ctx.pc);
                s += &format!("\tmov {}, 1 /* c = 1 */\n", REG_C);
                s += &format!("\tmov {}, 1 /* flag = 1 */\n", REG_FLAG);
                s += &format!("pc_{:x}_ltu_done:\n", ctx.pc);
            }
            ZiskOp::Lt => {
                s += &format!("\tcmp {}, {} /* Lt: a == b ? */\n", REG_A, REG_B);
                s += &format!("\tjl pc_{:x}_lt_true\n", ctx.pc);
                s += &format!("\tmov {}, 0 /* c = 0 */\n", REG_C);
                s += &format!("\tmov {}, 0 /* flag = 0 */\n", REG_FLAG);
                s += &format!("\tjmp pc_{:x}_lt_done\n", ctx.pc);
                s += &format!("pc_{:x}_lt_true:\n", ctx.pc);
                s += &format!("\tmov {}, 1 /* c = 1 */\n", REG_C);
                s += &format!("\tmov {}, 1 /* flag = 1 */\n", REG_FLAG);
                s += &format!("pc_{:x}_lt_done:\n", ctx.pc);
            }
            ZiskOp::LtuW => {
                s += &format!("\tcmp {}, {} /* LtuW: a == b ? */\n", REG_A_W, REG_B_W);
                s += &format!("\tjb pc_{:x}_ltuw_true\n", ctx.pc);
                s += &format!("\tmov {}, 0 /* c = 0 */\n", REG_C);
                s += &format!("\tmov {}, 0 /* flag = 0 */\n", REG_FLAG);
                s += &format!("\tjmp pc_{:x}_ltuw_done\n", ctx.pc);
                s += &format!("pc_{:x}_ltuw_true:\n", ctx.pc);
                s += &format!("\tmov {}, 1 /* c = 1 */\n", REG_C);
                s += &format!("\tmov {}, 1 /* flag = 1 */\n", REG_FLAG);
                s += &format!("pc_{:x}_ltuw_done:\n", ctx.pc);
            }
            ZiskOp::LtW => {
                s += &format!("\tcmp {}, {} /* LtW: a == b ? */\n", REG_A_W, REG_B_W);
                s += &format!("\tjl pc_{:x}_ltw_true\n", ctx.pc);
                s += &format!("\tmov {}, 0 /* c = 0 */\n", REG_C);
                s += &format!("\tmov {}, 0 /* flag = 0 */\n", REG_FLAG);
                s += &format!("\tjmp pc_{:x}_ltw_done\n", ctx.pc);
                s += &format!("pc_{:x}_ltw_true:\n", ctx.pc);
                s += &format!("\tmov {}, 1 /* c = 1 */\n", REG_C);
                s += &format!("\tmov {}, 1 /* flag = 1 */\n", REG_FLAG);
                s += &format!("pc_{:x}_ltw_done:\n", ctx.pc);
            }
            ZiskOp::Leu => {
                s += &format!("\tcmp {}, {} /* Leu: a == b ? */\n", REG_A, REG_B);
                s += &format!("\tpc_{:x}_jbe leu_true\n", ctx.pc);
                s += &format!("\tmov {}, 0 /* c = 0 */\n", REG_C);
                s += &format!("\tmov {}, 0 /* flag = 0 */\n", REG_FLAG);
                s += &format!("\tpc_{:x}_jmp leu_done\n", ctx.pc);
                s += &format!("pc_{:x}_leu_true:\n", ctx.pc);
                s += &format!("\tmov {}, 1 /* c = 1 */\n", REG_C);
                s += &format!("\tmov {}, 1 /* flag = 1 */\n", REG_FLAG);
                s += &format!("pc_{:x}_leu_done:\n", ctx.pc);
            }
            ZiskOp::Le => {
                s += &format!("\tcmp {}, {} /* Le: a == b ? */\n", REG_A, REG_B);
                s += &format!("\tjle pc_{:x}_lte_true\n", ctx.pc);
                s += &format!("\tmov {}, 0 /* c = 0 */\n", REG_C);
                s += &format!("\tmov {}, 0 /* flag = 0 */\n", REG_FLAG);
                s += &format!("\tjmp pc_{:x}_lte_done\n", ctx.pc);
                s += &format!("pc_{:x}_lte_true:\n", ctx.pc);
                s += &format!("\tmov {}, 1 /* c = 1 */\n", REG_C);
                s += &format!("\tmov {}, 1 /* flag = 1 */\n", REG_FLAG);
                s += &format!("pc_{:x}_lte_done:\n", ctx.pc);
            }
            ZiskOp::LeuW => {
                s += &format!("\tcmp {}, {} /* LeuW: a == b ? */\n", REG_A_W, REG_B_W);
                s += &format!("\tjbe pc_{:x}_leuw_true\n", ctx.pc);
                s += &format!("\tmov {}, 0 /* c = 0 */\n", REG_C);
                s += &format!("\tmov {}, 0 /* flag = 0 */\n", REG_FLAG);
                s += &format!("\tjmp pc_{:x}_leuw_done\n", ctx.pc);
                s += &format!("pc_{:x}_leuw_true:\n", ctx.pc);
                s += &format!("\tmov {}, 1 /* c = 1 */\n", REG_C);
                s += &format!("\tmov {}, 1 /* flag = 1 */\n", REG_FLAG);
                s += &format!("pc_{:x}_leuw_done:\n", ctx.pc);
            }
            ZiskOp::LeW => {
                s += &format!("\tcmp {}, {} /* LeW: a == b ? */\n", REG_A_W, REG_B_W);
                s += &format!("\tjle pc_{:x}_lew_true\n", ctx.pc);
                s += &format!("\tmov {}, 0 /* c = 0 */\n", REG_C);
                s += &format!("\tmov {}, 0 /* flag = 0 */\n", REG_FLAG);
                s += &format!("\tjmp pc_{:x}_lew_done\n", ctx.pc);
                s += &format!("pc_{:x}_lew_true:\n", ctx.pc);
                s += &format!("\tmov {}, 1 /* c = 1 */\n", REG_C);
                s += &format!("\tmov {}, 1 /* flag = 1 */\n", REG_FLAG);
                s += &format!("pc_{:x}_lew_done:\n", ctx.pc);
            }
            ZiskOp::And => {
                s += &format!("\tmov {}, {} /* And: c = a */\n", REG_C, REG_A);
                s += &format!("\tand {}, {} /* And: c = c AND b = a AND b */\n", REG_C, REG_B);
                //s += &format!("\tmov {}, 0 /* flag = 0 */\n", REG_FLAG);
                ctx.flag_is_always_zero = true;
            }
            ZiskOp::Or => {
                s += &format!("\tmov {}, {} /* Or: c = a */\n", REG_C, REG_A);
                s += &format!("\tor {}, {} /* Or: c = c OR b = a OR b */\n", REG_C, REG_B);
                //s += &format!("\tmov {}, 0 /* flag = 0 */\n", REG_FLAG);
                ctx.flag_is_always_zero = true;
            }
            ZiskOp::Xor => {
                s += &format!("\tmov {}, {} /* Xor: c = a */\n", REG_C, REG_A);
                s += &format!("\txor {}, {} /* Xor: c = c XOR b = a XOR b */\n", REG_C, REG_B);
                //s += &format!("\tmov {}, 0 /* flag = 0 */\n", REG_FLAG);
                ctx.flag_is_always_zero = true;
            }
            ZiskOp::Mulu => {
                // mulq
                // Unsigned full multiply of %rax by S
                // Result stored in %rdx:%rax
                s += &format!("\t/*mulq {}*/ /* Mulu */\n", REG_A);
                s += &format!("\tmov {}, {} /* Mulu */\n", REG_C, REG_B);
                //s += &format!("\tmov {}, 0\n", REG_FLAG);
                ctx.flag_is_always_zero = true;
            }
            ZiskOp::Muluh => {
                s += &format!("\t/*mulq {}*/ /* Muluh */\n", REG_A);
                s += &format!("\tmov {}, {} /* Muluh */\n", REG_C, REG_FLAG);
                //s += &format!("\tmov {}, 0\n", REG_FLAG);
                ctx.flag_is_always_zero = true;
            }
            ZiskOp::Mulsuh => {
                s += &format!("\t/*imulq {}*/ /* Mulsuh */\n", REG_A);
                s += &format!("\tmov {}, {} /* Mulsuh */\n", REG_C, REG_FLAG);
                //s += &format!("\tmov {}, 0\n", REG_FLAG);
                ctx.flag_is_always_zero = true;
            }
            ZiskOp::Mul => {
                s += &format!("\t/*imulq {}*/ /* Mul */\n", REG_A);
                s += &format!("\tmov {}, {} /* Mul */\n", REG_C, REG_B);
                //s += &format!("\tmov {}, 0\n", REG_FLAG);
                ctx.flag_is_always_zero = true;
            }
            ZiskOp::Mulh => {
                s += &format!("\t/*imulq {}*/ /* Mulh */\n", REG_A);
                s += &format!("\tmov {}, {} /* Mulh */\n", REG_C, REG_FLAG);
                //s += &format!("\tmov {}, 0\n", REG_FLAG);
                ctx.flag_is_always_zero = true;
            }
            ZiskOp::MulW => {
                s += &format!("\tmov {}, {} /* MulW */\n", REG_B_W, REG_B);
                s += &format!("\t/*imulq {}*/ /* MulW */\n", REG_A_W);
                s += &format!("\tmov {}, {} /* MulW */\n", REG_C, REG_B);
                //s += &format!("\tmov {}, 0\n", REG_FLAG);
                ctx.flag_is_always_zero = true;
            }
            ZiskOp::Divu => {
                s += &format!("\tcmp {}, 0 /* Divu */\n", REG_B);
                s += &format!("\tje pc_{:x}_divu_b_is_zerof\n", ctx.pc);
                s += &format!("\tmov {}, {}\n", REG_C, REG_B);
                s += &format!("\tmov {}, 0\n", REG_FLAG);
                s += &format!("\tmov {}, {}\n", REG_B, REG_A);
                s += &format!("\tdivq {}, 0\n", REG_C);
                s += &format!("\tmov {}, {}\n", REG_C, REG_B);
                s += &format!("\tmov {}, 0\n", REG_FLAG);
                s += &format!("\tje pc_{:x}_divu_donef\n", ctx.pc);
                s += &format!("pc_{:x}_divu_b_is_zero\n", ctx.pc);
                s += &format!("\tmov {}, 0xffffffffffffffff\n", REG_C);
                s += &format!("\tmov {}, 1\n", REG_FLAG);
                s += &format!("pc_{:x}_divu_done\n", ctx.pc);
            }
            ZiskOp::Remu => {
                s += &format!("\tcmp {}, 0 /* Remu *\n", REG_B);
                s += &format!("\tje pc_{:x}_remu_b_is_zerof\n", ctx.pc);
                s += &format!("\tmov {}, {}\n", REG_C, REG_B);
                s += &format!("\tmov {}, 0\n", REG_FLAG);
                s += &format!("\tmov {}, {}\n", REG_B, REG_A);
                s += &format!("\tdivq {}, 0\n", REG_C);
                s += &format!("\tmov {}, {}\n", REG_C, REG_FLAG);
                s += &format!("\tmov {}, 0\n", REG_FLAG);
                s += &format!("\tje pc_{:x}_remu_donef\n", ctx.pc);
                s += &format!("pc_{:x}_remu_b_is_zero\n", ctx.pc);
                s += &format!("\tmov {}, {}\n", REG_C, REG_A);
                s += &format!("\tmov {}, 1\n", REG_FLAG);
                s += &format!("pc_{:x}_remu_done\n", ctx.pc);
            }
            ZiskOp::Div => {
                s += &format!("\tcmp {}, 0 /* Div */\n", REG_B);
                s += &format!("\tje pc_{:x}_div_b_is_zerof\n", ctx.pc);
                s += &format!("\tmov {}, {}\n", REG_C, REG_B);
                s += &format!("\tmov {}, 0\n", REG_FLAG);
                s += &format!("\tmov {}, {}\n", REG_B, REG_A);
                s += &format!("\tidivq {}, 0\n", REG_C);
                s += &format!("\tmov {}, {}\n", REG_C, REG_B);
                s += &format!("\tmov {}, 0\n", REG_FLAG);
                s += &format!("\tje pc_{:x}_div_donef\n", ctx.pc);
                s += &format!("pc_{:x}_div_b_is_zero\n", ctx.pc);
                s += &format!("\tmov {}, 0xffffffffffffffff\n", REG_C);
                s += &format!("\tmov {}, 1\n", REG_FLAG);
                s += &format!("pc_{:x}_div_done\n", ctx.pc);
            }
            ZiskOp::Rem => {
                s += &format!("\tcmp {}, 0 /* Rem */\n", REG_B);
                s += &format!("\tje pc_{:x}_rem_b_is_zerof\n", ctx.pc);
                s += &format!("\tmov {}, {}\n", REG_C, REG_B);
                s += &format!("\tmov {}, 0\n", REG_FLAG);
                s += &format!("\tmov {}, {}\n", REG_B, REG_A);
                s += &format!("\tidivq {}, 0\n", REG_C);
                s += &format!("\tmov {}, {}\n", REG_C, REG_FLAG);
                s += &format!("\tmov {}, 0\n", REG_FLAG);
                s += &format!("\tje pc_{:x}_rem_donef\n", ctx.pc);
                s += &format!("pc_{:x}_rem_b_is_zero\n", ctx.pc);
                s += &format!("\tmov {}, {}\n", REG_C, REG_A);
                s += &format!("\tmov {}, 1\n", REG_FLAG);
                s += &format!("pc_{:x}_rem_done\n", ctx.pc);
            }
            ZiskOp::DivuW => {
                // TODO
                s += &format!("\tmov {}, 0 /* DivuW */\n", REG_C);
                s += &format!("\tmov {}, 0\n", REG_FLAG);
            }
            ZiskOp::RemuW => {
                // TODO
                s += &format!("\tmov {}, 0 /* RemuW */\n", REG_C);
                s += &format!("\tmov {}, 0\n", REG_FLAG);
            }
            ZiskOp::DivW => {
                // TODO
                s += &format!("\tmov {}, 0 /* DivW */\n", REG_C);
                s += &format!("\tmov {}, 0\n", REG_FLAG);
            }
            ZiskOp::RemW => {
                // TODO
                s += &format!("\tmov {}, 0 /* RemW */\n", REG_C);
                s += &format!("\tmov {}, 0\n", REG_FLAG);
            }
            ZiskOp::Minu => {
                s += &format!("\tcmp {}, {} /* Minu: compare a and b */\n", REG_A, REG_B);
                s += &format!("\tjb pc_{:x}_minu_a_is_below_bf\n", ctx.pc);
                s += &format!("\tmov {}, {} /* c = b */\n", REG_C, REG_B);
                s += &format!("\tjmp pc_{:x}_minu_a_is_not_belowf\n", ctx.pc);
                s += &format!("pc_{:x}_minu_a_is_below_b:\n", ctx.pc);
                s += &format!("\tmov {}, {} /* c = a */\n", REG_C, REG_A);
                s += &format!("pc_{:x}_minu_a_is_not_below_b:\n", ctx.pc);
                //s += &format!("\tmov {}, 0 /* flag = 0 */\n", REG_FLAG);
                ctx.flag_is_always_zero = true;
            }
            ZiskOp::Min => {
                s += &format!("\tcmp {}, {} /* Min: compare a and b */\n", REG_A, REG_B);
                s += &format!("\tjl pc_{:x}_min_a_is_below_bf\n", ctx.pc);
                s += &format!("\tmov {}, {} /* c = b */\n", REG_C, REG_B);
                s += &format!("\tpc_{:x}_jmp min_a_is_not_belowf\n", ctx.pc);
                s += &format!("pc_{:x}_min_a_is_below_b:\n", ctx.pc);
                s += &format!("\tmov {}, {} /* c = a */\n", REG_C, REG_A);
                s += &format!("pc_{:x}_min_a_is_not_below_b:\n", ctx.pc);
                //s += &format!("\tmov {}, 0 /* flag = 0 */\n", REG_FLAG);
                ctx.flag_is_always_zero = true;
            }
            ZiskOp::MinuW => {
                s += &format!("\tcmp {}, {} /* MinuW: compare a and b */\n", REG_A_W, REG_B_W);
                s += &format!("\tjb pc_{:x}_minuw_a_is_below_bf\n", ctx.pc);
                s += &format!("\tmov {}, {} /* c = b */\n", REG_C, REG_B);
                s += &format!("\tjmp pc_{:x}_minuw_a_is_not_below_bf\n", ctx.pc);
                s += &format!("pc_{:x}_minuw_a_is_below_b:\n", ctx.pc);
                s += &format!("\tmov {}, {} /* c = a */\n", REG_C, REG_A);
                s += &format!("pc_{:x}_minuw_a_is_not_below_b:\n", ctx.pc);
                //s += &format!("\tmov {}, 0 /* flag = 0 */\n", REG_FLAG);
                ctx.flag_is_always_zero = true;
            }
            ZiskOp::MinW => {
                s += &format!("\tcmp {}, {} /* MinW: compare a and b */\n", REG_A_W, REG_B_W);
                s += &format!("\tjl pc_{:x}_minw_a_is_below_bf\n", ctx.pc);
                s += &format!("\tmov {}, {} /* c = b */\n", REG_C, REG_B);
                s += &format!("\tjmp pc_{:x}_minw_a_is_not_below_bf\n", ctx.pc);
                s += &format!("pc_{:x}_minw_a_is_below_b:\n", ctx.pc);
                s += &format!("\tmov {}, {} /* c = a */\n", REG_C, REG_A);
                s += &format!("pc_{:x}_minw_a_is_not_below_b:\n", ctx.pc);
                //s += &format!("\tmov {}, 0 /* flag = 0 */\n", REG_FLAG);
                ctx.flag_is_always_zero = true;
            }
            ZiskOp::Maxu => {
                s += &format!("\tcmp {}, {} /* Maxu: compare a and b */\n", REG_A, REG_B);
                s += &format!("\tja pc_{:x}_maxu_a_is_below_bf\n", ctx.pc);
                s += &format!("\tmov {}, {} /* c = b */\n", REG_C, REG_B);
                s += &format!("\tjmp pc_{:x}_maxu_a_is_not_below_bf\n", ctx.pc);
                s += &format!("pc_{:x}_maxu_a_is_below_b:\n", ctx.pc);
                s += &format!("\tmov {}, {} /* c = a */\n", REG_C, REG_A);
                s += &format!("pc_{:x}_maxu_a_is_not_below_b:\n", ctx.pc);
                //s += &format!("\tmov {}, 0 /* flag = 0 */\n", REG_FLAG);
                ctx.flag_is_always_zero = true;
            }
            ZiskOp::Max => {
                s += &format!("\tcmp {}, {} /* Max: compare a and b */\n", REG_A, REG_B);
                s += &format!("\tjg pc_{:x}_max_a_is_below_bf\n", ctx.pc);
                s += &format!("\tmov {}, {} /* c = b */\n", REG_C, REG_B);
                s += &format!("\tjmp pc_{:x}_max_a_is_not_below_bf\n", ctx.pc);
                s += &format!("pc_{:x}_max_a_is_below_b:\n", ctx.pc);
                s += &format!("\tmov {}, {} /* c = a */\n", REG_C, REG_A);
                s += &format!("pc_{:x}_max_a_is_not_below_b:\n", ctx.pc);
                //s += &format!("\tmov {}, 0 /* flag = 0 */\n", REG_FLAG);
                ctx.flag_is_always_zero = true;
            }
            ZiskOp::MaxuW => {
                s += &format!("\tcmp {}, {} /* MaxuW: compare a and b */\n", REG_A_W, REG_B_W);
                s += &format!("\tja pc_{:x}_maxuw_a_is_below_bf\n", ctx.pc);
                s += &format!("\tmov {}, {} /* c = b */\n", REG_C, REG_B);
                s += &format!("\tjmp pc_{:x}_maxuw_a_is_not_below_bf\n", ctx.pc);
                s += &format!("pc_{:x}_maxuw_a_is_below_b:\n", ctx.pc);
                s += &format!("\tmov {}, {} /* c = a */\n", REG_C, REG_A);
                s += &format!("pc_{:x}_maxuw_a_is_not_below_b:\n", ctx.pc);
                //s += &format!("\tmov {}, 0 /* flag = 0 */\n", REG_FLAG);
                ctx.flag_is_always_zero = true;
            }
            ZiskOp::MaxW => {
                s += &format!("\tcmp {}, {} /* MaxW: compare a and b */\n", REG_A_W, REG_B_W);
                s += &format!("\tjg pc_{:x}_maxw_a_is_belowf\n", ctx.pc);
                s += &format!("\tmov {}, {} /* c = b */\n", REG_C, REG_B);
                s += &format!("\tjmp pc_{:x}_maxw_a_is_not_below_bf\n", ctx.pc);
                s += &format!("pc_{:x}_maxw_a_is_below_b:\n", ctx.pc);
                s += &format!("\tmov {}, {} /* c = a */\n", REG_C, REG_A);
                s += &format!("pc_{:x}_maxw_a_is_not_below_b:\n", ctx.pc);
                //s += &format!("\tmov {}, 0 /* flag = 0 */\n", REG_FLAG);
                ctx.flag_is_always_zero = true;
            }
            ZiskOp::Keccak => {
                // TODO
                s += &format!("\tmov {}, 0 /* Keccak */\n", REG_C);
                s += &format!("\tmov {}, 0\n", REG_FLAG);
            }
            ZiskOp::PubOut => {
                // TODO
                s += &format!("\tmov {}, 0 /* PubOut */\n", REG_C);
                s += &format!("\tmov {}, 0\n", REG_FLAG);
            }
        }
        s
    }
}
